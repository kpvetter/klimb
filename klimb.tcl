#!/bin/sh
# Restart with tcl: -*- mode: tcl; tab-width: 8; -*- \
exec tclsh $0 ${1+"$@"} & \
exit

##+##########################################################################
#
# KLIMB: Keith's deLuxe Interactive Map Builder
# an interactive bike map and route planner
# by Keith Vetter
#
# For copyright and copying information see procedure ::About::License below.
#
package require Tcl 8.4
package require Tk
wm withdraw .
package provide app-klimb 1.0			;# For starkits
if {! $tcl_interactive} {
    source packages/tkconclient.tsh
    tkconclient::start 9876
}


set state(progname) KLIMB
set state(version) 4.40
set state(build) ""				;# Gets set in ::Init::Init

# TODO
#  popup menu cancels balloon
#  arrow off in klimb.rc not working
#  edit::getNextId off by 1
#
# TERRASERVER replacement -- USGS services
#  https://viewer.nationalmap.gov/services/
#
# Mac OSX and stippling bugs
#  Regions::Select  done
#  SnapShot
#  Atlas


# Output from KLIMB
#  print
#  snapshot
#  atlas
#  Google Earth
#  Google Maps
#  profile print
#  profile snapshot
#  normal description
#  table description
#  GPS exchange


# BUGS & IDEAS
# multiple regions
# distance text & Gradient text not aligned in profile dialog

# Display::DoScale when width < 1 mile
# LOESS curve fitting(?)
# clear doesn't clear route info vitals
# bug w/ routing to a node w/o altitude
# print orientation uses bad values for margins
# zoom waypoints and mouse move
# u-turn arrow user-create
# create road to...
# zoom road's initial position


# Pixane for image stuff
# http://www.evolane.com/software/pixane/
# http://www.evolane.com/software/pixane/pixane.html
# http://www.evolane.com/software/pixane/pixfont.html

# ::Display::coords(zone,*) get converted to LATLON from UTM
#    - initially set by ::Display::BboxAll
#    - changed by ::Region::Display to latlon

# zoom: annotations?
# GPS: track 1 is not visible error message
# PDF and non-ASCII characters (arrows)
# PDF consolidation
# Zoom arrow size changes with zoom level
# Zoom: estimates off for metric

################################################################
#
# Other bike mapping software
#
# http://bikehacks.com/55-free-bike-route-mapping-tools/ -- lists bike tools
# http://massklimb.blogspot.com/  -- KLIMB in MA
# http://bikemaster.home.att.net/index.htm -- general purpose program
# http://www.opencyclemap.org/
#
# Google Mashups
#   http://mapmyride.com/
#   http://www.bikely.com/
#   http://www.routeslip.com/ => now http://mapmyride.com
#   http://www.cyclistnexus.com
#   http://www.sueandpaul.com/gmapPedometer/ => http://www.gmap-pedometer.com/
#   http://www.walkjogrun.net
#   http://www.everytrail.com/
#   http://www.routeyou.com
#
# GPS based software
#   http://www.gpsvisualizer.com/
#   http://www.montebellosoftware.com/ (MAC only)
#   http://www.motionbased.com/
#   http://www.zonefivesoftware.com/SportTracks/

# http://gisdata.usgs.net/XmlWebServices/TNM_Elevation_Service.php
# http://www.spectrumwatch.com/engineering/tools/SingleElevation.asp

# http://groups.google.com/group/comp.infosystems.gis/browse_frm/thread/402950bd70f0b0e0/f756a736eefed2d0?lnk=st&q=%22centerline+data%22&rnum=17#f756a736eefed2d0

# History of bicycles
# http://www.crazyguyonabike.com/doc/page/?o=QzzM&page_id=40615&v=8t

# http://www.lickingcountybicycleclub.com/id27.html
# Calories/hr = [V*W(.0053 + %G/100) + .0083(V^3)]*7.2
# Where V is speed, W is the weight of the bike and cyclist in pounds and
# %G is grade in percent. The .0053 is for friction + rolling resistance
# and .0083 is for aerodynamic drag. These are not absolute and will vary
# under different conditions but acceptable for this formula.  A clunker bike,
# inefficient cyclist position on the bike or inefficient drive train use
# would change things a bit. You can use the formula to calculate your calorie
# burn going up Chickencoop Road or the bike path.  Kind of fun.

# http://www.ngs.noaa.gov/TOOLS/Nadcon/Nadcon.html -- NAD27 -> WGS84 conversion

# mac deliverable: http://tk-components.sourceforge.net/tk-bundle-tutorial/index.html
# http://wiki.tcl.tk/12987 see #6 & 6.2
# http://anoved.net/2007/12/minimal-tcltk-mac-application-packages.html

######
# Journalling software
#
# http://www.bikejournal.com/
# http://www.mycyclinglog.com/
# http://connect.garmin.com/
# http://motionbased.com/
# http://www.zonefivesoftware.com/SportTracks/
# mapmyride.com
# Bike City on Facebook
# Fitday



# BUG:
#  RideLog: 1) bad after region change
# clear within::last when updating gis data
# profile trace wrong if route changes
# print box and scrolling
# if default region not present, no error message
# setting a route when Within is up
# clearroute, undo clears title from Route::Load
# setting metric doesn't update trace/profile/within/etc. dialog
#
# TODO:
#   starkit/starpacks for unix/mac see http://tcl.tk/starkits/
#                                      http://www.equi4.com/tclkit/

# PDF:
#  pdf4tcl    -- atlas: drawing commands into pdf
#  trampoline -- profile: canvas to pdf
#  Text2PDF   -- description: text into pdf

# emacs tags: c:\emacs-23.1\bin\etags --language=none --regex="/proc[ \t]+\([^ \t]+\)/\1/" klimb.tcl

# Potential features
#  o multiple simultaneous routes
#  o email routes to people
#  o start up at a different location?
#  o more ride log features
#  o show partial dirt roads as part red
#  o speed up: loading all.nodes
#
# Known bugs
#  o unix: splash quote overflow
#  o unix: geometry push title bar off the window
#
# Revisions:
# KPV Jul 25, 2001 - initial revision
# KPV Oct 03, 2001 - rotating quotes in splash window
# KPV Oct 04, 2001 - route tracing animation
# KPV Oct 05, 2001 - ride log
# KPV Oct 11, 2001 - profile window resizable
# KPV Oct 29, 2001 - made about/splash window less font size dependant
# version 0.61 released 10/31/01
# KPV Nov 01, 2001 - added scroll bar to description window
# KPV Nov 01, 2001 - GUI tweaks for Unix
# version 0.62 released 11/01/01
# KPV Nov 09, 2001 - handles regions defined externally;
#		     added Marin & South Bay regions; new overview map
#		     SaveUserData; optional running totals in description
# version 0.63 released 11/10/01
# KPV Nov 11, 2001 - bug fix for map names missing extension
# version 0.64 released 11/11/01
# KPV Nov 13, 2001 - smaller overview map; images in own namespace
# KPV Nov 16, 2001 - progress bars on map loading; maps off TOPO! cdrom
# KPV Nov 20, 2001 - all map data from *.klr file; trace in profile window;
#		     new road type--user; put procs into namespaces
# version 0.70 released internally 11/20/01
# KPV Nov 21, 2001 - eliminated window resize/redraw upon loading a region;
#		     new overview map; GUI disable during region loading;
#		     dashes for incomplete roads; centered splash quotes
# version 0.71 released internally 11/21/01
# KPV Dec 27, 2001 - all of Bushnell's data is entered and sanity checked;
#		     node size smaller for smaller scale maps; scroll region
#		     bounded to map size; clip roads & nodes to the map (plus
#		     all adjoining nodes); revamped regions; made freeware;
# KPV Jan  7, 2002 - always read user.nodes; SaveUserData; optimized nodelist
#		     which was becoming real bulky and slow; region name lookup
#		     improved
# KPV Jan  7, 2002 - beta version 0.72b released
# KPV Jan  7, 2002 - added graphical region selection
# KPV Jan  7, 2002 - beta version 0.73b released
# KPV Jan  8, 2002 - smarter command line region handling; canvas coordinates
#		     now "eval'ed" rather than being a list for tk8.2 compat;
#		     version 0.74b released to Jef Poskanzer [jef@acme.com]
# KPV Jan 10, 2002 - curvy roads; route turnings; clipped nodes;
#		     multiple regions; starting w/ route file bug;
#		     version 0.75b released to Steven Prothero spro@pacbell.net
# KPV Jan 11, 2002 - profile cutoff; detailed profiles; trace cancel;
#		     tweaks to descriptions especially "normal" description;
#		     omit turns implemented; loading multi-region routes
# KPV Jan 16, 2002 - trace follows curvy lines; better handling of no regions
#		     version 0.76b released
# KPV Jan 16, 2002 - configuration file
#		     version 0.77b released
# KPV Jan 18, 2002 - more complete customize dialog
#		     version 0.78b released
# KPV Jan 22, 2002 - made help and license dialogs scrollable so they fit
#		     on the screen; node list title was incorrect; initial
#		     size fixed for small screens
# KPV Jan 23, 2002 - added revision info to route files
#		     version 1.0 released
################################################################
# KPV Feb 05, 2002 - multiple roads between the same nodes; new help system;
#		     view ride log; datefield & timefield in ride log edit;
#		     wrapped exe includes BWidgets and tktable
# KPV Feb 24, 2002 - turned all unknown numbers into 3.3+? format
# KPV May 31, 2002 - space delimited descriptions
# KPV Jun 18, 2002 - fixed up resizing ridelog; added lots more quotes; POI
# KPV              - split roads; zones; multiple overview maps w/ labels;
#                    POI in nodelist; spaces in region names
# KPV Oct 04, 2002 - added printing
# KPV Mar 24, 2003 - zone.data also defines default region; added default zone
#                    to RC file; user.data into zone directory; route files
#                    only loadable in same zone
# KPV Jul 15, 2003 - removed bwidgets by replacing titleframe w/ labelframe;
#                    new about dialog images
# KPV Jul 18, 2003 - zoom out; -z (zone) command line option;
#                    freewrap requires absolute paths, needed indirection;
#                    customize zone,default & new road Road type now optionMenus
#                    better focus handling in date/time fields
#                    cleaned up Within: dialog, ShortestPath, balloon help;
#                    wrote labelframe clone for freewrap; within dialog;
#                    icons; handle argv0 not equal to klimb
# KPV Jul 25, 2003 - released v2.0.b1
# KPV Jul 28, 2003 - missing some images in freewrap version;
#                    changed to klimb.gif icon in dialogs;
#                    bug w/ LocateZoneFile; bug w/ new road & road type;
#                    overview labels uses -textvariable; removed eval on canvas;
#                    Advanced region select for parks (::Region::Walk fixed)
# KPV Aug  9, 2003 - optionMenus for colors in customize
# KPV Aug 11, 2003 - accumulated climbing in profile graph; zigzag turns;
#                    smaller font in nodes; RideLog view bug fix; comma bug;
#                    better handling of incomplete road climbing info;
#                    route description now uses "about 2 miles" vs "2+? miles";
#                    menu bug wrong entryconfig number for disabling;
#                    minimal description
# KPV Aug 25, 2003 - better distance guessing based on great circle distance;
#                    support starpack vs freewrap because of bugs in freewrap;
#                    better registry handling; single track road type
# KPV Aug 29, 2003 - removed freewrap and added starpack;
#                    zone names in zone.data; any mag in advanced region select
# KPV Sep  1, 2003 - legend window; view menu; more road types; zone rc files
#                    removed tktable freewrap loading; use tkcon for console
# KPV Sep  7, 2003 - Coordinate locator; smarter map deletion; hidebad zone.data
#                    floating point divide by zero error in trace;
#                    better new node/road numbering; ride description printing;
#                    superuser pane in options dialog;
# KPV Sep 16, 2003 - gave 2.0.b3 version to Todd
# KPV Sep 18, 2003 - xyz info for road, superuser AddAlt functionality;
#                    bug fix w/ omit node from description
# KPV Sep 26, 2003 - ride log show all; data quality & hidebad on scale 0-4;
#                    region revert; options data quality (read only)
# KPV Oct  3, 2003 - data quality help; z data into profile; su & data quality;
#                    profile balloon help on roads; hidebad => goodData
# KPV Oct 14, 2003 - ReadMapData only uses foreach and not scan; trails
# KPV Oct 15, 2003 - Muskingum County (start); merge regions maps not sorted;
#                    fixed within to use Dijkstra's algorithm;
#                    magnification labels set in region file;
#                    .klm format simpler
# KPV Oct 17, 2003 - METRIC (except RideLog & loading metric files);
#                    multiple node files;
#                    select region button disabled when nothing is selected
# KPV Oct 21, 2003 - Released v2.0
################################################################
# KPV Oct 29, 2003 - node font now {times 6}, add to customize?
# KPV Nov 19, 2003 - added missing continue after reading "mag=" .klr line
# KPV Dec 02, 2003 - bug w/ zooming multi region
# KPV Dec 12, 2003 - 7 new about images
# KPV Dec 18, 2003 - overview label; first map attribute
# KPV Jan 06, 2004 - update dialogs on unit change
# KPV Jan 15, 2004 - for faster startup defer balloon help creation until needed
#                    cleaned up badmath stuff; default zone was wrong
# KPV Jan 20, 2004 - fixed multiple region prompt message
# KPV Feb 06, 2004 - added PayPal button on About dialog -- v2.03
# KPV Feb 08, 2004 - added printing via Michael Schwartz's GDI extension
#                    v2.10b beta release
# KPV Feb 09, 2004 - made Dijkstra faster; front-end dialog for printing
# KPV Feb 12, 2004 - scale; zoomout cancel on zone; "continue on" description;
#                    RideLog creation speedup; new zone closes popups; GPX
# KPV Feb 16, 2004 - GPX includes road bends
# KPV Mar 01, 2004 - Waypoint on customize dialog
# KPV Mar 15, 2004 - start of UTM projection maps
# KPV Mar 26, 2004 - v2.10b3 beta release
# KPV Mar 30, 2004 - print stuff: automatic orientation & print selection
#                    v2.10b4 beta release
# KPV Mar 31, 2004 - RideLog climbing density; unbent all the roads;
# KPV Apr 03, 2004 - ridelog stats and whitespace; cleaned up balloon help
# KPV Apr 22, 2004 - better x-axis ticks on profile graph
#                    thanks Cesar Crusius crusius@delgesu.net
# KPV May 11, 2004 - Annotations
# KPV Sep 01, 2004 - bug: button bar/status bar state incorrect on new region;
#                    updating node alt now updates climbing guesses;
#                    bug: isolated node & node neighborhood
#                    fix loose ends in annotations; datefield update
# KPV October, 2004 -
#    mouse wheel, tracks, hills, XML, geocache, about popup menu;
#    options zoom cache, standardized most dialogs; gps hill in profile;
#    autoproxy; kcode.tcl; detailed route annotations;
#    zoom shows estimated distance; ridelog filter
#
# KPV January, 2005 - bike quote dialog; fix rc handling; config starting size;
#     zoom on right button menu; printing turn on via annotation
# KPV Feb 12, 2005  - v3.0b1 released
# KPV Mar 9,14, 2005 - urban zoom; profile trace metric bug; trace biker;
#     zoom bug not deleting rtepts; geocache dialog; xml using tdom;
#     rainbow progressbar; ridelog filter and matching regions; region info;
#     revamped saving user data; 3d profile; copyright; email feedback
# KPV Apr 5, 2005 - release 3.00b3
# KPV Apr 5, 2005 - bug fix in coord locator; label stats
# KPV Apr 11, 2005 - better profile for small elevation change
# KPV Apr ??, 2005 - view online w/ Google
# KPV Apr 27, 2005 - dns resolve terraserver host
# KPV Jun 26, 2005 - added some more About images
# KPV Feb 02, 2006 - show bad data; tile buttons; button bar w/ images;
#     annotate bug w/ update; annotate follows data quality
set WHATSNEW(4.0) {
    # KPV Feb 06, 2006 - *Release version 3.05
    # KPV Feb 07, 2006 - trace & describe bug fix w/ cleared routes
    # KPV Feb 08, 2006 - *Snapshot; route profile save as image
    # KPV Feb 08, 2006 - tile scale; edit dialog box moved some buttons
    # KPV Feb 12, 2006 - released 3.06
    # KPV Feb 14, 2006 - fixed zip version: missing buttonbar images, pgu
    # KPV Mar 01, 2006 - shadow on the about image; removed dns resolve shortcut
    # KPV Mar 02, 2006 - zoom any point; changed google for point
    # KPV Mar 03, 2006 - added bike path road type; added beta dialog
    # KPV Mar 10, 2006 - added 5 more about images
    # KPV Mar 11, 2006 - added picture gallery
    # KPV Apr 05, 2006 - faster calculating zoom cache size
    # KPV Apr 06, 2006 - *Query USGS for a node or route point elevation
    # KPV Apr 10, 2006 - node info dialog displays region node is in
    # KPV Apr 13, 2006 - animated gif support; internal reorg of capabilities
    # KPV Apr 14, 2006 - data sanity check for superuser
    # KPV Apr 15, 2006 - released version 3.07B
    # KPV May 01, 2006 - *Profile labels
    # KPV May 06, 2006 - RideLog bug with octal looking numbers
    # KPV Jun 08, 2006 - Snapshot border and copyright notice
    # KPV Jun 16, 2006 - *Time in tracing and description
    # KPV Jun 22, 2006 - *User select columns for route description
    # KPV Jun 22, 2006 - notebook widget for config
    # KPV Jun 23, 2006 - font configuration; better package handling
    # KPV Aug 31, 2006 - annotation font config; swaplist for route config
    # KPV Sep 02, 2006 - skip profile label for skipped nodes
    # KPV Sep 15, 2006 - zoom updates distance & climbing dynamically
    # KPV Sep 17, 2006 - *Zoom: USGS elevation for all waypoints
    # KPV Sep 18, 2006 - *3d profiles
    # KPV Sep 18, 2006 - save profiles images as GIFs
    # KPV Sep 20, 2006 - 3d profile configurable in direction and size
    # KPV Jan 30, 2007 - *Weather forecast
    # KPV Mar 26, 2007 - better node labels in profile and description
    # KPV Apr 04, 2007 - keep Z info when splitting a road, saving routes & log
    # KPV Apr 09, 2007 - *Hills dialog
    # KPV Apr 10, 2007 - improved help and route description
    # KPV Apr 20, 2007 - split roads from zoom window
    # KPV May 20, 2007 - *Mileposts
    # KPV Jun 11, 2007 - *Photo
    # KPV Jun 19, 2007 - improve viewing roads on google maps
    # KPV Jun 21, 2007 - *Route Info dialog
    # KPV Jun 22, 2007 - *View route on Google Earth
    # KPV Jun 24, 2007 - tools menu split into route and tools menus
    # KPV Jul 05, 2007 - *View route with Google Maps
    # KPV Jul 11, 2007 - *Released version 4.0
    # KPV Sep 21, 2007 - fixed loading route bug with bad magnification
    # KPV Jul 11, 2007 - -Released version 4.01
}
set WHATSNEW(4.10) {
    # KPV Oct 03, 2007 - zoom road color now configurable; weather dialog tweaks
    # KPV Oct 04, 2007 - zoom limits total rendered cells
    # KPV Oct 16, 2007 - *PDF output of profile and description
    # KPV Oct 23, 2007 - *Route atlas
    # KPV Oct 24, 2008 - *Route arrows
    # KPV Oct 29, 2007 - *Zoom route
    # KPV Oct 31, 2007 - route arrows saved when route is saved
    # KPV Nov 01, 2007 - route arrows in zoom window for route
    # KPV Nov 03, 2007 - milepost in zoom window for route
    # KPV Nov 04, 2007 - better mac handling of button-3
    # KPV Nov 08, 2007 - -tcl 8.5 bug fixes
    # KPV Nov 11, 2007 - config allows default per page
    # KPV Nov 13, 2007 - -what's new understands versions
    # KPV Nov 13, 2007 - *Computing gradients from profile graph
    # KPV Nov 23, 2007 - delete profile label with right click
    # KPV Nov 28, 2007 - -changed web browser invoke for windows
    # KPV Feb 22, 2008 - *released 4.10
}
set WHATSNEW(4.11) {
    # KPV Feb 28, 2008 - -fixed crash when started as wish script
    # KPV Feb 28, 2008 - -tcl 8.5 fix for text widget default font
    # KPV Feb 28, 2008 - google earth/maps user control of showing nodes
    # KPV Feb 29, 2008 - -some gallery pictures were being dropped
    # KPV Mar 04, 2008 - -copyright on atlas pdf
    # KPV Mar 07, 2008 - scrolling via overview windows
    # KPV Mar 08, 2008 - save route description as web page
    # KPV Mar 08, 2008 - -fixed description turn label for start and end nodes
    # KPV Mar 10, 2008 - -consolidated tab & space delimited into table
    # KPV Mar 10, 2008 - fixed bug in legend and showing trails
    # KPV Mar 10, 2008 - sexier table format route description
    # KPV Mar 18, 2008 - added photos to node list
    # KPV Mar 18, 2008 - fixed bug with splitting a road
    # KPV Mar 21, 2008 - fixed ridelog load bug
    # KPV Mar 25, 2008 - -zoom move bug (not using centroid)
    # KPV Mar 25, 2008 - -coord locator cosmetic change
    # KPV Mar 26, 2008 - go/end icons for route arrows
    # KPV Mar 26, 2008 - trace speed independent of map scale
    # KPV Mar 28, 2008 - better arrows for route description
    # KPV Mar 29, 2008 - -google map tweaks
    # KPV Mar 29, 2008 - node renumber dialog for superusers
    # KPV Apr 07, 2008 - configure description now on Description window menu
    # KPV Apr 07, 2008 - -ridelog filter recognizes bare year
    # KPV Apr 07, 2008 - -fixed bug with mal-formed NOAA weather data
}
set WHATSNEW(4.20) {
    # KPV Apr 10, 2008 - *favorites dialog
    # KPV Apr 11, 2008 - *extend route--connect to any node via shortest path
    # KPV Apr 14, 2008 - -cleaned up menu creation
    # KPV Apr 15, 2008 - -minor unix tweaks: splash msg, about dialog
    # KPV Apr 18, 2008 - route description computes route turns for you
    # KPV Apr 21, 2008 - -sync TOC while navigating help
    # KPV Apr 23, 2008 - -split road not updating visible road list
    # KPV Apr 23, 2008 - -zoom insert waypoint (aid for better profile)
    # KPV Apr 24, 2008 - -what's new minor tweaks
    # KPV Apr 24, 2008 - *update favorites from KLIMB web site
    # KPV May 10, 2008 - atlas can add profile graph or any user image
    # KPV May 13, 2008 - -fully implemented tile widget set
    # KPV May 13, 2008 - -Atlas works w/o rotation on Unix
    # KPV May 13, 2008 - -Zoom cache size progress displayed while computing
    # KPV May 14, 2008 - Balloon help highlights road/node
    # KPV May 15, 2008 - Arrow dialog updates main window as you edit
    # KPV Jun 03, 2008 - favorites dialog shows arrow in sorted column
    # KPV Jun 03, 2008 - new go & end sign when start/end are the same
    # KPV Jun 04, 2008 - *Update nodes and favorites from KLIMB's website
    # KPV Jun 04, 2008 - -cleaned up Weather's download code
    # KPV Jun 05, 2008 - Cursor change on middle-button scrolling
    # KPV Jun 07, 2008 - -bug fix with version tcl 8.4 and tile
    # KPV Jun 07, 2008 - -bug fix with ridelog filter
    # KPV Jun 13, 2008 - -bug fix with route description and unknown data
    # KPV Jun 13, 2008 - -bug fix in weather w/ icon not being updated correctly
    # KPV Jun 18, 2008 - better printing page size computing (w/ test page)
    # KPV Jun 20, 2008 - *Email routes
    # KPV Jun 21, 2008 - atlas rotation locks into 90 degrees if near
    # KPV Jun 23, 2008 - better print page fit
    # KPV Jul 02, 2008 - -bug fix with showing stop/end sign when loading route
    # KPV Jul 02, 2008 - -bug fix with updating profile labels
    # KPV Jul 21, 2008 - -USGS moved its web service page
    # KPV Jul 21, 2008 - release 4.20
}
set WHATSNEW(4.30) {
    # KPV Dec 01, 2008 - -bug fix for showing road on google maps (api change)
    # KPV Jan 01, 2009 - -bug fix with coordinat locator (using tile entries)
    # KPV Jan 01, 2009 - -bug fix with profile gradient
    # KPV Jan 02, 2009 - -minor gui tweaks
    # KPV Jan 02, 2009 - Remember last sort for Favorite dialog
    # KPV Jan 05, 2009 - Google Maps from any point within the zoom window
    # KPV Jan 05, 2009 - Favorite routes can be in multiple regions
    # KPV Jan 13, 2009 - -photos: local now means zone local
    # KPV Jan 13, 2009 - -configuration stuff: hide node text, description fonts
    # KPV Apr 09, 2009 - *Panning via button 1 (in addition to button 2)
    # KPV Apr 11, 2009 - Profile graph uses hysteresis algorithm for total climbing
    # KPV Apr 11, 2009 - Moved zoom cache into zone directory
    # KPV Apr 11, 2009 - Sanity check for web services: USGS, NOAA, etc.
    # KPV Apr 13, 2009 - *Prettier annotations with round corners and shout outs
    # KPV Apr 14, 2009 - -bug fix with user favorites overwriting system ones
    # KPV Apr 14, 2009 - Speed of button-1 panning configurable
    # KPV Apr 19, 2009 - route annotations include data from skipped legs
    # KPV May 01, 2009 - -bug fix in sframe.tcl with () variables and tkcon
    # KPV Jun 24, 2009 - *Profile Graph configuration
    # KPV Jul 15, 2009 - -bug fix in node renumber dialog for superusers
    # KPV Jul 16, 2009 - -GPS stuff: zoom, google maps, better date handling
    # KPV Jul 29, 2009 - *Calorie calculator
    # KPV Aug 20, 2009 - drawing only selected portion of a GPS track
    # KPV Aug 26, 2009 - -bug fix for favorites off the map
    # KPV Nov 13, 2009 - -balloon help fade
    # KPV Feb 27, 2010 - -bug fix for ribbon graphs and hidden surface removal
    # KPV Mar 02, 2010 - more profile graph configuration
    # KPV Mar 12, 2010 - added expected temperatures to weather dialog
    # KPV Mar 13, 2010 - metric weather forecast and temperatures
    # KPV Mar 16, 2010 - trace not lets you specify the distance
    # KPV Mar 16, 2010 - favorites can be filtered to contain specific node
    # KPV Mar 16, 2010 - -gps tracks with no waypoints failed in Google maps
    # KPV Jun 16, 2010 - updated coordinates dialog
    # KPV Jun 17, 2010 - updated advanced select region dialog
    # KPV Jun 30, 2010 - convert track segment into a road
    # KPV Feb 11, 2011 - -bug with multiple regions
    # KPV Mar  3, 2011 - -bug with default extension in file dialogs
    # KPV Mar  5, 2011 - -bug parsing geocaching links
    # KPV Mar 10, 2011 - -bug fixes upgrading to pdf4tcl
    # KPV Mar 11, 2011 - Google Earth works on Linux and Mac platform
    # KPV Mar 15, 2011 - favorites work across regions
    # KPV Apr 30, 2011 - -bug fixes with coordinate locator
    # KPV May  6, 2011 - -GPX geocache format changed slightly in the type field
    # KPV Jul  7, 2011 - terraserver host changed again
    # KPV Sep 24, 2011 - NOAA weather host changed again
    # KPV Sep 26, 2011 - -small fix for GetNextID
    # KPV Sep 27, 2011 - -bug fix and loading multiple regions
    # KPV Sep 28, 2011 - -fix Unix message boxes
    # KPV Sep 28, 2011 - -load route determines needed regions on the fly
}
# ZZZZZZZZZZZZZZZZ
if {[info exists ::state(dosetup)]} return
##+##########################################################################
#
# Dialogs
#  1 Describe Route          2 Splash
#  3 Profile Route           4 Help
#  5 Trace Route             6 About
#  7 About Large photo       8 Bicycling Quotes
#  9 License                10 Copyright
# 11 Customize              12 Options
# 13 ProgressBar            14 Edit/Create New Node
# 15 Ride Log Add           16 Edit/Create New Road
# 17 Ride Log               18 Split Road
# 19 Ride Log Statistics    20 Ride Log Filter
# 21 Region Info            22 Region Select
# 23 Print                  24 Annotate
# 25 Node Neighborhood      26 Coordinate Locator
# 27 POI                    28 Snapshot
# 29 GPS track              30 Geocache
# 31 Zoom                   32 Add Route Point Elevation
# 33 What's New             34 Gallery
# 35 USGS                   36 USGS Wait
# 37 Weather                38 URL Wait
# 39 ChooseFont             40 Hills
# 41 Photo                  42 Edit/Create photo
# 43 Route Info             44 Arrows
# 45 Favorites              46 Web Update
# 47 Route Atlas            48 Profile Graph Config
# 49 Calorie Calculator
#
#                           50 CanDo Test
# 51 Sanity                 52 Node Renumber
# 53 Config Dump            54 Web Services Check
#
# PrintPS                Print Wait
#
if {[info commands lassign] eq ""} {
    proc lassign {values args} {
	uplevel 1 [list foreach $args [linsert $values end {}] break]
	lrange $values [llength $args] end
    }
}
if {[info commands dict] eq ""} {
    proc dict {cmd dict key} {
	if {$cmd ne "get"} {error "only handle dict get"}
	array set T $dict
	return $T($key)
    }
}
namespace eval ::3D {
    variable gpexe				;# Actual executable
    variable 3dDir "3dProfile"			;# Where temp files go
    variable dataFile0 "gnuData.dat"
    variable dataFile
    variable ctrlFile0 "gnuCtrl.gnu"
    variable ctrlFile
    variable gp ""				;# File handle to gnuplot
    variable aid ""				;# After id
    variable xrot 80
    variable zrot 20
}
namespace eval ::About {
    variable who 0
    variable bmsg
    variable aid ""
    variable noShuffle 0

    array unset bmsg
}
namespace eval ::Arrow {
    variable A
    variable ARROWS

    unset -nocomplain ARROWS
    set A(W) .arrow
    set A(idx) 0
}
namespace eval ::Atlas {
    variable S
    variable WIN
    variable PDF
    variable fileName klimbAtlas.pdf
    variable userFile ""

    array unset S
    set S(cnt) 0
    set WIN(top) .atlas
    set WIN(maps) .c
    array set PDF {fontSize 18 titleSize 36 title2Size 28 footerSize 12
	rMargin 20 imgPad 5}
}
namespace eval ::BadMath {}
namespace eval ::Balloon {
    variable enabled 1
    variable btext				;# Balloon text
    variable stext				;# Status line text
    variable lastID
    variable fadeStep .2
    array set lastID {nid "" rid ""}

}
namespace eval ::Bend { variable maps ; variable bounds}
namespace eval ::ChooseFont {
    variable S

    set S(W) .cfont
    set S(fonts) [lsort -dictionary [font families]]
    set S(styles) {Regular Italic Bold "Bold Italic"}

    set S(sizes) {8 9 10 11 12 14 16 18 20 22 24 26 28 36 48 72}
    set S(strike) 0
    set S(under) 0
    set S(first) 1

    set S(fonts,lcase) {}
    foreach font $S(fonts) { lappend S(fonts,lcase) [string tolower $font]}
    set S(styles,lcase) {regular italic bold "bold italic"}
    set S(sizes,lcase) $S(sizes)
    set S(style) ""
    set S(font) ""
    set S(size) ""
}
namespace eval ::ClipBox {
    variable P					;# Box position
    variable M					;# Mousing info

    unset -nocomplain P
    set P(clr,1) cyan
    set P(clr,0) red
    array set M {
	xy {} minWidth 200 minHeight 200 mousing 0 resizeSize 8 cornerSize 15
	cursor,corner exchange cursor,strip hand2 cursor,width fleur
	cursor,height fleur
    }
}
namespace eval ::Config {
    variable factory
    variable cdata
    variable zone
    variable user
    variable W
    variable TAB 0
}
namespace eval ::Coords {
    variable latlon
    variable aid ""
    variable C
    set C(values) {"Decimal degrees" "Degrees and minutes"
	"Degrees, minutes, seconds"}
    set C(ll) [lindex $C(values) 2]
}
namespace eval ::Data {
    variable labels; variable etypes ; variable mtypes ; variable changed
    variable log {}

    array set etypes {dist mile climb foot area area weight weight}
    array set mtypes {dist kilometer climb meter area area weight weight}
    array set labels {
	dist,english,0 " mile"         dist,metric,0 " kilometer"
	dist,english,1 " mi"           dist,metric,1 " km"
	dist,english,2 " mi"           dist,metric,2 " km"
	dist,english,3 " mile"         dist,metric,3 " km"
	dist,english,4 ""              dist,metric,4 ""
	climb,english,0 " foot"        climb,metric,0 " meter"
	climb,english,1 " ft"          climb,metric,1 " m"
	climb,english,2 "'"            climb,metric,2 "m"
	climb,english,3 " foot"        climb,metric,3 " meter"
	climb,english,4 ""             climb,metric,4 ""
	area,english,0 " square mile"  area,metric,0 " square kilometer"
	area,english,1 " sq mi"        area,metric,1 " sq km"
	area,english,2 " sq mi"        area,metric,2 " sq km"
	area,english,3 " sq mile"      area,metric,3 " sq km"
	area,english,4 ""              area,metric,4 ""
	weight,english,0 " pound"      weight,metric,0 " kilogram"
	weight,english,1 " lb"         weight,metric,1 " kg"
	weight,english,2 " lb"         weight,metric,2 " kg"
	weight,english,3 " lb"         weight,metric,3 " kg"
	weight,english,4 ""            weight,metric,4 ""
    }
    array unset changed
}
namespace eval ::Data::SetCover {}
namespace eval ::Datefield {
    variable pos
    variable formats
    variable cformat "%m/%d/%Y"
    array set pos {m1 0 m2 2 d1 3 d2 5 y1 6 y2 10 len 10}
    array set formats {
	mdy {0  2    3  5    6 10 10 "%m/%d/%Y"}
	myd {0  2    8 10    3  7 10 "%m/%Y/%d"}
	dmy {3  5    0  2    6 10 10 "%d/%m/%Y"}
	dym {8 10    0  2    3  7 10 "%d/%Y/%m"}
	ymd {5  7    8 10    0  4 10 "%Y/%m/%d"}
	ydm {8 10    5  7    0  4 10 "%Y/%d/%m"}
    }
}
namespace eval ::Description {
    variable saveName "klimbDescription"
    variable dformat Table
    variable ctabs
    variable arrows
    array set arrows {
	_B \x02\u21EA\x02
	_B \x02\u21D1\x02
	B \x02\u21E7\x02
	_E "\x02\u253b\x02"
	_E "\x02\u03a9\x02"
	_E "\x02X\x02"
	E " "
	L \x02\u21b0\x02
	N " "
	O " "
	R \x02\u21b1\x02
	_S \u2191
	_S \x02\u21E7\x02
	S \u21E7
	U \x02\u21b7\x02
	Y \x02\u21af\x02
	Z \x02\u21af\x02
    }
}
namespace eval ::Display {
    variable tops {}
    variable coords
    variable pColors [list red red orange \#e0e000 green cyan violet]
    set pColors [list green cyan magenta]	;# Progress bar
    variable scanning				;# For mouse panning

    variable ALPHA				;# Rotated text
    array set ALPHA {
	32 R0lGODlhDwADAJEAANnZ2f///////////yH5BAEAAAAALAAAAAAPAAMAAAIGhI+py00FADs=
	33 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIPhI95EUdxCH4EUHyCj3kFADs=
	34 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIWhI+pF0EhfLSIyMyUDIkJHy0iMvOQAgA7
	35 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIfhBNhYWZmAIlN8DEsICiEHxEWd2dIbIKPYQFBIXzMKwA7
	36 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIdhI+JEUYx4UNchFEIm+JjEOywiAuCDxFhQSF8TCwAOw==
	37 R0lGODlhDwAPAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAA8AAAI5hI+pEEEJ4SPFJ/gXGGgUgOITfAiLCArhXwQiHoXwMSMSKQ5AEHyg+ABB8OMg7o7iE3yMiEBEhAwpADs=
	38 R0lGODlhDwALAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAsAAAIxhI+JEUHwESg2wceIi6AQPoRRfIIfEBFHIXyIsDAK4UcEBFBC+BAWgWgkAATBR4jMAgA7
	39 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAINhI+pF0EhfLSIyMxDCgA7
	40 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIShBmf4BvFN4IfcRdBMOLuIAguADs=
	41 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIRDOFjYAQaJYRP8Y3gG8Un+AUAOw==
	42 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIWhI+pF5sUhODjRUQQfAwIRDQSwsfMAgA7
	43 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIWhA+BiEYhfMTIBIofBB8hMpFC+IiRVgA7
	44 R0lGODlhDwADAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAMAAAIMhI8JAUEhfLSIyKQCADs=
	45 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIMhB13d0YhfMTIzERSADs=
	46 R0lGODlhDwADAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAMAAAIKhI95EapAEsLHAgA7
	47 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAINhBMEHzMiMpPEhI8ZVwA7
	48 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIchEHxg+ADxT+CH3cQdxTCh0Cj+EfwgeIHwcfEAgA7
	49 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIVhI95oUAhfIp/BJ/iH8EPgo+py0kFADs=
	50 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIihGMGYWZGEsKOO4igAAARBD8C4oJC+BFGsQl+xEUEwcfEAgA7
	51 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIhhBNmYWZGEsKOO4ijABEEPyzCgkL4QPGN4ENEWFAIHxMLADs=
	52 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIbhB1xdwcUhOCjhUUQfKP4RvCB4h/Bt0BERCQFADs=
	53 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIjhBMWZmZGEoAZwYe4CKCE8OMiICiEDwERQUgIvkXEBcHHvAIAOw==
	54 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIghEGxCf5R/CD4FhgRBB8CA4JC+BQfIAg+REQchfAxrwAAOw==
	55 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIchH8RiGiUEH7EWQTBt4iwoBA+QkQEwceLyMwjBQA7
	56 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIghBEREEEhfKD4R/DjIiwIfljEBcGn+EfwISIsKISPiQUAOw==
	57 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIfhGMQEUHwIYziE/wIiAMK4UNEYBB8o/hB8I9iE3xMLAA7
	58 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIOhI95EUYJ4V+ERRB8TC0AOw==
	59 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIRhI8JAUEBIgi+RYQFhfAxtQAAOw==
	60 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIbhA+BiEBBCD5aQGQCCQBB8DEuEIFC2HF3dwekADs=
	61 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIZhB8Qd3cUhOCjBUSmkSAEHy0gMo0EIfiYWgA7
	62 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIZhBFncXcUAILgY1wgHgUh+GgBkXkkhI+pUAA7
	63 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIbhI+pF0HwIQIjKIQfARFHIXyk2AQfISIyE5ECADs=
	64 R0lGODlhDwAMAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAwAAAJEhI95FJ/gW6AFGgWICACgAAABQLEBIAAIAQQABAUIAAggIAAQABQAAoBiA0AAEAIIAAgKEAAAQUDMIMyMAlBsgm+BeAUAOw==
	65 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAImhEPwESMi00iAiCD4aGERBB8DIoJC+AEUm+AbxSb4GIGIQCF8hAIAOw==
	66 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAInhGNmEGZG4h/Bp/hH8OPi4o4CQABAEPy4CAuCT/GP4ENEWFAIHxMLADs=
	67 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIjhI+ZFJvgH8UPgg8RCEEh/LiDuKMQPgRaoFEI3wIjguBjXgEAOw==
	68 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIkhGNmEGZG4h/Bp/hH8OMO4o5C+BBoEQQ74g4ofhD8o9gEHzMLADs=
	69 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIghGNmEGZG4h/Bp/hH8OPi4o4CRARAEPy4g7ijhLAjrgAAOw==
	70 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIchGNmEGZG4h/Bp/hH8OPi4u5IDAiCjxiZRwkACgA7
	71 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAInhI+ZFJvgH8UPgg8RCEEh/LiDuKMAAQAQBD8i4oLgW0RYUEL4F4gFADs=
	72 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIlhGNmEGZG4h/Bp/hH8OPi4u4ACeFjXFwQfIp/BJ/iH8GPO4ijAgA7
	73 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIRhGNmEGZG4h/Bp/hH8OMO4qgAOw==
	74 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIahBFxd0cx4aNFJlIIHwKN4h/BB4pvBB8xrgAAOw==
	75 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIohGNmEGZG4h/Bp/hH8OPi4u5ITPgXEGEUhOBHxEFQCD/iLu4ohA9xBQA7
	76 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIdhGNmEGZG4h/Bp/hH8OMO4o5C+IgRmUdxCD6mWgEAOw==
	77 R0lGODlhDwALAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAsAAAIthGNmEGZG4h/Bj7OIIPhH8Qk+xSf4FxGIeCQm/AuECArhU/wj+BT/CH7cQRwVADs=
	78 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIihGNmEGZG4h/Bj7uIuzskJnyMCMSjmPAxIjAIPsU/go8YVwA7
	79 R0lGODlhDwAKAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAoAAAInhI+ZFJvgH8UPgg8RCEEh/LiDuKMQPgRaBMGOuAOKHwT/KDbBx8wCADs=
	80 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIghGNmEGZG4h/Bp/hH8OPi4u4ACQBB8JFiE3yEiMhMRAoAOw==
	81 R0lGODlhDwAKAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAoAAAIqhI+ZFJvgH8UPgg8RCEEBACKC4ENcRFAIH+LCgkLYERdH8YPgH8Um+JhZADs=
	82 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIphGNmEGZG4h/Bp/hH8OPi4u5IAoAg+BARcRTCjwig2AQ/DiKC4EMgXgEAOw==
	83 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIlhI95EUFAIszMKABERBD8uAgLgh8WcUHwKTZAEHyLCAtKCB/zCgA7
	84 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIehI8RiGgUwo87iDuKfwSf4h/BjzuIuzuGhPDxIq4AADs=
	85 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIdhI8QaRTfCD7FP4IfdxB3FMJHjLQg+EDxjeAjxhUAOw==
	86 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIlhI8QmUcJ4SNERBD8i4gACuFTbIKPEYGIRxIABMFHiIgg+HgRVwA7
	87 R0lGODlhDwANAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAA0AAAI0hI8QmUYx4R/FJ/gUn+BfRCBQCP8iLhCPxCH4R/EJPsUGgCD4EXF3dyQBQBB8hIgIgo8YVwA7
	88 R0lGODlhDwAJAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAkAAAIthGNmEGZGEsKOuIugABARBD8sIIIQwr+IQAQKEhAE/yLighDCjziLIPhxB3FUADs=
	89 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIhhI8QmUcJ4cdBRFAIn+IHBMGn2AQfAyOAQvh4EZlIAaAAADs=
	90 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIohEPwESMwKCH8iIgLCuEHRMRRCD8uIoBC+HEQERTCjziLIPgRcRYEFwA7
	91 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIPhI9J8dEAINMIHDMzC4ILADs=
	92 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIPhI8RiEYx4V9EIB6F8BEKADs=
	93 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIODOFjHMVHA4BMI/AxrwAAOw==
	94 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIYhA+BiEcJ4WNGZlIIHy8yjRLCR4vMTCMFADs=
	95 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIUDOEjRiZSCB8xMpFC+IiRiRTCRywAOw==
	96 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIKhI+pGasUwsfEAgA7
	97 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIYhBEWdwcUwwj+BYQFwT+KT/CPYhN8DMQrADs=
	98 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIXhBn/CD5QfCP4cRB3R/EJPkZEICJChhQAOw==
	99 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIYhBERcXdA4hP8CwxEoAAQQfAxLAIREQKkADs=
	100 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIYhBERcXdA4hP8CwwLgk/xj+BT/CP4cXdWADs=
	101 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIZhBERcXdA4hP8CwsIgn9hEUHwMSACEREypAA7
	102 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIThGMWZmZA4hvBB4p/BD8OwoLgAgA7
	103 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIlRBIBEQQfAiKA4hD8gAgIAmJmAUFBIoLgB0RYUEL4EIEQBB9TCwA7
	104 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIahGNmEGZG4h/Bp/hH8DEQjeIT/KP4BP8C8QoAOw==
	105 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIShGMWZmZA4oMRfIoPRvDj7qwAADs=
	106 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIRDOFDoFH8AwMAAuMbGMHHvAIAOw==
	107 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIihGNmEGZG4h/Bp/hH8MPi7g5IHIJ/EWFB8C/iAhFICB+hAAA7
	108 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIRhGNmEGZG4h/Bp/hH8OPurAAAOw==
	109 R0lGODlhDwAKAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAoAAAIjhGMWZmZA4hP8o/gEHy8yKT7BP4pP8PEik+IT/KP4BP8C8QoAOw==
	110 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIahGMWZmZA4hP8o/gEHy8yKT7BP4pP8C8QrwAAOw==
	111 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIXhBERcXdA4hP8CwxEoPgEHyMiEBEhQwoAOw==
	112 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIXjH8En+IfwQ+LgyD4R/EJPkZEICJChhQAOw==
	113 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIahBERcXdA4hP8sDgIgk/xjeADxT+CH3d3RgUAOw==
	114 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIXhGMWZmZA4hP8o/gE/+ICEY+E8PEiEqgAOw==
	115 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIchBMQYWZmSICIIPgXEAEUwr+IsCD4GAERBB9TCwA7
	116 R0lGODlhDwAEAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAQAAAIQhG+BCBSf4B/FN4IPgYFGBQA7
	117 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIYhG+BaBSb4B/FJ/gXiGgUn+AfxSf4F4hXADs=
	118 R0lGODlhDwAFAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAUAAAIShB0RcXcUn+BfBCIexSH4iJFQADs=
	119 R0lGODlhDwAIAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAgAAAIdhB8Rd0fxCf5FBCIeiQn/KD7Bv4hAxCMx4SNGQgEAOw==
	120 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIbhGMWZmZAEoARfISICIJ/FJvgY0RYEPwLDDQqADs=
	121 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIYTAg/7uKMYsKHCKDYBP8iAhGPxISPGAkFADs=
	122 R0lGODlhDwAGAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAYAAAIahGMQYWYGSAwIgn8Un+BfWEQQ/Iu4QESEACkAOw==
	123 R0lGODlhDwAFAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAUAAAIUhI+poUex4QIACIwNABdAQAg+xhUAOw==
	124 R0lGODlhDwADAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAMAAAIJhI9J8dEIPuYVADs=
	125 R0lGODlhDwAFAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAUAAAIUDOFjHMUGgAsgABQbLgg+BiIiHikAOw==
	126 R0lGODlhDwAHAJEAANnZ2QAAAP///////yH5BAEAAAAALAAAAAAPAAcAAAIVhB1xd2cUwkeMzKMQPmJkIiWEj6lWADs=
    }
}

namespace eval ::Embellishment {
    variable E
    unset -nocomplain E
}
namespace eval ::Edit {}
namespace eval ::Favorites {
    variable RDATA
    variable S

    array unset S
    set S(W) .fav
    set S(thisRegion) 1
    set S(nodeFilter) 0
    set S(nodeFilter,val) "--"
    set S(headers) {region title distance climbing}
    set S(widths) {100 200 100 100}
    set S(bandColor,0) white
    set S(bandColor,1) \#aaffff
    set S(bandColor,selected,0) red
    set S(bandColor,selected,1) magenta
    set S(lastSort) {distance 0}
    set S(msg) ""
}
namespace eval ::Filter {
    variable F					;# Filter info
    variable ROWS 5
    variable W ""
    variable valid -1				;# First valid filter
    variable LABELS2COLUMNS
    variable IgnoreNulls 1

    array set F {0,col "Distance" 0,op ">" 0,val 30}
    array set LABELS2COLUMNS { Date date Title title Region kregion
	Distance distance Climbing climbing "Climbing Density" density
	Time time "Avg Speed" avg "Max Speed" max
	"KLIMB Distance" kdistance "KLIMB Climbing" kclimbing
	Node knodes Road kroads
    }
}
namespace eval ::Gallery {
    variable meta
    variable vrows 2
    variable vcols 3
    variable topRow -1
}
namespace eval ::Geocache {
    variable fname "<nothing loaded>"
    variable defaultName "geocaching.loc"
    variable tcnt 0
    variable vcnt 0
}
namespace eval ::Google {
    # http://code.google.com/apis/kml/documentation/kml_tut.html
    # http://code.google.com/apis/kml/documentation/kml_tags_21.html
    # Google maps API key:
    #  ABQIAAAA03TXYyeZwtbHC0iHPwlQLxSViEb1mpVtIF9OMSyvMuIyIvCIThSxxg-tosAGWMut8UORxCS5wISI3w
    # http://www.google.com/apis/maps/documentation/#Driving_Directions
    # http://qbert.ubaluba.com/blog/2007/06/24/google-maps-api-follow-road/

    variable saveName klimbGoogle
    variable GE
    variable TEMPLATE
    variable templateName "googlemap_template.html"

    array set GE {action "googleearth" markers 1}

    set TEMPLATE(doc,pre) {
	<kml xmlns="http://earth.google.com/kml/2.0">
	<Document>
	<name>KLIMB Bike Route</name>
	<Snippet><![CDATA[Created with <a href="http://www.klimb.org/">KLIMB</a>]]></Snippet>
	<Style id="klimbNode">
	<IconStyle>
	<Icon>
	<href>http://maps.google.com/mapfiles/kml/paddle/ylw-circle.png</href>
	</Icon>
	</IconStyle>
	</Style>}
    set TEMPLATE(doc,post) {
	</Document>
	</kml>}

    set TEMPLATE(point,pre) {
	<Folder>
	<name>KLIMB Nodes</name>
	<Snippet>KLIMB nodes used by this route</Snippet>}
    set TEMPLATE(point,item) {
	<Placemark id="$nid">
	<name><![CDATA[$name]]></name>
	<description><![CDATA[$desc]]></description>
	<styleUrl>#klimbNode</styleUrl>
	<Point>
	<coordinates>$lon,$lat,0</coordinates>
	</Point>
	</Placemark>}
    set TEMPLATE(point,post) {
	</Folder>}

    set TEMPLATE(path,pre) {
	<Folder>
	<visibility>1</visibility>
	<name>KLIMB Route</name>
	<Snippet><![CDATA[$snippet]]></Snippet>
	<Placemark id="$routeID">
	<name>KLIMB Route</name>
	<visibility>1</visibility>
	<open>0</open>
	<!-- <flyToView>1</flyToView> -->
	<Style>
	<LineStyle>
	<color>ff0000ff</color>
	<width>4</width>
	</LineStyle>
	</Style>
	<LineString>
	<extrude>1</extrude>
	<tessellate>1</tessellate>
	<altitudeMode>clampToGround</altitudeMode>
	<coordinates>}
    set TEMPLATE(path,item) {
	$lon,$lat,0 }
    set TEMPLATE(path,post) {
	</coordinates>
	</LineString>
	</Placemark>
	</Folder>}
}
namespace eval ::GPS {
    variable tracks				;# Tracks and routes
    variable wpts				;# Waypoints & geocaches
    variable skip -1
    variable ready 0
    variable fname ""
}
namespace eval ::GPX {variable indent "    "}
namespace eval ::Help {
    variable history {} seen {} current {} all {} allTOC {} TREE ""
    variable pages
    variable alias
    variable title2TOC

    array unset pages
    array unset alias
    array unset title2TOC
}
namespace eval ::Hills {
    variable LIMIT 30 ;
    variable Hills
    set Hills(height) 100
    set Hills(slope) 0
    set Hills(activeHill) 0
}
namespace eval ::Info { variable extremes }
namespace eval ::Init {}
namespace eval ::Legend {}
namespace eval ::Matrix {}
namespace eval ::MilePost {}
namespace eval ::NodeList {}
namespace eval ::Options { variable stats}
namespace eval ::Overview {}
namespace eval ::pBox {
    variable xy {0 0 0 0}			;# Coordinates of print box
    variable CURSORS				;# Cursors to use while resizing
    variable bxy {}				;# Button down location
    variable bdown 0				;# Button is down flag
    variable minSize 250			;# Minimum size of print box
    variable grabSize 10			;# Size of "grab" area
    variable debug 0

    if {$::tcl_platform(platform) eq "windows"} {
	array set CURSORS {
	    L size_we      R size_we
	    B size_ns      T size_ns
	    TL size_nw_se  BR size_nw_se
	    TR size_ne_sw  BL size_ne_sw
	}
    } else {
	array set CURSORS {
	    L sb_h_double_arrow      R sb_h_double_arrow
	    B sb_v_double_arrow      T sb_v_double_arrow
	    TL top_left_corner       BR bottom_right_corner
	    TR top_right_corner      BL bottom_left_corner
	}
    }
}
namespace eval ::Photo {}
namespace eval ::POI {}
namespace eval ::Power {
    variable C
    variable P
    variable V
    variable A2
    variable D					;# Display variables
    array unset ::Power::D
    variable W .cal
    variable w
    variable AirDensity
    variable FrontalArea                ;# In meters^2
    variable mphs [list 10 15 20 25 30]
    variable kphs [list 10 20 30 40 50]

    set C(mOs_per_miOhr) 0.44704	;# meters/second per kilometers/hour
    set C(Nt_per_lb) 4.4482
    set C(kg_per_Nt) 0.102
    set C(Watts_per_horsepower) 745.700
    set C(Watts_per_CalOhr) 1.163	;# Watts per dietary Calories/hour
    set C(BM_rate) 1.4 ;# Basal Metabolism rate [Watts/kg of body weight]
    set C(coeffAirResistance) 0.90 ;# Coefficient of air resistance

    array set FrontalArea {
	"Standing"                                      0.65669
	"Upright"                                       0.49252
	"Crouch"	                                0.4298
	"Racing"                                        0.308027
	"Tuck"                                          0.26747
	"End of pack"                                   0.22136
	"Middle of pack"                                0.18446
    }
    set FrontalArea(labels) [list \
	"Standing" "Upright" "Crouch" "Racing" \
	"Tuck" "End of pack" "Middle of pack"]
    #array set oldA2 {
    #    "Standing"                                     0.356
    #    "Upright"                                      0.267
    #    "Crouch"	                                0.233
    #    "Racing"	                                0.167
    #    "Tuck"                                         0.145
    #    "End of pack"                                  0.12
    #    "Middle of pack"                               0.10
    #}


    set AirDensity {}   ;# If temp if given, recompute A2 from this table
    lappend AirDensity 1.5147 1.5083 1.5019 1.4955 1.4892 ;# -30 3.6f
    lappend AirDensity 1.4829 1.4767 1.4706 1.4645 1.4584 ;# -25
    lappend AirDensity 1.3951 1.3896 1.3841 1.3787 1.3734 ;# -20
    lappend AirDensity 1.3680 1.3628 1.3575 1.3523 1.3472 ;# -15
    lappend AirDensity 1.3420 1.3370 1.3319 1.3269 1.3219 ;# -10
    lappend AirDensity 1.3170 1.3121 1.3072 1.3024 1.2977 ;# - 5
    lappend AirDensity 1.2929 1.2882 1.2835 1.2789 1.2742 ;#   0
    lappend AirDensity 1.2697 1.2651 1.2606 1.2561 1.2517 ;#   5
    lappend AirDensity 1.2472 1.2428 1.2385 1.2342 1.2299 ;#  10
    lappend AirDensity 1.2256 1.2214 1.2171 1.2130 1.2088 ;#  15
    lappend AirDensity 1.2047 1.2006 1.1965 1.1925 1.1885 ;#  20
    lappend AirDensity 1.1845 1.1805 1.1766 1.1727 1.1688 ;#  25
    lappend AirDensity 1.1649 1.1611 1.1573 1.1535 1.1498 ;#  30
    lappend AirDensity 1.1460 1.1423 1.1387 1.1350 1.1314 ;#  35
    lappend AirDensity 1.1277 1.1242 1.1206 1.1170 1.1135  ;#  40c 138.6f

}
namespace eval ::Postit {
    variable A
    variable rDetails 1				;# How much details in route
    variable radiusCorner 5
    variable maxShoutWidth 30
    unset -nocomplain A
    array set Details {onoff 0 rnames 1 rdist 0 rclimb 0 nnames 0 nelev 0}
}
namespace eval ::Print {
    variable orientation automatic
    variable quality Medium
    variable WhyNot
    variable PrintScreen 1
    variable hide 0
    variable postit 1
    variable route
    variable margins
    variable sxy
    array set route {roads 1 dist 1 nodes 0 ele 1}
    array set margins {top 140 bottom 204}
}
namespace eval ::PrintPS {
    variable orientation portrait
    variable colormode color
    variable height 1350
    variable width 975
    variable xheight 1350
    variable xwidth 975
    variable zoom 1.5
    variable pageheight 9.0i
    variable pagewidth 6.5i
    variable rotate false
    variable inDialog 0
}
namespace eval ::Profile {
    variable lastAlt 0
    variable saveName "klimbProfile"
    variable show
    variable colors
    variable sizes
    variable Ribbon

    array set show {z 1 labels 1 ribbon 1}
    array set colors {band,0 darkblue band,1 seagreen}
    array set colors {ncolor yellow zcolor red ecolor gold gcolor gold}
    array set sizes {nsize 5 esize 2 gsize 1}
    array set sizes {bigTick 8 smallTick 4}
    array set Ribbon {dx 4 dy -10}
}
namespace eval ::Region {
    variable rdata
    variable multi 0				;# Allow for multiple regions
    variable mag 3				;# Mag w/ advanced selection
    variable S
    set S(W) .region
}
namespace eval ::Renumber {
    variable W .renumber
    variable S
    array set S {pre "" low 0 high 9999 newPre "" newLow 1}
}
namespace eval ::RideLog {
    variable RideData
    variable TableData
    variable Names
    variable Sort
    variable Select
    variable Widget ""
    variable W .rlog
    variable RoadLog
    variable ShowAll 0
    variable filter 0
    variable Log
    variable Arrows
    variable RideCount 0

    array set Select {table 0 data -1}
    array set Sort   {column "" dir 0}
    array set Arrows {0 \u25bc 1 \u25b2}

    array set Names {
	col,date date
	col,title title
	col,distance distance
	col,climbing climbing
	col,density density
	col,avg avg
	col,max max
	col,time time
	"col,klimb distance" kdistance	   "col,klimb climbing" kclimbing
	"col,klimb nodes" knodes	   "col,klimb turns" kturns
	"col,klimb roads" kroads	   "col,klimb region" kregion
	"col,klimb newnodes" knnodes	   "col,klimb newroads" knroads
	"col,klimb mag" kmag		   "col,klimb version" kversion
	col,comments comments              "col,klimb splits" knsplits
	sort,0 date
	sort,1 title
	sort,2 kregion
	sort,3 distance
	sort,4 climbing
	sort,5 density
	sort,6 time
	sort,7 avg
	sort,8 max
	sort,9 kdistance
	sort,10 kclimbing
	sort,11 comments
    }
}
namespace eval ::RInfo {
    variable RI
    unset -nocomplain RI
}
namespace eval ::Route {
    variable saveName "klimbRoute"
    variable tlabel				;# In balloon help
    variable tlabel2				;# In tabbed description
    variable tlabel3				;# In long description
    array set tlabel {
	L "left turn" R "right turn" S "go straight" U "u turn"
	N "goes through" O "omit" B "start of route" E "end of route"
	Z "zigzag right" Y "zigzag left"
    }
    array set tlabel2 {L L R R S S U U N "" O O B "Start" Z "R/L" Y "L/R" E End}
    array set tlabel3 {
	L "Turn left" R "Turn right" S "Go straight" U "U turn"
	N "Go through" O "omit" B "Start" E "End"
	Z "Zigzag first right then left"
	Y "Zigzag first left then right"
    }
}
namespace eval ::Sanity {
    variable W .sanity
    variable WEB .sanityWeb
    variable S
    variable WW
    variable bgColor \#73ffff
    variable granville {40.06791666666667 82.52016666666667}

    foreach what {node road droad} {
	set S(err,$what) "<none>"
	set S(value,$what) 0
	set S(who,$what) this
    }
    set S(what) node
    set S(What) [string totitle $S(what)]
    set S(skip,droad) 0
}
namespace eval ::Save {
    variable fileName "user.nodes"
}
namespace eval ::Snapshot {
    variable W .snap
    variable S
    variable BOX
    variable saveName "klimbSnapshot"
    variable msg

    array set S {w 200 h 200}
}
#namespace eval ::Super {
#    variable W .renum
#    variable S
#}
namespace eval ::TileTable {}
namespace eval ::Trace {
    variable W .trace
    variable tdata
    variable Dash

    array set tdata {xy {} dist {} anim 0 startat 0 reset 0}
    array set tdata {anim,pixels 10 anim,delay 100}
    array set tdata {afterId ""}
    if {$::tcl_platform(platform) eq "windows"} {
	set Dash(0) "-."		;# Windows has limited Dashes
	set Dash(1) "-."
	set Dash(2) "-."
	set Dash(3) "-.."
	set Dash(4) "-.."
	set Dash(5) "-.."
    } else {
	set Dash(0) "-.."
	set Dash(1) "-.."
	set Dash(2) ".-."
	set Dash(3) ".-."
	set Dash(4) "..-"
	set Dash(5) "..-"
    }
}
namespace eval ::Tracks {
    variable trackNum 0				;# Which track to process
    variable trackCnt 0				;# How many tracks in file
    variable fname "<nothing loaded>"
    variable filetype "GPS Exchange"
    variable height 200				;# Minimum height for a hill
    variable height_external			;# How it gets displayed
    variable slope 0				;# Minimum slope for a hill
    variable hillData ""
    variable ttime
    variable tdate
    variable name
    variable distance
    variable climbs
    variable descends
    variable legs
    variable waypoints
    variable activeHill 0
    variable isVisible 0
}
namespace eval ::URL {
    variable W .webDownload
    variable S
}
namespace eval ::USGS { variable S }
namespace eval ::Weather {
    variable W .noaa
    variable NOAA
    variable FORECAST
    variable S

    unset -nocomplain NOAA
    unset -nocomplain FORECAST
    unset -nocomplain S
    set S(days) 9
    #set S(url) http://www.weather.gov/forecasts/xml/SOAP_server/ndfdSOAPclientByDay.php
    #set S(url) http://graphical.weather.gov/xml/SOAP_server/ndfdSOAPclientByDay.php
    set S(url) https://graphical.weather.gov/xml/SOAP_server/ndfdSOAPclientByDay.php
    set S(format) 12+hourly
}
namespace eval ::Weather::Temp {
    variable S
    variable WEATHER
    unset -nocomplain WEATHER

    #set S(url,temp)     http://www.weather.gov/forecasts/xml/SOAP_server/ndfdXMLclient.php
    set S(url,temp)     http://graphical.weather.gov/xml/SOAP_server/ndfdXMLclient.php
    set S(url,temp,parameters) {?lat=${LAT}&lon=${LON}&product=time-series&begin=${BEGINDATE}T00%3A00%3A00&end=${ENDDATE}T00%3A00%3A00&temp=temp&Submit=Submit}
    set S(days) 9

    variable M
    array set M {lm 40 tm 20 bm 20 rm 20}
}

namespace eval ::Within {
    variable W .within
    variable queue
    variable d
    variable pi
    variable last ""
    variable on {}
    variable radius
    variable destination
    variable center
}
namespace eval ::WUpdate {
    variable W .update
    variable S
    variable DLG
}
namespace eval ::XML {
    variable XML "" loc 0 valid 0 length 0
    variable tdom
    array set tdom {exists -1 doc "" root "" tree {}}
}
namespace eval ::Zone {
    variable defaults
    array set defaults {multiple 0 region,default "" goodData 4}
}
namespace eval ::Zoom {
    variable ZMAP				;# Info about current map
    variable RINFO				;# Info about road/node
    variable T ".zoom"				;# Toplevel to make in
    variable W					;# Canvas widget
    variable W2					;# Zoom window
    variable DS					;# Display state
    variable STATIC				;# Static stuff
    variable SCREEN
    variable FETCH
    variable COLORS
    variable stats
    variable google

    array set COLORS {
	queued cyan    pending yellow  done green  timeout orange
	cancel plum1   failure red     web white   cache \#b7ffff
	empty \#a0a0a0 discarded magenta
    }

    array set SCREEN {l 0 t 0 r 600 b 600 w 600 h 600 rows 3 cols 3}
    array set FETCH {q,other {} aid ""}
    array set stats {queued 0 loading 0 retrieved 0}

    set DS(mag) 1
    set DS(theme) "topo"
    set ZMAP(mag) [expr {$DS(mag) + 10}]
    set ZMAP(sid) -1				;# Session id
    set ZMAP(ready) 0
    set ZMAP(readonly) 0
    set ZMAP(nofetch) 1
    set ZMAP(nocache) 0

    set ::Zoom::STATIC(small) 10.0		;# Zoom zoom window scale
    set ::Zoom::STATIC(maxFetch) 50		;# Max request outstanding
    set ::Zoom::STATIC(maxRendered) 60		;# Max rendered on canvas
    set ::Zoom::STATIC(rtheme,aerial) 1
    set ::Zoom::STATIC(rtheme,topo) 2
    set ::Zoom::STATIC(rtheme,urban) 4
    #set ::Zoom::STATIC(url) "http://terraserver.microsoft.com/tile.ashx"
    #set ::Zoom::STATIC(url) "http://terraserver-usa.com/tile.ashx"
    set ::Zoom::STATIC(url) "http://MSRMaps.com/tile.ashx"
    set ::Zoom::STATIC(mags) {}
    for {set i 8; set n .25} {$i < 20} {incr i; set n [expr {2*$n}]} {
	lappend STATIC(mags) [format "%g m/p" $n]
    }
    unset -nocomplain ::Zoom::i
    unset -nocomplain ::Zoom::n

    set google(last) {}
}
## BON INIT
##+##########################################################################
#
# ::Init::Init
#
# Initialize some global state. If fast is true then we only initialize
# what's needed for displaying the splash window.
#
proc ::Init::Init {fast} {
    global state msg route map region nnode zone trails tcl_platform

    if {$fast} {				;# Splash windows stuff
	set state(zone)   none
	set state(region) none
	set state(mag)	  none
	set state(units,internal) english
	set state(verbose) 1
	set state(logMax) 500
	set state(modified) 0

	set state(freewrap) [info exists ::freewrap::progname]
	set state(starpack) [expr {! [catch {package present starkit}]}]
	::Init::GetKLIMBDirectory
	if {$state(kcode) ne ""} { append state(version) "k" }

	# How big the canvas should be
	set state(cw) 880	       ; set state(ch) 850
	set sw [winfo screenwidth .]   ; set sh [winfo screenheight .]
	if {$state(cw) > $sw - 50  } { set state(cw) [incr sw -150] }
	if {$state(ch) > $sh - 300 } { set state(ch) [incr sh -300] }

	::Init::LoadTile
	return
    }

    INFO "initializing program..."
    set state(macosx) [string equal $tcl_platform(os) "Darwin"]
    set state(unix) [expr {$tcl_platform(platform) eq "unix" && !$state(macosx)}]
    set state(windows) [string equal $tcl_platform(platform) "windows"]
    set state(console) ""
    set state(beta) [regexp -nocase bk?$ $state(version)]
    set state(build) [file extension \
			  [glob -nocomplain -directory $state(pdir) -- build.*]]
    set state(build) [string map {\} ""} $state(build)]

    ::Data::CanDo jpeg				;# Loads jpeg stuff
    ::Display::MakeNeededImages

    set state(locale) "$state(region),$state(mag)"
    set state(images) 2				;# 0 none, 1 main, 2 all
    set state(zoomout) 0			;# For scaling image
    set state(zoomin) 0				;# For scaling image
    set state(zoomlevel) 2			;# How much to zoom out
    set state(isZoomed) 0			;# True if maps are zoomed
    set state(stealth) 0;#[regexp {\.mtv\.} $::env(SESSION_MANAGER)] ;# Hide ourselves
    set state(rname) ""				;# Region filename
    set state(title) ""				;# Title bar
    set state(iconfile) [file join $state(idir) klimb.ico]

    set state(homepagex) "http://purl.oclc.org/keithv/klimb/klimb.html"
    set state(homepage) "http://www.klimb.org/klimb.html"
    set state(paypal) "https://www.paypal.com/xclick/no_shipping=1&no_note=1"
    append state(paypal) "&business=klimb%40klimb.org&tax=0&currency_code=USD"
    append state(paypal) "&item_name=KLIMB%20Bike%20Mapping%20Program"

    set state(me) [expr {$::tcl_platform(user) eq "Keith" ||
			 $::tcl_platform(user) eq "keith" ||
			 $::tcl_platform(user) eq "kvetter"}]

    # Balloon help stuff (see also ::Config::DefaultRC)
    set state(balloon,afterid) ""
    set state(balloon,fadeid) ""

    # Road type definitions -- don't forget to add road color for new types
    set types {"Normal road" "Dirt road" "Ridge road" "Restricted road"
	"User road" "Single track" "Fire break" "Paved fire road"
	"Bike path" "Zoom"}
    set desc {"" "on dirt" "" "restricted access road" "" "single track"
	"fire Break" "paved fire road" "bike path" ""}
    for {set i 0} {$i < [llength $types]} {incr i} {
	set trails(type,$i) [lindex $types $i]
	set trails(rtype,[lindex $types $i]) $i
	set trails(dtype,$i) [lindex $desc $i]
    }

    # New node info
    set state(nodes,next) 99
    set state(roads,next) 99
    #set state(N,sizes) [list .4 .4 .6 1 1.2 1.2] ;# node size scaling per mag

    catch {unset ::Display::coords}
    ::Config::ReadRC				;# Need zone,default now
    ::Zone::FindZones

    set n [regexp {^\s*(\d+)\s*[xX]\s*(\d+)\s*$} $state(start,size) => sw sh]
    if {$n} {
	if {$sw > 100 && $sw < 5000 && $sh > 100 && $sh < 5000} {
	    set state(cw) $sw
	    set state(ch) $sh
	    set state(start,size) "$sw x $sh"
	}
    }

    set state(menu,region) "$state(region),$state(mag)";# For menu radiobuttons
    set state(menu,zone) $state(zone)

    # Dynamic stuff
    set state(su) 0
    set state(overview)	  0			;# Overview window toggle
    set state(nodelist)	  0			;# Nodelist window toggle
    set state(legend)     0			;# Legend window toggle
    set state(milepost)   [expr {$state(init,milepost) eq "On"}]
    set state(arrow)      [expr {$state(init,arrow) eq "On"}]
    set state(weather)    0			;# Weather dialog toggle
    set state(atlas)      0			;# Atlas interaction
    set state(favorites)  0			;# Favorites dialog
    set state(regionInfo) 0			;# Region info dialog
    set state(email,cmd)  ""			;# How to send email

    # Route information
    set route(start) -1
    set route(tail)  -1
    set route(roads) {}				;# Which roads are in the route
    set route(nodes) {}				;# Which nodes are in the route
    set route(turns) {}				;# Turning info for each node

    # Textvariables variables
    set msg(dist)   "distance"
    set msg(climb)  "climbing"
    set msg(desc)   "descending"
    set msg(dist2)  0				;# Used by ridelog
    set msg(climb2) 0
    set msg(desc2)  0

    eval font create nodeFont [font actual $state(n,font)]
    eval font create descFont [font actual $state(desc,font)]
    eval font create descTitleFont [font actual $state(desc,titleFont)]
    eval font create descFixedFont "[font actual descFont] -family Courier"
    eval font create descHeaderFont "[font actual descFont] -weight bold"
    eval font create descBoldFont "[font actual descFont] -weight bold"

    font create boldFont -family Helvetica -size 10 -weight bold
    font create bolderFont -family Helvetica -size 18 -weight bold
    font create bigBold -family Helvetica -size 24 -weight bold
    bind all <Key-F2> DoConsole
    bind all <Key-F1> ::Help::Help

    if {$state(unix)} {
	option add *Dialog.msg.font {Times 12}
	option add *Dialog.msg.wrapLength 3i
    }

}
##+##########################################################################
#
# ::Init::LoadTile -- loads the tile extension but we only replace the old
# button widget explicitly with the tile version.
#
proc ::Init::LoadTile {} {
    # We need ::tk::button to point to tk's button
    # and button to be the new button

    # button canvas checkbutton entry frame label labelframe
    # listbox menubutton menu message radiobutton scale scrollbar
    # spinbox text

    set allWidgets { button checkbutton entry frame label labelframe listbox
	radiobutton scale scrollbar}
    set myWidgets [list frame label labelframe entry]
    set ttkWidgets [list button radiobutton checkbutton scale scrollbar]

    # Copy all into ::tk::* and ::my::*
    foreach widget $allWidgets {
	if {[info commands ::tk::$widget] eq ""} {
	    rename ::$widget ::tk::$widget
	    interp alias {} $widget {} ::tk::$widget
	}
	interp alias {} ::my::$widget {} $widget
    }

    #foreach widget $ttkWidgets {
    #	interp alias {} $widget {} ::ttk::$widget
    #}
    foreach widget $myWidgets {
	interp alias {} ::my::$widget {} ::ttk::$widget
    }
    ::ttk::style configure whiteBG.TFrame -background white
    #style configure Raised.TCheckbutton -relief raised -borderwidth 2 -padding {5 0}
    #style configure bold.TLabelframe -font boldFont -foreground black
    #style configure TLabelframe -font boldFont -foreground black
    #style configure ZFrame -background red
}
##+##########################################################################
#
# ::Init::GetKLIMBDirectory
#
# Finds the directory with all the image and other files. Also locates
# the directory where we can write to. When wrapped, all images are internal.
#
proc ::Init::GetKLIMBDirectory {} {
    global state argv0

    set state(kdir) ""				;# Where KLIMB's files are
    set state(idir) ""				;# KLIMB images in here
    set state(wdir) ""				;# Where to write files
    set state(zdir) ""				;# Zone data in here
    set state(hdir) [file dirname [info script]] ;# Home directory
    set state(kcode) ""				;# External loadable module
    set state(pdir) ""				;# Our extra packages


    if {$state(starpack)} {
	set state(kdir) [file dirname $::starkit::topdir]
    } else {

	# started as wish console
	if {[string match "wish*" [file tail $argv0]]} {
	    set argv0 "klimb.tcl"
	}

	# Make argv0 an absolute path
	set script [file normalize [file join [pwd] $argv0]]
	if {[file pathtype $script] eq "volumerelative"} {
	    set cwd [pwd]
	    cd [file dirname $script]
	    set script [file join [pwd] [file tail $script]]
	    cd $cwd
	}

	set state(kdir) [file dirname $script]
    }

    set state(wdir) $state(kdir)		 ;# Write files here too
    set state(idir) [file join $state(hdir) Images]
    set kcode [file join $state(kdir) "kcode.tcl"]
    if {[file readable $kcode] && $state(kdir) ne "K:/"} {set state(kcode) $kcode }
    if {! $state(starpack)} {
	set state(pdir) [file join $state(hdir) packages]
	set ::auto_path [concat $state(pdir) $::auto_path]
    } else {
	set state(pdir) [file join $state(hdir) .. packages]
	set ::auto_path [concat $state(pdir) $::auto_path]
    }
}
##+##########################################################################
#
# ::Init::ReInit
#
# Resets global variables needed to start a new region
#
proc ::Init::ReInit {} {
    global state route map nnode

    set state(locale) "$state(region),$state(mag)"
    set state(menu,region) "$state(region),$state(mag)" ;# For menu radiobuttons
    set state(menu,zone) $state(zone)		;# For menu radiobuttons
    array unset state mags,*

    set perc 1
    #if {[string is integer $state(mag)]} {
    #	set perc [lindex $state(N,sizes) $state(mag)]
    #}
    #if {$perc eq ""} {set perc 1}
    set state(N,size) [expr {$state(n,size) * $perc}]

    if {[winfo exists .balloonhelp]} {
	::Balloon::Cancel
    }

    # Clean up map root image stuff
    array unset ::Display::coords root,*

    # New node info
    catch {unset nnode}
    set nnode(n) 0

    ::RideLog::QuickRead
}
##+##########################################################################
#
# ::Init::ParseArgs
#
# Checks all the command line arguments
#
proc ::Init::ParseArgs {} {
    global argc argv state region

    set myZone   ""
    set myRegion ""
    set myMag	 ""

    if {[lindex $argv end] eq "%*"} { incr argc -1 } ;# Windows porkchop

    for {set a 0} {$a < $argc} {incr a} {
	set arg [lindex $argv $a]
	switch -regexp -- $arg {
	    ^-z$ { set myZone [lindex $argv [incr a]]}
	    ^-z	 { set myZone [string range $arg 2 end]}
	    ^-m$ { set myMag [lindex $argv [incr a]]}
	    ^-m	 { set myMag [string range $arg 2 end]}
	    ^-r$ { set myRegion [lindex $argv [incr a]]}
	    ^-r	 { set myRegion [string range $arg 2 end]}

	    ^--$ { incr a; break }
	    ^- {   DIE "unknown option: \"$arg\"" }
	    default { break }
	}
    }
    set argc [expr {$argc - $a}]
    set argv [lrange $argv $a end]
    regsub -all {\\} $argv {/} argv

    set state(zone,argv) $myZone
    set state(region,argv) $myRegion
    set state(mag,argv) $myMag

    # Now figure out file name stuff
    if {$argc == 0} return
    if {$argc > 1} {
	WARN "Too many route files given: \"$argv\", ignoring."
	set argc 0
	return
    }
    set fname [lindex $argv 0]

    if {[file exists $fname]} return
    if {[file exists "$fname.klm"]} {
	set argv [list "$fname.klm"]
    } else {
	WARN "Cannot find route file \"$fname\", ignoring."
	set argc 0
    }
}
##+##########################################################################
#
# ::Init::StartingRegion
#
# Figures out what the starting region and magnification should be
# based on the perhaps erroneous user command line values.
#
proc ::Init::StartingRegion {myRegion myMag} {
    global region state zone

    # Figure out what region to use
    set r [::Region::Lookup $myRegion why]
    if {$r eq ""} {
	while {1} {
	    if {$r ne ""} break
	    set r [::Region::Lookup $state(region,default) why2] ;# Use rc file value
	    if {$r ne ""} break
	    set r [::Region::Lookup $zone(region,default) why2] ;# Zone default
	    if {$r ne ""} break

	    set mags {}
	    foreach arr [array names region *,mag] {
		foreach mag $region($arr) {
		    lappend mags $mag
		}
	    }
	    foreach z [concat $myMag 3 14 [lsort -uniq -dictionary $mags]] {
		if {[info exists region($z)]} break
	    }
	    set r [lindex $region($z) 0]
	}
	if {$myRegion ne ""} {
	    WARN "$why '$myRegion'.\nUsing $r region instead."
	    set myMag ""			;# Override user mag if any
	}
    }

    # Now $r is a valid region, check about magnification
    if {[lsearch $region($r,mag) $myMag] > -1} {;# Valid mag given
	set m $myMag
    } else {					;# Bad or no magnification
	set m $state(mag,default)		;# Default mag to use
	if {[lsearch $region($r,mag) $m] == -1} {
	    set m [lindex [lsort -dictionary $region($r,mag)] end]
	}
	if {$myMag ne ""} {
	    set err "Magnification \"$myMag\" is not available for region "
	    append err "$r,\n will use magnification \"$m\" instead."
	    WARN $err
	}
    }

    set state(region) $r
    set state(mag) $m
}
##+##########################################################################
#
# ::Init::LocateZoneFile
#
# Finds a file that should live in the current zone. The problem is freewrap
# now requires absolute paths, so we must now look in multiple places.
#
proc ::Init::LocateZoneFile {fname {readonly 1} {fatal 1}} {
    global state zone

    set f1 [file join $state(zdir) $fname]	;# In the file system
    set f2 [file join $state(hdir) [file tail $state(zdir)] $fname] ;# Wrapped

    if {$readonly} {				;# File MUST exist
	if {[file exists $f1]} {return $f1}
	if {$state(starpack) && [file exists $f2]} {return $f2}
	if {! $fatal} {return ""}
	DIE "Cannot locate file $fname"
    }
    return $f1
}
##+##########################################################################
#
# ::Init::Internet -- loads the http package and does autoproxy
#
proc ::Init::Internet {} {
    global state

    if {[info exists state(can,internet)]} { return $state(can,internet)}

    set n [catch {package require http 2.0}]
    if {! $n} {
        set n [catch {package require tls ;
            http::register https 443 [list ::tls::socket -tls1 1]}]   ;# "-tls1 1" is required since [POODLE]
    }

    set state(can,internet) [expr {! $n}]
    if {! [catch {package require autoproxy}]} {
	::autoproxy::init
    }
    return $state(can,internet)
}
## EON INIT
## BON DATA
##+##########################################################################
#
# ::Data::ReadMapData
#
# Reads in all the nodes, roads and poi data from the nodes file.
#
proc ::Data::ReadMapData {} {
    global nodes roads poi splits state region trails photos

    array unset nodes
    array unset roads
    array unset poi
    array unset splits
    array unset photos
    array unset trails user,*
    ::Data::ClearModified 1
    ::Balloon::ClearText * *

    set state(nodes,next) 99
    set state(roads,next) 99
    set errmsg ""

    set nfiles $region($state(region),nodes)
    set fname [::Init::LocateZoneFile $::Save::fileName 1 0]
    if {[file readable $fname]} {lappend nfiles $fname} else {lappend nfiles {}}

    foreach fname $nfiles {
	set result [::Data::ReadMapData2 $fname]
	append errmsg $result
    }
    ::Data::ClearModified
    ::Data::ProcessRoads

    if {$errmsg ne ""} {
	WARN "Error reading data from file:\n$errmsg"
    }
}
proc ::Data::ReadMapData2 {fname} {
    global line lnum				;# For debugging

    ::Data::ClearModified 1
    if {$fname eq {}} return

    ::Display::DoProgressBar
    INFO "reading map data $fname..."
    set fname [::Init::LocateZoneFile $fname 1 0]
    set n [catch {set FIN [open $fname r]} err]
    if {$n} { WARN "Error opening $fname: $err" ; return}

    set data [read $FIN] ; list
    set data [string map {\\\n " "} $data]
    set lines [split $data "\n"] ; list
    close $FIN

    set lnum 0
    foreach line $lines {
	incr lnum

	if {[string match "\#*" $line]} continue
	regsub {[^\\]\#.*} $line {\1} line      ;# Get rid of comments
	regsub {\\\#} $line # line		;# Unescape things
	set line [string trim $line]		;# And junk whitespace
	if {[string length $line] == 0} continue

	# N nodeid name of the node altitude lat(1,2,3) lon(1,2,3)
	if {[string match "N *" $line]} {
	    foreach {. id name alt lat1 lat2 lat3 lon1 lon2 lon3 usgs} \
		$line break
	    ::Data::ProcessOneNode $id $name $alt $lat1 $lat2 $lat3 \
		$lon1 $lon2 $lon3 $usgs
	    continue
	}
	# R rid nodeid1 nodeid2 north distance south type "name" "comment"
	if {[string match "R *" $line]} {
	    foreach {. rid id1 id2 north dist south type name \
			 comment xy survey} $line break

	    ::Data::ProcessOneRoad $rid $id1 $id2 $north $dist $south \
		$type $name $comment $xy $survey
	    continue
	}
	if {[string match "P *" $line]} {
	    ::Data::ProcessOnePOI $line
	    continue
	}
	if {[string match "S *" $line]} {
	    ::Data::ProcessOneSplit $line
	    continue
	}
	if {[string match "T *" $line]} {
	    ::Data::ProcessOneTrail $line
	    continue
	}
	if {[string match "Ph *" $line]} {
	    ::Data::ProcessOnePhoto $line
	    continue
	}
	if {[string match "E *" $line]} {
	    ::Data::ProcessOneEmbellishment $line
	    continue
	}
	INFO "ERROR: can't parse ($lnum) $line"
	return " '$line'\n"
    }
    return
}
##+##########################################################################
#
# ::Data::ProcessOneNode -- converts raw node data into our data structures.
#
proc ::Data::ProcessOneNode {nid name alt lat1 lat2 lat3 lon1 lon2 lon3 usgs} {
    global region

    set lat [lat2int $lat1 $lat2 $lat3]
    set lon [lat2int $lon1 $lon2 $lon3]
    set xy [::Display::pos2canvas root $lat $lon]

    if {! [string is double -strict $alt] || $alt < 0} { set alt "0+?" }
    set ::nodes($nid) [list $name $alt $lat $lon $xy $usgs]
    ::Data::MarkModified node $nid
}
##+##########################################################################
#
# ::Data::ProcessOneRoad
#
# Takes raw road data and puts it into our data structures, specifically
# into roads()
#   roads(##) : nid1 nid2 north dist south name comment xy z quality survey
#
# Quality: 0 perfect data; 1 one-way road data; 2 topo Z;
#          3 endpoint delta; 4 no end point info
#
proc ::Data::ProcessOneRoad {rid id1 id2 north dist south type name \
				 comment xy survey} {
    global roads nodes state

    # First, clean up all the data
    foreach who {north dist south} {
	set $who [::BadMath::Fix [set $who]]
    }
    set xy2 {}
    set z {}
    if {[lindex $xy 0] eq "xy"} {
	set xy2 [lrange $xy 1 end]
    } elseif {[lindex $xy 0] eq "xyz"} {
	foreach {a b c d e f zz} [lrange $xy 1 end] {
	    lappend xy2 $a $b $c $d $e $f
	    lappend z $zz
	}
    }

    if {! [::Data::IsNorthNode $id1 $id2]} {	;# id1 always north node
	foreach {id1 id2} [list $id2 $id1] break
	set xy2 [::Data::XYReverse $xy2]
	set z [::Data::Reverse $z]
    }
    # Handle unknown and bad data
    set roads($rid) [list $id1 $id2 $north $dist $south $type \
			    $name $comment $xy2 $z 0 $survey]
    foreach {dist north south quality} [::Data::BadData $rid] break
    set roads($rid) [list $id1 $id2 $north $dist $south $type \
			    $name $comment $xy2 $z $quality $survey]

    ::Data::MarkModified road $rid
    if {! [info exists nodes($id1)] || ! [info exists nodes($id2)]} {
	return
	puts -nonewline "can't handle $rid: "
	puts -nonewline "$id1 => [info exists nodes($id1)] "
	puts "$id2 => [info exists nodes($id2)]"
    }
}
##+##########################################################################
#
# ::Data::ReProcessOneRoad -- when a roads end points changes we
# recalculate road info for it.
#
proc ::Data::ReProcessOneRoad {rid} {
    global roads

    # North-south direction may have swapped
    foreach {id1 id2} $roads($rid) break
    if {! [::Data::IsNorthNode $id1 $id2]} {
	foreach {id1 id2 north dst south . . . xy z} $roads($rid) break
	set roads($rid) [lreplace $roads($rid) 0 4 $id2 $id1 $south $dst $north]
	lset roads($rid) 8 [::Data::XYReverse $xy]
	lset roads($rid) 9 [::Data::Reverse $z]
    }

    foreach {dist north south quality} [::Data::BadData $rid] break
    set roads($rid) [lreplace $roads($rid) 2 4 $north $dist $south]
    lset roads($rid) 10 $quality
    ::Data::ProcessRoads $rid
    ::Display::DrawRoads $rid
    ::Balloon::ClearText road $rid
}
##+##########################################################################
#
# ::Data::BadData -- handles raw data input for a road, returning cleaned
# up values plus QUALITY of the data.
#
proc ::Data::BadData {rid} {
    global roads

    foreach {id1 id2 north dist south type name comment xy z q} \
	$roads($rid) break

    set dbad [::BadMath::IsBad $dist]
    set nbad [::BadMath::IsBad $north]
    set sbad [::BadMath::IsBad $south]

    if {! $dbad && ! $nbad && ! $sbad} {return [list $dist $north $south 0]}

    if {$dbad} {
	set dist [::Data::GuessDistance $dist $id1 $id2 $xy]
    }
    foreach {north south quality} \
	[::Data::GuessClimbing $north $south $id1 $id2 $z] break
    if {$dbad && $quality < 2} {set quality 2}
    return [list $dist $north $south $quality]
}
##+##########################################################################
#
# ::Data::GuessDistance
#
# Returns the straight line distance between two nodes using
# approximation 1 min lat/lon distance for this region. It follows
# the XY windings to get a better guess.
#
proc ::Data::GuessDistance {dist node1 node2 xy } {
    global nodes

    # lxy => list of lat/lon points on the road
    set lxy [lrange $nodes($node1) 2 3]
    foreach {l1 l2 l3} $xy {
	lappend lxy [lat2int $l1 $l2 $l3]
    }
    lappend lxy [lindex $nodes($node2) 2] [lindex $nodes($node2) 3]

    set dist 0
    foreach {lat1 lon1} $lxy break
    foreach {lat2 lon2} [lrange $lxy 2 end] {
	set d [::Data::Distance $lat1 $lon1 $lat2 $lon2]
	set dist [expr {$dist + $d}]
	set lat1 $lat2
	set lon1 $lon2
    }
    set dist [Round1 $dist]
    if {$dist == 0} {set dist .01}
    return "$dist+?"
}
##+##########################################################################
#
# ::Data::RoadDistance -- computes a roads distance based its road() value
#
proc ::Data::RoadDistance {rid {calc 0}} {
    global roads nodes

    foreach {node1 node2 . dist . . . . xy} $roads($rid) break
    if {! $calc && ! [::BadMath::IsBad $dist]} { ;# Already surveyed
	return $dist
    }
    set lxy [lrange $nodes($node1) 2 3]
    foreach {l1 l2 l3} $xy {
	lappend lxy [lat2int $l1 $l2 $l3]
    }
    lappend lxy [lindex $nodes($node2) 2] [lindex $nodes($node2) 3]

    set dist 0
    foreach {lat1 lon1} $lxy break
    foreach {lat2 lon2} [lrange $lxy 2 end] {
	set d [::Data::Distance $lat1 $lon1 $lat2 $lon2]
	set dist [expr {$dist + $d}]
	set lat1 $lat2
	set lon1 $lon2
    }
    return "$dist+?"
}
##+##########################################################################
#
# ::Data::Distance -- Computes the great circle distance between two points
#
proc ::Data::Distance {lat1 lon1 lat2 lon2 {feet 0}} {
    set y1 $lat1
    set x1 $lon1
    set y2 $lat2
    set x2 $lon2

    set pi [expr {acos(-1)}]
    set x1 [expr {$x1 *2*$pi/360.0}]		;# Convert degrees to radians
    set x2 [expr {$x2 *2*$pi/360.0}]
    set y1 [expr {$y1 *2*$pi/360.0}]
    set y2 [expr {$y2 *2*$pi/360.0}]
    # calculate distance:
    ##set d [expr {acos(sin($y1)*sin($y2)+cos($y1)*cos($y2)*cos($x1-$x2))}]
    set d [expr {sin($y1)*sin($y2)+cos($y1)*cos($y2)*cos($x1-$x2)}]
    if {abs($d) > 1.0} {			;# Rounding error
	set d [expr {$d > 0 ? 1.0 : -1.0}]
    }
    set d [expr {acos($d)}]

    set meters [expr {20001600/$pi*$d}]
    set miles [expr {$meters * 100 / 2.54 / 12 / 5280}]
    if {$feet} {
	return [expr {$miles * 5280}]
    }
    return $miles
}
##+##########################################################################
#
# ::Data::ToMetric -- converts miles or feet into kilometers or meters
#
proc ::Data::ToMetric {val unit} {
    if {$unit eq "area"} {			;# Sq miles => sq kilometers
	set val [expr {$val * 5280.0*5280 * 12*12 * 2.54*2.54 / 10000 /1000000}]
    } elseif {$unit eq "weight"} {		;# Pounds to kilograms
	set val [expr {$val / 2.20462262}]
    } elseif {[string match "m*" $unit]} {	;# Miles => kilometers
	set val [expr {$val * 5280 * 12 * 2.54 / 100 / 1000}]
	set val [Round1 $val]
    } else {					;# Feet => meters
	set val [expr {$val * 12 * 2.54 / 100}]
	if {$unit ne "ft1"} {
	    set val [Round0 $val]
	}
    }
    return [Round1 $val]
}
##+##########################################################################
#
# ::Data::ToEnglish -- converts kilometers to miles or meters to feet
#
proc ::Data::ToEnglish {val unit} {
    if {$unit eq "area"} {			;# Sq kilometers => sq miles
	set val [expr {$val * 10000.0*1000000 / 5280/5280 / 12/12 / 2.54/2.54}]
    } elseif {$unit eq "weight"} {		;# Kilograms to pounds
	set val [expr {$val * 2.20462262}]
    } elseif {[string match "k*" $unit]} {
	set val [expr {$val * 100 * 1000 / 5280.0 / 12 / 2.54}]
    } else {
	set val [expr {$val * 100 / 12.0 / 2.54}]
	if {$unit eq "m0"} {
	    set val [Round0 $val]
	}
    }
    return [Round1 $val]
}
##+##########################################################################
#
# ::Data::ll2utm
#
# Convert latitude and longitude into Universal Transverse Mercator (UTM)
# coordinates. Lots of fun math which I got off the web.
#
proc ::Data::ll2utm {latitude longitude {forceZone ""}} {
    if {$longitude > 0} {set longitude [expr {-1 * $longitude}]}
    set PI [expr {acos(-1)}]
    set K0 0.9996

    # WGS-84
    set er 6378137                              ;# EquatorialRadius
    set es2 0.00669438                          ;# EccentricitySquared
    set es4 [expr {$es2 * $es2}]
    set es6 [expr {$es2 * $es2 * $es2}]

    # Must be in the range -180 <= lon < 180
    while {$longitude < -180} { set longitude [expr {$longitude + 360}]}
    while {$longitude >= 180}  { set longitude [expr {$longitude - 360}]}

    # Now convert
    set lat_rad [expr {$latitude * $PI / 180.0}]
    set lon_rad [expr {$longitude * $PI / 180.0}]

    set zone [expr {int(($longitude + 180) / 6) + 1}]
    if {$forceZone ne ""} { set zone $forceZone }
    if {$latitude >= 56.0 && $latitude < 64.0 &&
	$longitude >= 3.0 && $longitude < 12.0} {
	$zone = 32
    }
    if { $latitude >= 72.0 && $latitude < 84.0 } {
	if { $longitude >= 0.0  && $longitude <  9.0 } {$zone = 31;}
	if { $longitude >= 9.0  && $longitude < 21.0 } {$zone = 33;}
	if { $longitude >= 21.0 && $longitude < 33.0 } {$zone = 35;}
	if { $longitude >= 33.0 && $longitude < 42.0 } {$zone = 37;}
    }
    # +3 puts origin in middle of zone
    set lon_origin [expr {( $zone - 1 ) * 6 - 180 + 3}]
    set lon_origin_rad [expr {$lon_origin * $PI / 180.0}]
    set eccPrimeSquared [expr {$es2 / ( 1.0 - $es2 )}]
    set N [expr {$er / sqrt( 1.0 - $es2 * sin( $lat_rad ) * sin( $lat_rad ) )}]
    set T [expr {tan( $lat_rad ) * tan( $lat_rad )}]
    set C [expr {$eccPrimeSquared * cos( $lat_rad ) * cos( $lat_rad )}]
    set A [expr {cos( $lat_rad ) * ( $lon_rad - $lon_origin_rad )}]
    set M [expr { $er * ( \
			      (1.0 - $es2 / 4 - 3 * $es4 / 64 - 5 * $es6 / 256) * $lat_rad \
			      - (3 * $es2 / 8 + 3 * $es4 / 32 + 45 * $es6 / 1024) * sin(2 * $lat_rad) \
			      + (15 * $es4 / 256 + 45 * $es6 / 1024 )             * sin(4 * $lat_rad) \
			      - (35 * $es6 / 3072 )                               * sin(6 * $lat_rad) \
			      )}]
    set easting [expr {$K0 * $N * ( $A + ( 1 - $T + $C ) * $A * $A * $A / 6 \
					+ ( 5 - 18 * $T + $T * $T + 72 * $C - 58 * $eccPrimeSquared ) * \
					$A * $A * $A * $A * $A / 120 ) + 500000.0}]
    set northing [expr {$K0 * ( $M + $N * tan( $lat_rad ) * \
				    ( $A * $A / 2 + ( 5 - $T + 9 * $C + 4 * $C * $C ) * \
					  $A * $A * $A * $A / 24 + ( 61 - 58 * $T + $T * $T + \
									 600 * $C - 330 * $eccPrimeSquared ) * \
					  $A * $A * $A * $A * $A * $A / 720 ) )}]

    if {$latitude < 0} {  ;# 1e7 meter offset for southern hemisphere
	set northing [expr {$northing + 10000000.0}]
    }

    set northing [expr {int($northing)}]
    set easting [expr {int($easting)}]
    if {$latitude > 84.0 || $latitude < -80.0} {
	set letter "Z"
    } else {
	set l [expr {int(($latitude + 80) / 8.0)}]
	set letter [string index "CDEFGHJKLMNPQRSTUVWXX" $l]
    }

    return [list $northing $easting $zone $letter]
}
##+##########################################################################
#
# ::Data::utm2ll -- converts from UTM to lat/lon.
# NB. ALWAYS makes longitude positive
#
proc ::Data::utm2ll {northing easting zone {letter S}} {
    set PI [expr {atan(1) * 4}]
    set K0 0.9996

    # WGS-84
    set er 6378137                              ;# EquatorialRadius
    set es2 0.00669438                          ;# EccentricitySquared
    set es2x [expr {1.0 - $es2}]

    set x [expr {$easting - 500000.0}]
    set northernHemisphere [expr {$letter >= "N"}]
    set y [expr {$northing - ($northernHemisphere ? 0.0 : 10000000.0)}]
    set lon_origin [expr {($zone - 1) * 6 - 180 + 3}] ;# +3 puts in middle
    set ep2 [expr {$es2 / $es2x}]
    set e1 [expr {(1.0 - sqrt($es2x)) / (1.0 + sqrt($es2x))}]
    set M [expr {$y / $K0}]
    set mu [expr {$M / ($er * (1.0 - $es2 /4.0 - 3 * $es2 * $es2 /64.0
			       - 5 * $es2 * $es2 * $es2 /256.0))}]
    set phi [expr {$mu + (3 * $e1 / 2 - 27 * $e1 * $e1 * $e1 / 32 ) * sin(2*$mu)
		   + (21 * $e1 * $e1 / 16 - 55 * $e1 * $e1 * $e1 * $e1 / 32)
		   * sin(4*$mu ) + (151 * $e1 * $e1 * $e1 / 96 ) * sin(6*$mu)}]
    set N1 [expr {$er / sqrt(1.0 - $es2 * sin($phi) * sin($phi))}]
    set T1 [expr {tan($phi) * tan($phi)}]
    set C1 [expr {$ep2 * cos($phi) * cos($phi)}]
    set R1 [expr {$er * $es2x / pow(1.0 - $es2 * sin($phi) * sin($phi), 1.5)}]
    set D [expr {$x / ($N1 * $K0)}]
    set latitude [expr {$phi - ($N1 * tan($phi) / $R1)
			* ($D * $D / 2
			   - (5 + 3 * $T1 + 10 * $C1 - 4 * $C1 * $C1 - 9 * $ep2)
			   * $D * $D * $D * $D / 24
			   + (61 + 90 * $T1 + 298 * $C1 + 45 * $T1 * $T1
			      - 252 * $ep2 - 3 * $C1 * $C1 )
			   * $D * $D * $D * $D * $D * $D / 720)}]
    set latitude [expr {$latitude * 180.0 / $PI}]
    set longitude [expr {($D - (1 + 2 * $T1 + $C1)
			  * $D * $D * $D / 6
			  + (5 - 2 * $C1 + 28 * $T1 - 3 * $C1 * $C1
			     + 8 * $ep2 + 24 * $T1 * $T1)
			  * $D * $D * $D * $D * $D / 120)
			 / cos($phi)}]
    set longitude [expr {$lon_origin + $longitude * 180.0 / $PI}]

    set longitude [expr {-1 * $longitude}]
    return [list $latitude $longitude]
}
##+##########################################################################
#
# ::Data::GuessClimbing
#
# If climbing values are unknown, it guesses the climbing values based
# on the starting and ending nodes elevations
#
# Quality: 0 perfect data; 1 one-way road data; 2 topo Z;
#          3 endpoint delta; 4 no end point info
#
proc ::Data::GuessClimbing {north south id1 id2 z} {
    global nodes

    # Determine if either north or south is bad
    foreach {north nbad} [::BadMath::Split $north] break
    foreach {south sbad} [::BadMath::Split $south] break

    if {! $nbad && ! $sbad} {			;# Is the data already valid???
	return [list $north $south 0]
    }
    set nelev [lindex $nodes($id1) 1]		;# Get endpoint elevation
    set selev [lindex $nodes($id2) 1]

    # If either end node has unknown elevation then give up
    if {[::BadMath::IsBad $nelev] || [::BadMath::IsBad $selev]} {
	if {$nbad} { set north "0+?" }
	if {$sbad} { set south "0+?" }
	return [list $north $south 4]
    }

    regsub -all {\s*\?} $z {} z
    set zz [concat $nelev [expr {$nelev + ($sbad ? 0 : $south)}] \
		$z \
		[expr {$selev + ($nbad ? 0 : $north)}] $selev]
    foreach {gSouth gNorth} [::Data::PreCalcClimb $zz] break
    if {$nbad} {set north "$gNorth+?"}
    if {$sbad} {set south "$gSouth+?"}

    if {! $nbad || ! $sbad} {			;# One-way road data
	return [list $north $south 1]
    }
    if {[llength $z] > 0} {			;# Some topo Z info
	return [list $north $south 2]
    }
    return [list $north $south 3]
}
proc ::Data::GuessClimbingX {rid} {
    global nodes roads

    foreach {id1 id2 north . south . . . . z} $roads($rid) break

    # Determine if either north or south is bad
    foreach {north nbad} [::BadMath::Split $north] break
    foreach {south sbad} [::BadMath::Split $south] break

    set nelev [lindex $nodes($id1) 1]		;# Get endpoint elevation
    set selev [lindex $nodes($id2) 1]

    # If either end node has unknown elevation then give up
    if {[::BadMath::IsBad $nelev] || [::BadMath::IsBad $selev]} {
	set q 0
	if {$nbad} { set north "0+?" ; set q 4}
	if {$sbad} { set south "0+?" ; set q 4}
	return [list $north $south $q]
    }

    regsub -all {\s*\?} $z {} z
    set zz [concat $nelev [expr {$nelev + ($sbad ? 0 : $south)}] \
		$z \
		[expr {$selev + ($nbad ? 0 : $north)}] $selev]

    set rzz [::Data::Reverse $zz]
    set north2 0
    set alt [lindex $rzz 0]
    foreach alt2 $rzz {
	if {! [string is double $alt2] || $alt2 < 0} continue
	if {$alt2 > $alt} { set north2 [expr {$north2 + $alt2 - $alt}] }
	set alt $alt2
    }
    if {$nbad} {
	set north "$north2+?"
    } else {
	set north [Max $north $north2]
    }

    set south2 0
    set alt [lindex $zz 0]
    foreach alt2 $zz {
	if {! [string is double $alt2] || $alt2 < 0} continue
	if {$alt2 > $alt} { set south2 [expr {$south2 + $alt2 - $alt}] }
	set alt $alt2
    }
    if {$sbad} {
	set south "$south2+?"
    } else {
	set south [Max $south $south2]
    }

    if {! $nbad && ! $sbad} {			;# Is the data already valid???
	return [list $north $south 0]
    }

    if {! $nbad || ! $sbad} {			;# One-way road data
	return [list $north $south 1]
    }
    if {[llength $z] > 0} {			;# Some topo Z info
	return [list $north $south 2]
    }
    return [list $north $south 3]		;# End node altitude delta
}
##+##########################################################################
#
# ::Data::GuessRoadName
#
# Given two end points, try to determine the road name by seeing if
# the same road name appears in both end points.
#
proc ::Data::GuessRoadName {name id1 id2 rid} {
    global nodes roads

    set name [string trim $name]		 ;# Is there already a name?
    if {$name ne ""} { return $name }		 ;# Yes, so use it

    set node1 [lindex $nodes($id1) 0]		 ;# Look at both end points
    set node2 [lindex $nodes($id2) 0]

    regsub -all {\s*\(.*?\)\s*} $node1 {} node1	 ;# ???
    regsub -all {\s*\(.*?\)\s*} $node2 {} node2

    # Split around the "&" character
    if {[regexp {(.*)\s+&\s+(.*)} $node1 {} n11 n12] && \
	    [regexp {(.*)\s+&\s+(.*)} $node2 {} n21 n22]} {
	if {$n11 == $n21 || $n11 == $n22} {
	    return $n11
	} elseif {$n12 == $n21 || $n12 == $n22} {
	    return $n12
	}
    }

    #puts "no name for: $rid : $id1 $node1  <=> $id2 $node2"
    return ""
}
##+##########################################################################
#
# ::Data::ProcessRoads -- preprocess the road data into NR for faster retrieval
#
proc ::Data::ProcessRoads {{who {}}} {
    global nodes roads zone NR trails

    set cnt 0
    if {$who eq {}} {
	set who [array names roads]
	catch {unset NR}
    }

    foreach rid $who {
	foreach {id1 id2 north dist south type . . . . q} $roads($rid) break
	if {! [info exists trails(type,$type)] && \
		! [info exists trails(user,$type)]} {
	    set type 0
	    lset roads($rid) 5 $type
	}

	if {![info exists nodes($id1)] || ![info exists nodes($id2)]} continue

	if {$q <= $zone(goodData)} {
	    set north [::BadMath::MakeGood $north]
	    set south [::BadMath::MakeGood $south]
	    set dist  [::BadMath::MakeGood $dist]
	}

	if {[::Data::IsNorthNode $id1 $id2]} {	 ;# South bound
	    set NR($rid,$id1,$id2) [list $rid $dist $south $north $type]
	    set NR($rid,$id2,$id1) [list $rid $dist $north $south $type]
	} else {
	    set NR($rid,$id1,$id2) [list $rid $dist $north $south $type]
	    set NR($rid,$id2,$id1) [list $rid $dist $south $north $type]
	}
	incr cnt
    }
    return $cnt
}
##+##########################################################################
#
# ::Data::IsNorthNode
#
# Returns 1 if node1 is north of node2
#
proc ::Data::IsNorthNode {node1 node2} {
    global nodes

    set lat1 [lindex $nodes($node1) 2]
    set lat2 [lindex $nodes($node2) 2]

    if {$lat1 >= $lat2} { return 1 }
    return 0
}
##+##########################################################################
#
# ::Data::XYReverse
#
# Returns the XY extra road data reversed
#
proc ::Data::XYReverse {xy} {
    set result {}
    foreach {a1 a2 a3 b1 b2 b3} $xy {
	set result [concat $a1 $a2 $a3 $b1 $b2 $b3 $result]
    }
    return $result
}
proc ::Data::XYZReverse {xyz} {
    set result {}
    foreach {a1 a2 a3 b1 b2 b3 alt} $xyz {
	set result [concat $a1 $a2 $a3 $b1 $b2 $b3 $alt $result]
    }
    return $result
}
##+##########################################################################
#
# ::Data::Reverse -- reverses the z data (just list reverse)
#
proc ::Data::Reverse {z} {
    set result {}
    foreach zz $z { set result [concat [list $zz] $result] }
    return $result
}
##+##########################################################################
#
# ::Data::2Reverse -- reverses list by pairs
#
proc ::Data::2Reverse {l} {
    set result {}
    foreach {a b} $l {
	set result [concat $a $b $result]
    }
    return $result
}
##+##########################################################################
#
# ::Data::ProcessOnePOI
#
# Takes raw POI (point of interest) data and puts it into our data structures.
#
proc ::Data::ProcessOnePOI {line} {
    global poi

    foreach {. pid type name lat1 lat2 lat3 lon1 lon2 lon3 \
		 location ldesc url} $line break
    set lat [lat2int $lat1 $lat2 $lat3]
    set lon [lat2int $lon1 $lon2 $lon3]

    set xy [::Display::pos2canvas root $lat $lon]
    set poi($pid) [list $type $name $lat $lon $location $ldesc $xy $url]
    ::Data::MarkModified poi $pid
}
##+##########################################################################
#
# ::Data::ProcessOneSplit
#
# Updates the split array w/ data from node file. We assume the new roads
# and node have already been read in so we only need to delete the old road.
#   => S r275 => Xn601.741902792 Xr602.741902880 Xr603.741902891
#
proc ::Data::ProcessOneSplit {line} {
    global splits roads
    foreach {s rid => nid rid1 rid2} $line {
	if {! [info exists roads($rid)]} continue ;# Road doesn't exist
	set splits(f,$rid) [list $nid $rid1 $rid2]
	set splits(r,$rid1) $rid		;# Reverse split info
	set splits(r,$rid2) $rid
	set splits(u,$rid) $roads($rid)
	lappend splits(undo) $rid
	::Edit::DeleteRoad $rid 1
	::Data::MarkModified split f,$rid
    }
}
##+##########################################################################
#
# ::Data::ProcessOneTrail -- handles trail definition lines
#   T t1 "White Tail Loop" red 3 magenta 6
#
proc ::Data::ProcessOneTrail {line} {
    global state trails

    set default {. tid tname blue 3 magenta 6}
    set line2 [concat $line [lrange $default [llength $line] end]]

    foreach {. tid tname color1 width1 color2 width2} $line2 break
    set trails(user,$tid) $tname
    set trails(rtype,$tname) $tid

    set state(r,0,$tid,color) $color1
    set state(r,0,$tid,width) $width1
    set state(r,1,$tid,color) $color2
    set state(r,1,$tid,width) $width2
    set state(r,balloon,$tid,color) $color2
    set state(r,balloon,$tid,width) $width2
    ::Data::MarkModified trail $tid
}
proc ::Data::ProcessOnePhoto {line} {
    foreach {. phid lat lon url sdesc ldesc} $line break
    ::Photo::AddNew $phid $lat $lon $url $sdesc $ldesc
}

proc ::Data::ProcessOneEmbellishment {line} {
    foreach {. eid type ll options} $line break
    ::Embellishment::AddNew $eid $type $ll $options
}
##+##########################################################################
#
# ::Data::DistanceToLine
#
# Given a point and a line segment, determines how close that point is
# to that line segment. We drop a perpendicular line and see how far
# along the line segment it is (hdist). If it before or after the line
# segment then we take the euclidean distance, otherwise we take the
# distance along the perpendicular.
#
proc ::Data::DistanceToLine {PX PY x0 y0 x1 y1} {
    set lx [expr {$x1 - $x0}]			;# Line vector
    set ly [expr {$y1 - $y0}]
    set d [expr {hypot($lx, $ly)}]		;# To normalize line vector
    if {$d == 0} {				;# Degenerate line
	return 99999
    }

    set px [expr {$PX - $x0}]			;# Vector to our point
    set py [expr {$PY - $y0}]

    set hdist [expr {($px*$lx + $py*$ly) / $d}]	;# Distance along line vector
    set vdist [expr {($py*$lx - $px*$ly) / $d}]	;# Distance along perpendicular

    if {$hdist < 0} {				;# Point behind line segment
	set rdist [expr {hypot($px, $py)}]
    } elseif {$hdist <= $d} {			;# Point w/i line segment
	set rdist [expr {abs($vdist)}]
    } else {					;# Point beyond line segment
	set px [expr {$PX - $x1}]
	set py [expr {$PY - $y1}]
	set rdist [expr {hypot($px, $py)}]
    }

    return $rdist
}
##+##########################################################################
#
# ::Data::NearestPointOnLine -- returns x,y of nearest point on line PX,PY
#
proc ::Data::NearestPointOnLine {PX PY x0 y0 x1 y1} {
    set lx [expr {$x1 - $x0}]			;# Line vector
    set ly [expr {$y1 - $y0}]
    set d [expr {hypot($lx, $ly)}]		;# To normalize line vector
    if {$d == 0} {				;# Degenerate line
	return [list $x0 $y0]
    }

    set px [expr {$PX - $x0}]			;# Vector to our point
    set py [expr {$PY - $y0}]

    set hdist [expr {($px*$lx + $py*$ly) / $d}]	;# Distance along line vector
    set hdist [Median 0 $hdist $d]		;# Clamp to w/i 0 to d

    set x [expr {$x0 + $lx * $hdist / $d}]
    set y [expr {$y0 + $ly * $hdist / $d}]
    return [list $x $y]
}
##+##########################################################################
#
# ::Data::MakeXYZ -- combines xy and z data into xyz format
#
proc ::Data::MakeXYZ {xy z} {
    if {$xy eq {}} {return {}}
    if {$z eq {}} {return [concat "xy" $xy]}

    set hasZ 0
    set xyz {xyz}
    foreach {a b c d e f} $xy zz $z {
	if {$zz eq {}} {set zz "?"}
	if {$zz ne "?"} {set hasZ 1}
	lappend xyz $a $b $c $d $e $f $zz
    }
    if {$hasZ} { return $xyz }
    return [concat "xy" $xy]
}
##+##########################################################################
#
# ::Data::Units -- converts units, handles imprecise data and plurals
#  type  : dist, area, climb, weight
#  style : what type of label
#  btype : how to handle bad data
#
proc ::Data::Units {num type {style 0} {btype 0}} {
    set num [::Data::Convert $num $type]
    set result [::Data::Label $num $type $style $btype]
    return $result
}
##+##########################################################################
#
# ::Data::Label -- Prettifies number w/ commas, label and bad data
#    num: external units
#    type: dist or climb or area or weight (miles/kilometers vs feet/meters)
#    style: 0 miles/feet/kilometers/meters
#           1 mi/ft/km/m
#           2 mi/'/km/m
#           3 miles/feet/km/meters
#           4 nothing
#    btype: 0 => 10+?; 1 => about 10; 2 => ?
#
proc ::Data::Label {num type style {btype 0}} {
    variable labels

    foreach {val bad} [::BadMath::Split $num] break
    set result [comma $val]
    if {$bad && $btype == 1} {
	set result "about $result"
    } elseif {$bad && $btype == 2} {
	set result "?"
    } elseif {$bad} {
	append result "+?"
    }

    # Now append appropriate label
    set eunits $::state(units,external)
    if {$eunits eq "default"} {set eunits $::state(units,internal)}
    set lbl $labels($type,$eunits,$style)
    if {$val != 1 && ($style == 0 || $style == 3)} {
	if {$lbl eq " foot"} {
	    set lbl " feet"
	} elseif {$lbl ne " km"} {
	    append lbl "s"
	}
    }
    append result $lbl
    return $result
}
##+##########################################################################
#
# ::Data::Convert -- converts from internal units to external units
#      type: climb, dist
#
proc ::Data::Convert {num type} {
    variable etypes ; variable mtypes

    if {$num eq "" || $num eq "?"} {return $num}

    foreach {val bad} [::BadMath::Split $num] break

    if {$::state(units,external) ne "default" &&
	$::state(units,internal) ne $::state(units,external)} {
	if {$::state(units,external) eq "metric"} {
	    set val [::Data::ToMetric $val $etypes($type)]
	} else {
	    set val [::Data::ToEnglish $val $mtypes($type)]
	}
    }
    set val [format %g $val]			;# Tcl 8.5 precision "fix"
    if {$bad} {append val "+?"}
    return $val
}
##+##########################################################################
#
# RConvert -- converts from external units to internal units
#      type: area, climb, dist
#
proc ::Data::RConvert {num type} {
    variable etypes ; variable mtypes

    if {$num eq {}} { return $num }
    if {$::state(units,external) eq "default"} { return $num }
    if {$::state(units,internal) == $::state(units,external)} { return $num }

    foreach {val bad} [::BadMath::Split $num] break
    if {$::state(units,external) eq "metric"} {
	set val [::Data::ToEnglish $val $mtypes($type)]
    } else {
	set val [::Data::ToMetric $val $etypes($type)]
    }
    if {$bad} { append val "+?" }
    return $val
}
##+##########################################################################
#
# ::Data::RConvert2 -- converts from english or metric into internal units
#      type: area, climb, dist
#      units: english, metric
#
proc ::Data::RConvert2 {num type units} {
    variable etypes ; variable mtypes

    if {$num eq {}} { return $num }
    if {$units eq $::state(units,internal)} { return $num }

    foreach {val bad} [::BadMath::Split $num] break
    if {$units eq "metric"} {
	set val [::Data::ToEnglish $val $mtypes($type)]
    } else {
	set val [::Data::ToMetric $val $etypes($type)]
    }
    if {$bad} { append val "+?" }
    return $val
}
##+##########################################################################
#
# ::Data::TempConvert -- Converts fahrenheit to celsius if needed
#
proc ::Data::TempConvert {fahrenheit} {
    if {$::state(units,external) ne "metric"} {
	return $fahrenheit
    }
    set celsius [expr {($fahrenheit-32)/1.8}]
    set celsius [Round1 $celsius]
    return $celsius
}
proc ::Data::TimeFormat {minutes {trim 0}} {
    set minutes [expr {round($minutes)}]
    set min [expr {$minutes % 60}]
    set hour [expr {($minutes / 60) % 24}]
    set days [expr {($minutes / 60 / 24)}]
    set result [format "%02d:%02d:%02d" $days $hour $min]
    regsub {^00:} $result {} result
    if {$trim} {
	set result [string trimleft $result "0"]
    }
    return $result
}
proc ::Data::ReadTime {val} {
    if {! [catch {clock scan $val} vval]} { return $vval }
    set re {(\d\d\d\d-\d\d-\d\d)T(\d\d:\d\d:\d\d)(\.\d*)?Z}
    if {[regsub $re $val {\1 \2} val2]} {
	if {! [catch {clock scan $val2} vval]} { return $vval }
    }
    return ""
}
##+##########################################################################
#
# ::Data::IsPriviledged -- queries priviledged status
#
proc ::Data::IsPriviledged {what} {
    if {$what ne "printing"} {return 0}

    if {$::state(beta)} {return 1}
    if {$::state(me) && ! $::state(starpack)} {
	WARN "I'm letting you print just this time!"
	return 1
    }

    set fname [file join $::state(wdir) Images "klimb2.gif"]
    return [file exists $fname]
}
##+##########################################################################
#
# ::Data::SetPriviledge -- sets priviledge status and gives message
#
proc ::Data::SetPriviledge {what onoff} {
    if {$what ne "printing"} {return 0}
    set fname [file join $::state(wdir) Images "klimb2.gif"]
    set iname [file join $::state(idir) klimb.gif]
    set action [expr {$onoff ? "enable" : "disable"}]

    if {$onoff} {
	if {! [file exists $fname]} { file copy -- $iname $fname }
	.m.file entryconfig "Print..." -state normal
	unset -nocomplain ::state(can,printMaps)
    } else {
	file delete $fname
	.m.file entryconfig "Print..." -state disabled
    }
    if {!! $onoff == !! [file exists $fname]} {
	set txt "Printing is now ${action}d."
	DoInfo $txt $::state(progname)
    } else {
	set txt "ERROR: couldn't $action printing.\nContact support@klimb.org"
	WARN $txt
    }
}
##+##########################################################################
#
# ::Data::lunique -- Returns a list w/ duplicates removed
#
proc ::Data::lunique {l} {
    set r {}
    foreach ll $l {
	if {[lsearch $r $ll] == -1} {lappend r $ll}
    }
    return $r
}
##+##########################################################################
#
# ::Data::lsearchX -- lsearch w/ nocase and handle unambigous abbreviations
#
proc ::Data::lsearchX {what whence} {
    set n [lsearch -nocase $whence $what]
    if {$n > -1} { return $what }
    set all [lsearch -nocase -glob -all -inline $whence ${what}*]
    if {[llength $all] == 1} { return [lindex $all 0] }
    return ""

    # this fails if you have 2 ambiguous and 1 exact match
    set found ""
    set len [string length $what]
    foreach a $whence {
	if {[string equal -nocase $what $a]} { return $a }
	if {[string equal -nocase -length $len $what $a]} {
	    if {$found ne ""} {return ""}	;# Ambiguous
	    set found $a
	}
    }
    return $found
}
##+##########################################################################
#
# ::Data::Flatten -- Flattens an arbitrarily nested list
#
proc ::Data::Flatten {l} {
    if {[llength $l] == 1} { return $l }
    set result {}
    foreach elem $l {
	set l2 [::Data::Flatten $elem]
	lappend result {*}$l2
    }
    return $result
}
##+##########################################################################
#
# ::Data::Shuffle -- shuffles a list
#
proc ::Data::Shuffle { alist } {
    set len [llength $alist]
    set len2 $len
    for {set i 0} {$i < $len-1} {incr i} {
	set n [expr {int($i + $len2 * rand())}]
	incr len2 -1

	# Swap elements at i & n
	set temp [lindex $alist $i]
	lset alist $i [lindex $alist $n]
	lset alist $n $temp
    }
    return $alist
}
##+##########################################################################
#
# ::Data::MarkModified -- keeps track of nodes, etc. that have been changed
#
proc ::Data::MarkModified {what who {delete 0}} {
    variable changed
    global region

    if {$delete} {
	set changed($what) [ldelete $changed($what) $who]
	if {[info exists regions($what,visible)]} {
	    set region($what,visible) [ldelete $region($what,visible) $who]
	}
    } else {
	if {[lsearch -exact $changed($what) $who] == -1} {
	    lappend changed($what) $who
	}
    }
    .m.file entryconfigure "Save User Data" -state normal
    set ::state(modified) 1
}
##+##########################################################################
#
# ::Data::ClearModified -- erases all changed info
#
proc ::Data::ClearModified {{dataToo 0}} {
    if {$dataToo} {
	array unset ::Data::changed
	foreach who {node road split poi geo trail photo} {
	    set ::Data::changed($who) {}
	}
    }
    if {[winfo exists .m.file]} {
	.m.file entryconfigure "Save User Data" -state disabled
    }
    set ::state(modified) 0
}
##+##########################################################################
#
# ::Data::SaveData -- prompts to save user data
#
proc ::Data::SaveData {} {
    if {! $::state(modified)} { return "yes" }
    set ans [tk_messageBox -type yesnocancel -message "Save your changes?" \
		 -title "$::state(progname) Exit" -icon question]
    if {$ans eq "yes"} {
	::Save::SaveUserDataCmd 1
    }
    return $ans
}
##+##########################################################################
#
# ::Data::FixExtension -- Adds default to fname if name doesn't
# have an extension
#
proc ::Data::FixExtension {fname default} {
    set fname [string trimright $fname "."]
    if {[file extension $fname] eq ""} {
	append fname "." [string trimleft $default "."]
    }
    return $fname
}
##+##########################################################################
#
# ::Data::WhichRegion -- figures out which region/mag a node/road/etc. is in
#
proc ::Data::WhichRegion {what {mag *}} {
    global nodes roads poi photos region

    if {[llength $what] == 1} {
	set what2 [::Edit::FindNode $what]
	if {[info exists nodes($what)]} {
	    foreach {. . lat lon} $nodes($what) break
	} elseif {[info exists nodes($what2)]} {
	    foreach {. . lat lon} $nodes($what2) break
	} elseif {[info exists roads($what)]} {
	    set nid [lindex $roads($what) 0]
	    foreach {. . lat lon} $nodes($nid) break
	} elseif {[info exists poi($what)]} {
	    foreach {. . lat lon} $poi($what) break
	} elseif {[info exists photos($what)]} {
	    foreach {lat lon} $photos($what) break
	} else {
	    error "unknown node or road: $what"
	}
    } elseif {[llength $what] == 2} {
	foreach {lat lon} $what break
    } elseif {[llength $what] == 6} {
	foreach var {lat lon} {a b c} $what {
	    set $var [lat2int $a $b $c]
	}
    } else {
	error "usage: ::Data::WhichRegion {lat lon} | <node id> | <road id> | <poi id> | <photo id>"
    }

    set result {}
    foreach which [lsort -dictionary [array names ::region *,$mag,maps]] {
	lassign [split $which ","] rname mag
	if {$rname eq "Multiple"} continue
	foreach mmap $::region($which) {
	    if {$region($rname,UTM)} {
		foreach {n0 e0 z0 n1 e1 z1} $::map($mmap) break
		foreach {lat0 lon0} [::Data::utm2ll $n0 $e0 $z0] break
		foreach {lat1 lon1} [::Data::utm2ll $n1 $e1 $z1] break
	    } else {
		foreach var {lat0 lon0 lat1 lon1} {a b c} $::map($mmap) {
		    set $var [lat2int $a $b $c]
		}
	    }
	    if {$lat > $lat0 || $lat < $lat1} continue
	    if {$lon > $lon0 || $lon < $lon1} continue
	    lappend result [list $rname $mag]
	}
    }
    return $result
}
##+##########################################################################
#
# ::Data::SetCover::Get -- Performs greedy set cover algorithm
# Return: [list regionName...]
#
proc ::Data::SetCover::Get {mag nids} {
    set cover {}
    set missingNids $nids
    while {$missingNids ne {}} {
	set greedy [::Data::SetCover::Greedy $mag $missingNids]
	if {$greedy eq {}} break

	lassign [lindex $greedy 0] who missingNids
	lappend cover $who
    }
    return [list $cover $missingNids]
}
##+##########################################################################
#
# ::Data::SetCover::Greedy -- Finds which region covers the most nids.
# Returns [list [list regionName missingNids]...]
#
proc ::Data::SetCover::Greedy {mag nids} {
    unset -nocomplain COVER
    set regionNames [::Region::GetNamesAtMag $mag]
    foreach rname $regionNames {
	set COVER($rname,in) [set COVER($rname,out) {}]
    }
    foreach nid $nids {
	set where [::Data::WhichRegion $nid $mag]
	foreach rname $regionNames {
	    if {[lsearch -index 0 $where $rname] > -1} {
		lappend COVER($rname,in) $nid
	    } else {
		lappend COVER($rname,out) $nid
	    }
	}
    }
    set who {}
    set best -1
    foreach rname $regionNames {
	set numIn [llength $COVER($rname,in)]
	if {$numIn == 0} continue
	if {$numIn > $best} {
	    set who [list $rname]
	    set best $numIn
	} elseif {$numIn == $best} {
	    lappend who $rname
	}
    }
    set result {}
    foreach rname $who {
	lappend result [list $rname $COVER($rname,out)]
    }
    return $result
}
##+##########################################################################
#
# ::Data::SetCover::MissingFromCover -- Given a set of regions and nodes,
# returns which nodes aren't covered by the regions.
#
proc ::Data::SetCover::MissingFromCover {rnames mag nids} {
    set missing {}
    foreach nid $nids {
	set where [::Data::WhichRegion $nid $mag]
	set ok 0
	foreach rname $where {
	    if {[lsearch $rnames [lindex $rname 0]] > -1} {
		set ok 1
		break
	    }
	}
	if {! $ok} { lappend missing $nid }
    }
    return $missing
}
##+##########################################################################
#
# ::Data::GetFileUsage -- gets disk usage for a directory tree
#
proc ::Data::GetFileUsage {basedir {callback ""} {first 1}} {
    variable tcnt

    update
    if {! [winfo exists .opt]} {return {0 0}}

    if {$first} { set tcnt 0}

    if { [file isfile $basedir] } {
	return [list [file size $basedir] 1]
    }
    if { ! [file isdirectory $basedir] } {
	return {0 0}
    }

    set fsizes 0
    set fcnt 0
    set fnames [glob -directory $basedir -tails -nocomplain -- *]
    foreach fname $fnames {
	if {([incr tcnt] % 100) == 0} {		;# Come up for air
	    if {$callback ne ""} { catch {eval $callback $tcnt} }
	    update
	    if {! [winfo exists .opt]} {return {0 0}}
	}

	if {$fname eq "." || $fname eq ".."} continue
	set fullname [file join $basedir $fname]

	if {[file isfile $fullname]} {
	    incr fsizes [file size $fullname]
	    incr fcnt
	}
	if {[file isdirectory $fullname]} {
	    foreach {fsize1 fcnt1} \
		[::Data::GetFileUsage $fullname $callback 0] break
	    incr fsizes $fsize1
	    incr fcnt $fcnt1
	}
    }
    return [list $fsizes $fcnt]
}
##+##########################################################################
#
# ::Data::DoCanDoTest -- Tests all known cando possibilities
#
proc ::Data::DoCanDoTest {} {
    set pkgs {3d anigif atlas autoscroll googleearth grabWindow internet jpeg
	pdf4tcl pdfCanvas pdfText pgu png printMaps printText registry sframe
	slippy snapshot statistics swaplist tcl8.5 tdom tktable weather webPage
	xphoto
    }
    ::Atlas::CanDo 1				;# To avoid a warning
    ::3D::CanDo 1				;# To avoid a warning

    set results {}
    foreach pkg $pkgs {
	lappend results $pkg [::Data::CanDo $pkg]
    }
    return $results
}
##+##########################################################################
#
# ::Data::CanDo -- central place for all tests of available features
#  NB. we update auto_path in non-starpack version
#
proc ::Data::CanDo {what {emsg ""}} {
    global state
    array set pkg {
	registry registry
	tktable Tktable
	anigif anigif
	statistics math::kstatistics
	pgu pgu
	png img::png
	jpeg img::jpeg
	grabWindow img::window
	autoscroll autoscroll
	tdom tdom
	pdfCanvas trampoline
	pdfText text2pdf
	pdf4tcl pdf4tcl
	sframe Scrolledframe
	xphoto xphoto
	email registry
	slippy map::kpv_slippy
	uri uri
    }

    if {[info exists state(can,$what)]} {
	if {! $state(can,$what) && $emsg ne ""} {
	    WARN $emsg
	}
	return $state(can,$what)
    }

    while {1} {
	if {[info exists pkg($what)]} {
	    set state(can,$what) [expr {! [catch {package require $pkg($what)}]}]
	    break
	}

	if {$what eq "tcl8.5"} {
	    set state(can,$what) [package vsatisfies [package require Tcl] 8.5]
	    break
	}

	if {$what eq "tile" || $what eq "tile0.7.8"} {
	    ::Init::LoadTile
	    break
	}
	if {$what eq "webPage"} {
	    CanLaunchBrowser
	    break
	}
	if {$what eq "printMaps"} {
	    ::Print::CanPrint
	    break
	}
	if {$what eq "printText"} {
	    CanPrintText
	    break
	}
	if {$what eq "snapshot"} {
	    ::Snapshot::CanSnapshot
	    break
	}
	if {$what eq "weather"} {
	    ::Weather::CanDo
	    break
	}
	if {$what eq "internet"} {
	    ::Init::Internet
	    break
	}
	if {$what eq "swaplist"} {
	    set state(can,$what) [expr {! [catch {package require kswaplist}]}]
	    ::Data::CanDo autoscroll		;# Nice, but not required
	    break
	}
	if {$what eq "googleearth"} {
	    set state(can,$what) [expr {$state(windows) || \
					    [auto_execok googleearth] ne ""}]
	    break
	}
	if {$what eq "atlas"} {
	    ::Atlas::CanDo
	    break
	}

	if {$what eq "3d"} {
	    # Don't set state(can,3d) because we don't
	    # really know until we try to use it
	    return [::3D::CanDo]
	    break
	}

        if {$what eq "stipple"} {
            set state(can,$what) [expr {! $state(macosx)}]
            break
        }

	#set emsg "Internal error: unknown CanDo feature: '$what'"
	set state(can,$what) 0
	break
    }
    if {! $state(can,$what) && $emsg ne ""} {
	WARN $emsg
    }
    return $state(can,$what)
}
##+##########################################################################
#
# ::Data::VAdd -- adds two vectors w/ scaling of 2nd vector
# ::Data::VSub -- subtract two vectors
proc ::Data::VAdd {v1 v2 {scaling 1}} {
    foreach {x1 y1} $v1 {x2 y2} $v2 break
    return [list [expr {$x1 + $scaling*$x2}] [expr {$y1 + $scaling*$y2}]]
}
proc ::Data::VSub {v1 v2} { return [::Data::VAdd $v1 $v2 -1] }
proc ::Data::VReScale {v scaling} {
    foreach {x y} $v break
    set len [expr {hypot($x,$y)}]
    return [list [expr {$x * $scaling / $len}] [expr {$y * $scaling / $len}]]
}
proc ::Data::VNormalTo {vv length} {
    foreach {x y} $vv break
    set len [expr {hypot($x,$y)}]
    set xx [expr {-$y * $length / $len}]
    set yy [expr {$x * $length / $len}]
    return [list $xx $yy]
}
proc ::Data::VBisect {p1 p2 p3} {
    set v1 [::Data::VReScale [::Data::VSub $p1 $p2] 1]
    set v2 [::Data::VReScale [::Data::VSub $p3 $p2] 1]
    set v [::Data::VReScale [::Data::VAdd $v1 $v2] 1]
    return $v
}
proc ::Data::VDot {v1 v2} {
    foreach {x1 y1} $v1 {x2 y2} $v2 break
    return [expr {$x1*$x2 + $y1*$y2}]
}
proc ::Data::VDistance {p1 p2} {
    foreach {p1x p1y} $p1 {p2x p2y} $p2 break
    return [expr {hypot($p1x-$p2x, $p1y-$p2y)}]
}
##+##########################################################################
#
# ::Data::VAngle -- clockwise rotation from V1 to V2
#
proc ::Data::VAngle {V1 V2} {
    set V1 [::Data::VReScale $V1 1]
    set V2 [::Data::VReScale $V2 1]
    set dot [::Data::VDot $V1 $V2]
    set cross [::Data::VCross $V1 $V2]
    set angle [expr {acos($dot) * 180 / acos(-1)}]
    if {$cross < 0} { set angle [expr {-$angle}] }
    return $angle
}
proc ::Data::VCross {A B} {
    foreach {a1 a2} $A {b1 b2} $B break
    return [expr {$a1*$b2 - $a2*$b1}]
}
##+##########################################################################
#
# ::Data::Intersect -- find two line intersection given two points on each line
#
proc ::Data::Intersect {p1 p2 p3 p4} {
    return [::Data::IntersectV $p1 [VSub $p2 $p1] $p3 [VSub $p4 $p3]]
}
##+##########################################################################
#
# ::Data::IntersectV -- find where 2 point/vector intersect
#
# p1+K(v1) = p3+J(v3)
# convert into and solve matrix equation (a b / c d) ( K / J) = ( e / f )
#
proc ::Data::IntersectV {p1 v1 p3 v3} {
    foreach {x1 y1} $p1 {vx1 vy1} $v1 {x3 y3} $p3 {vx3 vy3} $v3 break

    set a $vx1
    set b [expr {-1 * $vx3}]
    set c $vy1
    set d [expr {-1 * $vy3}]
    set e [expr {$x3 - $x1}]
    set f [expr {$y3 - $y1}]

    set det [expr {double($a*$d - $b*$c)}]
    if {$det == 0} {error "Determinant is 0"}

    set k [expr {($d*$e - $b*$f) / $det}]
    #set j [expr {($a*$f - $c*$e) / $det}]
    return [::Data::VAdd $p1 $v1 $k]
}
proc ::Data::Smooth {data {n 2}} {
    # http://www.numberwatch.co.uk/smoothing_of_data.htm
    # Y(k) = Y(k-1) + (data(k) - data(k-n))/n

    set sum 0
    set data2 {}
    for {set k 0; set k0 -1} {$k < [llength $data]} {incr k; incr k0} {
	set xk [lindex $data $k]
	set x0 [lindex $data [expr {$k-$n}]]
	if {$x0 eq ""} { set x0 0}

	set sum [expr {$sum + $xk - $x0}]
	set nn [expr {($k+1) < $n ? ($k+1) : $n}] ;# First N points have problem
	set this [expr {$sum / double($nn)}]
	lappend data2 $this
    }
    return $data2
}
##+##########################################################################
#
# ::Data::GetLabelText -- gets text to be shown for a given node
# in profile graph and route description.
# 1. use node text if NOT an intersection (has " & ")
# 2. rname in != rname out => rname out
# 3. use 1/2 of node text if we can determine the intersecting road
# 4. use out-going road's name
#
proc ::Data::GetLabelText {nid rid0 rid1} {
    global roads nodes

    set nname [lindex $nodes($nid) 0]
    set nlist {}
    foreach rname [split [string map {" & " "\x01"} $nname] "\x01"] {
	lappend nlist [::Data::CleanRoadname $rname]
    }
    # 1. use node text if NOT an intersection (has " & ")
    if {[llength $nlist] != 2 || $rid0 eq "" || $rid1 eq ""} {return $nname}

    set rname0 [string tolower [::Data::CleanRoadname [lindex $roads($rid0) 6]]]
    set rname1 [::Data::CleanRoadname [lindex $roads($rid1) 6]]

    # 2. rname in != rname out => rname out
    if {[string tolower $rname1] ne $rname0} { return $rname1 }

    set n [lsearch [string tolower $nlist] $rname0]
    if {$n != -1} {
	# 3. use 1/2 of node text if we can determine the intersecting road
	return [lindex $nlist [expr {$n == 0 ? 1 : 0}]]
    }

    # 4. use out-going road's name
    return $rname1
}
##+##########################################################################
#
# ::Data::CleanRoadname -- removes parentheses from roads names
#
proc ::Data::CleanRoadname {rname} {
    regsub -all {\s*\(.*\)\s*} $rname {} rname
    return [string trim $rname]
}
##+##########################################################################
#
# ::Data::AddZ2XY -- creates either an XY or XYZ list for use for AddRoad2
#  to be used by ::Data::ProcessOneRoad
#
proc ::Data::AddZ2XY {xy z} {
    if {$z eq {}} { return [concat "xy" $xy] }
    if {6*[llength $z] != [llength $xy]} { error "Mismatch in xy and z" }
    set result "xyz"
    foreach {a b c d e f} $xy zz $z {
	lappend result $a $b $c $d $e $f $zz
    }
    return $result
}
##+##########################################################################
#
# ::Data::WordWrap -- wraps text to certain line length
#
proc ::Data::WordWrap {txt {len 25}} {

    regsub -all {\s+} $txt " " txt
    set result ""
    set line ""
    foreach word [split [string trim $txt] " "] {
	if {$line eq ""} { set line2 $word } else {set line2 "$line $word"}
	if {[string length $line2] > $len} {
	    append result "$line\n"
	    set line2 $word
	}
	set line $line2
    }
    append result $line
    set result [string trim $result]
    return $result
}
proc ::Data::NBSP {txt} {
    return [string map {" " \x01} $txt]
}
proc ::Data::NoNBSP {txt} {
    return [string map {\x01 " "} $txt]
}
proc ::Data::GetTempFile {ext} {
    set tempDir [pwd]
    if {[file isdirectory "c:/temp"]} { set tempDir "c:/temp"}
    if {[file isdirectory "/tmp"]} { set tempDir "/tmp"}
    catch {set tempDir $::env(TRASH_FOLDER)}	;# Macintosh(?)
    catch {set tempDir $::env(TMPDIR)}
    catch {set tempDir $::env(TMP)}
    catch {set tempDir $::env(TEMP)}

    set ext [string trimleft $ext "."]
    set fname "KLIMB_temp.[clock seconds].$ext"
    set cnt 0
    while {1} {
	set fpath [file join $tempDir $fname]
	if {! [file exists $fpath]} break
	set fname "KLIMB_temp.[clock seconds].[incr cnt].$ext"
    }
    return $fpath
}
##+##########################################################################
#
# ::Data::VCompare -- compares 2 versions numbers which have the
# format #.## or #.##B# or #.##K#. Returns v1 <==> v2
#
proc ::Data::VCompare {v1 v2} {
    set n [scan $v1 %f vv1]
    if {! $n} { return -1 }
    set n [scan $v2 %f vv2]
    if {! $n} { return 1 }

    set n [expr {$vv1 - $vv2}]
    if {$n < 0} { return -1 }
    if {$n > 0} { return 1 }
    return 0
}
##+##########################################################################
#
# ::Data::PixelAway -- returns point on a road which is dist away from
#
proc ::Data::PixelAway {x0 y0 xy dist} {
    set xx $x0
    set yy $y0
    set tooFar 0
    foreach {x y} $xy {
	set d [expr {round(hypot($x-$x0, $y-$y0))}]
	if {$d == $dist} { return [list $x $y] }
	if {$d > $dist} {
	    set tooFar 1
	    break
	}
	set xx $x
	set yy $y
    }

    if {! $tooFar} { return ""}

    # (x,y) is too far away & (xx,yy) is too close
    # Binary search to find point on vector correct distance away

    set probe 0
    set V [::Data::VSub [list $x $y] [list $xx $yy]]
    for {set i 0;set offset .5} {$i<5} {incr i;set offset [expr {$offset/2}]} {
	set P [::Data::VAdd [list $xx $yy] $V [expr {$probe + $offset}]]
	foreach {Px Py} $P break
	set d [expr {hypot($Px-$x0, $Py-$y0)}]
	if {$d < $dist} { set probe [expr {$probe + $offset}] }
    }
    return $P

    # Direct math calculation -- didn't work
    set B [::Data::VSub [list $xx $yy] [list $x0 $y0]]
    set V [::Data::VSub [list $x $y] [list $xx $yy]]
    foreach {Bx By} $B {Vx Vy} $V break
    set a [expr {$Vx*$Vx + $Vy*$Vy}]
    set b [expr {2*$Vx + 2*$Vy}]
    set c [expr {$Bx*$Bx + $By*$By - $dist*$dist}]

    set det [expr {$b*$b - 4*$a*$c}]
    if {$det < 0} {return "bad determinant"}
    set pos [expr {(-$b + sqrt($det)) / 2 / $a}]
    set neg [expr {(-$b - sqrt($det)) / 2 / $a}]
}
##+##########################################################################
#
# ::Data::GetAngle -- returns clockwise angle a line makes with the x axis
# BUT in 90-450 range
#
proc ::Data::GetAngle {p0 p1} {
    foreach {x0 y0} $p0 {x1 y1} $p1 break
    set dx [expr {$x1 - $x0}]
    set dy [expr {$y1 - $y0}]
    set a [expr {atan2($dy,$dx)*180/acos(-1)}]
    while {$a <= 90} { set a [expr {$a + 360}] }
    return $a
}
##+##########################################################################
#
# ::Data::HTMLSafe -- encodes special HTML characters
#
proc ::Data::HTMLSafe {txt} {
    set txt [string map {> &gt; < &lt; & &amp; ' &apos; \x22 &quot;} $txt]
    return $txt
}
##+##########################################################################
#
# ::Data::BboxCenter -- returns center of an items bounding box
#
proc ::Data::BboxCenter {bbox} {
    foreach {x0 y0 x1 y1} $bbox break
    set x [expr {($x0+$x1)/2}]
    set y [expr {($y0+$y1)/2}]
    return [list $x $y]
}
##+##########################################################################
#
# ::Data::GetBackupName -- returns backup file name
#
proc ::Data::GetBackupName {fname} {
    append fname ".bak"
    if {! [file exists $fname]} { return $fname }

    for {set i 0} {$i < 999} {incr i} {
	set bname [format "%s.%03d" $fname $i]
	if {! [file exists $bname]} break
    }
    return $bname
}
##+##########################################################################
#
# ::Data::CleanUserData -- Fixes up data: commas and leading zeroes
#
proc ::Data::CleanUserData {str} {
    regsub -all {,} $str {} val			;# First remove commas
    if {$val eq ""} { return $str }
    # NB. in 8.4 "08" passed is double test, not so in 8.5
    set val [string trimleft $val "0"]
    if {$val eq ""} { return 0 }

    if {[string is double -strict $val]} { return $val }
    return $str					;# Not a number
}
##+##########################################################################
#
# ::Data::BackupFile -- Makes a backup of a given file
#
proc ::Data::BackupFile {fname} {
    if {! [file exists $fname]} return

    for {set i 0} {$i < 1000} {incr i} {
	set backupName [format %s.%03d $fname $i]
	if {! [file exists $backupName]} break
    }
    if {[file type $fname] eq "link"} {
	set fin [open $fname r]
	set fout [open $backupName w]
	fcopy $fin $fout
	close $fout
	close $fin
    } else {
	file copy -force -- $fname $backupName
    }
    return $backupName
}

##+##########################################################################
#
# ::Data::PreCalcClimb -- takes list of elevations and computes smoothed
# out climbing.
#
proc ::Data::PreCalcClimb {z} {
    # First convert absolute altitudes into delta
    set dz1 {}
    set last [lindex $z 0]
    foreach alt [lrange $z 1 end] {
	set d [expr {$alt - $last}]
	if {$d != 0} {
	    lappend dz1 $d
	}
	set last $alt
    }

    # Next, combine consecutive climbs or descends into one item
    set dz2 {}
    lappend dz1 0
    set last 0
    foreach delta $dz1 {
	if {($delta < 0 && $last < 0) || ($delta > 0 && $last > 0)} {
	    set last [expr {$last + $delta}]
	} else {
	    lappend dz2 $last
	    set last $delta
	}
    }
    set dz2 [lrange $dz2 1 end]
    if {[llength $dz2] == 0} { set dz2 0 }
    return [CalcClimb $dz2]
}
##+##########################################################################
#
# CalcClimb -- given a list of alternating climb and descents this
# removes all small bumps less than a certain threshold. The code
# is by Dan Connelly.
#
# First examine triplets: if middle less than LIMIT and less than the
# other two then we combine the three into 1. Second, if the first two
# items are less than LIMIT then combine them, with two special cases
# of the new item equally 0 or being the same sign as the next item.
# Third, repeat second step for the end of the list.

proc CalcClimb {dz} {
    set LIMIT 30

    # Examine triplets, combining middle if necessary
    for {set n 2} {$n < [llength $dz]} {} {
	set n2 [expr {$n - 2}]
	foreach {dz0 dz1 dz2} [lrange $dz $n2 $n] break
	set adz1 [expr {abs($dz1)}]
	if {$adz1 < $LIMIT && $adz1 <= abs($dz0) && $adz1 <= abs($dz2)} {
	    set dznew [expr {$dz0 + $dz1 + $dz2}]
	    set dz [lreplace $dz $n2 $n $dznew]
	    set n [expr {$n2 < 2 ? 2 : $n2}]
	} else {
	    incr n
	}
    }

    # Handle cancellations at the head of list
    # test cases: {10 -20 30 -40}   {20 -10 30 -40}  {10 -10 30 -40}
    while {[llength $dz] > 1} {
	foreach {dz0 dz1 dz2} $dz break
	if {abs($dz0) >= $LIMIT || abs($dz1) >= $LIMIT} break
	set dznew [expr {$dz0 + $dz1}]
	if {$dznew == 0} {
	    set dz [lrange $dz 2 end]
	} else {
	    set n 1
	    if {$dz2 ne {} \
		    && ($dznew < 0 && $dz2 < 0) || ($dznew > 0 && $dz2 > 0)} {
		set dznew [expr {$dznew + $dz2}]
		incr n
	    }
	    set dz [lreplace $dz 0 $n $dznew]
	}
    }

    # Handle cancellations at the tail of list
    # test cases: {-40 30 -20 10}   {-40 30 -10 20}   {-40 30 -10 10}
    while {[llength $dz] > 1} {
	foreach {dz1 dz0} [lrange $dz end-1 end] break
	if {abs($dz0) >= $LIMIT || abs($dz1) >= $LIMIT} break
	set dznew [expr {$dz0 + $dz1}]
	if {$dznew == 0} {
	    set dz [lrange $dz 0 end-2]
	} else {
	    set n 1
	    set dz2 [lindex $dz end-2]
	    if {$dz2 ne {} \
		    && ($dznew < 0 && $dz2 < 0) || ($dznew > 0 && $dz2 > 0)} {
		set dznew [expr {$dznew + $dz2}]
		incr n
	    }
	    set dz [lreplace $dz end-$n end $dznew]
	}
    }
    #if {[llength $dz] > 1 && abs([lindex $dz 0]) < $LIMIT} { set dz [lrange $dz 1 end] }
    #if {[llength $dz] > 1 && abs([lindex $dz end]) < $LIMIT} { set dz [lrange $dz 0 end-1] }

    set climb 0
    set desc 0
    foreach dz0 $dz {
	if {$dz0 < 0} { set desc [expr {$desc - $dz0}]}
	if {$dz0 > 0} { set climb [expr {$climb + $dz0}]}
    }

    return [list $climb $desc $dz]
}
##+##########################################################################
#
# AvocetHysteresis -- smooths altitude data w/ Avocets hysteresis
# algorithm of ignoring changes under 30 feet.
#
# Returns: total climbing to each point
#
proc AvocetHysteresis {z} {
    set LIMIT 30
    set tClimb 0
    set low [lindex $z 0]
    set high $low
    set thisElev $low
    set lastElev -

    set soFar {}
    set avState "DESCENDING"
    for {set i 1} {$i < [llength $z]} {incr i} {
	lappend soFar $tClimb
	set lastElev $thisElev
	set thisElev [lindex $z $i]
	if {! [string is integer -strict $thisElev]} {
	    set thisElev $lastElev
	}
	set delta [expr {$thisElev - $lastElev}]

	if {$avState eq "DESCENDING"} {
	    if {$delta > 0} {
		set rise [expr {$thisElev - $low}]
		if {$rise > $LIMIT} {
		    set avState "CLIMBING"
		    set tClimb [expr {$tClimb + $rise}]
		    set high $thisElev
		    set low $thisElev
		}
	    } elseif {$delta <= 0} {
		set low [expr {min($low, $thisElev)}]
	    }
	} elseif {$avState eq "CLIMBING"} {
	    if {$delta >= 0} {
		set high $thisElev
		set low $thisElev
		set tClimb [expr {$tClimb + $delta}]
	    } elseif {$delta < 0} {
		set avState "DIPPING"
	    }
	}
	if {$avState eq "DIPPING"} {
	    if {$delta > 0} {
		if {$thisElev >= $high} {
		    set avState "CLIMBING"
		    set rise [expr {$thisElev - $high}]
		    set tClimb [expr {$tClimb + $rise}]
		    set high $thisElev
		    set low $thisElev
		}
	    } elseif {$delta <= 0} {
		set low [expr {min($low, $thisElev)}]
		set dip [expr {$high - $low}]
		if {$dip >= $LIMIT} {
		    set avState "DESCENDING"
		    set high $thisElev
		}
	    }
	}
    }
    lappend soFar $tClimb
    return $soFar
}
##+##########################################################################
#
# ::Data::Halfway -- Returns lat/lon of a road's halfway point
#
proc ::Data::Halfway {rid} {
    foreach {id1 id2 . dist . . . . xy} $::roads($rid) break
    foreach {. . lat lon} $::nodes($id2) break
    set xy [concat $xy $lat 0 0 $lon 0 0]

    foreach {. . lat1 lon1} $::nodes($id1) break
    set dist [::BadMath::MakeGood $dist]
    set half [expr {$dist/2.0}]
    set soFar 0
    foreach {la1 la2 la3 lo1 lo2 lo3} $xy {
	set lat0 $lat1
	set lon0 $lon1
	set lat1 [lat2int $la1 $la2 $la3]
	set lon1 [lat2int $lo1 $lo2 $lo3]

	set leg [Data::Distance $lat0 $lon0 $lat1 $lon1]
	if {$soFar + $leg < $half} {
	    set soFar [expr {$soFar + $leg}]
	    continue
	}

	# This leg takes us past the half-way point, interpolate how far
	set k [expr {($half - $soFar) / $leg}]
	set lat [expr {($lat1 - $lat0) * $k + $lat0}]
	set lon [expr {($lon1 - $lon0) * $k + $lon0}]
	return [list $lat $lon]
    }
}
##+##########################################################################
#
# ::Data::Plural -- Returns proper noun form
#
proc ::Data::Plural {cnt singular plural} {
    return [expr {$cnt == 1 ? $singular : $plural}]
}
proc ::Data::ReadAllText {fname} {
    if {! [file exists $fname]} { return "" }

    set fin [open $fname r]
    set data [read $fin]; list
    close $fin
    return $data
}
proc ::Data::WriteAllText {fname txt {append 0} {backup 0}} {
    if {$backup eq "backup"} {
	set bfile [::Data::GetBackupName $fname]
	file copy $fname $bfile
    }
    set how [expr {$append ? "a" : "w"}]
    set fout [open $fname $how]
    puts -nonewline $fout $txt
    close $fout
}
##+##########################################################################
#
# ::Data::Bearing -- Returns N,NE,E,SE,S,SW,W,NW depending on direction
# of lat0/lon0 to lat1/lon1
#
proc ::Data::Bearing {lat0 lon0 lat1 lon1} {
    foreach {x0 y0} [::Display::pos2canvas root $lat0 $lon0] break
    foreach {x1 y1} [::Display::pos2canvas root $lat1 $lon1] break

    set dx [expr {$x1 - $x0}]
    set dy [expr {$y1 - $y0}]
    set rad [expr {atan2(-$dy, $dx)}]
    set deg [expr {$rad * 180 / acos(-1)}]
    # Deg: 180 -> -179
    if {$dx == 0 && $dy == 0} {			;# Special case
	set bearing "-"
    } elseif {$deg > 135+45/2.} {
	set bearing W
    } elseif {$deg > 90+45/2.} {
	set bearing NW
    } elseif {$deg > 90-45/2.} {
	set bearing N
    } elseif {$deg > 45/2.} {
	set bearing NE
    } elseif {$deg > -45/2.} {
	set bearing E
    } elseif {$deg > -45-45/2.} {
	set bearing SE
    } elseif {$deg > -90-45/2.} {
	set bearing S
    } elseif {$deg > -135-45/2.} {
	set bearing SW
    } else {
	set bearing W
    }

    return $bearing
}
##+##########################################################################
#
# ::Data::UniqueTrace -- Makes sure varName doesn't have multiple traces
#
proc ::Data::UniqueTrace {varName {function ""}} {
    foreach tr [trace info variable $varName] {
	eval trace remove variable $varName $tr
    }
    if {$function ne ""} {
	trace variable $varName w $function
    }
}
##+##########################################################################
#
# ::Data::NodeInPath -- Checks if a node is on a given start node, roads path
#
proc ::Data::NodeInPath {nid path} {
    if {$nid eq [lindex $path 0]} { return 1}
    foreach rid [lrange $path 1 end] {
	foreach {id1 id2} $::roads($rid) break
	if {$id1 eq $nid || $id2 eq $nid} { return 1 }
    }
    return 0
}
##+##########################################################################
#
# ::Data::NearestNode -- Finds node nearest a given point
#
proc ::Data::NearestNode {lat0 lon0} {
    global nodes

    set dist [expr {5280*100}]
    set nearest ""
    foreach nid [array names nodes] {
	lassign $nodes($nid) . . lat lon
	set feet [::Data::Distance $lat0 $lon0 $lat $lon 1]
	if {$feet < $dist} {
	    set dist $feet
	    set nearest $nid
	}
    }
    return [list $nearest $dist]
}
##+##########################################################################
#
# ::Data::MergeUserNodes -- Non-public routine to merge user.nodes back
# into klimb.nodes
#
proc ::Data::MergeUserNodes {args} {
    if {$args eq ""} {
	set nfiles $::region($::state(region),nodes)
	if {[llength $nfiles] != 1} { WARN "too many master node files"; return }
	set kname [::Init::LocateZoneFile [lindex $nfiles 0] 1 0]
	set uname [::Init::LocateZoneFile $::Save::fileName 1 0]
    } elseif {[llength $args] == 2} {
	lassign $args kname uname
    } else {
	WARN "usage: MergeUserNodes ?kname uname?"
	return
    }
    puts "merging $kname with $uname"
    if {! [file exists $uname]} {
	WARN "user node file doesn't exists"
	return
    }

    set klines [split [::Data::ReadAllText $kname] \n]
    set udata [::Data::ReadAllText $uname]
    set ulines [split $udata \n]

    set splitRoads {}
    foreach {. rid} [regexp -all -inline -line {^S (r\d+)} $udata] {
	lappend splitRoads "R $rid"
    }

    set kline [set uline {}]
    set klast "S"
    set result {}
    while {1} {
	# If kline is empty, get next line from klimb.nodes
	if {$kline eq ""} {
	    if {$klines eq {}} break
	    set klines [lassign $klines kline]
	    set kline [string trim $kline]
	    if {$kline eq "" || [string match "#*" $kline]} {
		lappend result $kline
		set kline ""
	    }
	    set kkey [string range $kline 0 [string first " " $kline 2]-1]
	    if {$kkey in $splitRoads} {
		lappend result "#M $kline"
		set kline ""
	    }
	    if {[string index $kline 0] eq "R" && $klast eq "S"} {
		puts "into R"
		set klast "R"
	    }

	    continue
	}

	# If uline is empty, get next line from user.nodes
	if {$uline eq ""} {
	    if {$ulines eq {}} break
	    set ulines [lassign $ulines uline]
	    set uline [string trim $uline]
	    if {$uline eq "" || [string match "#*" $uline] || [string match "S*" $uline]} {
		set uline ""
	    }
	    set ukey [string range $uline 0 [string first " " $uline 2]-1]
	    if {$ukey in $splitRoads} {
		set uline ""
	    }
	    continue
	}

	# Merge lines from klimb.nodes and user.nodes
	if {$kkey eq $ukey} {
	    lappend result "#M $kline"
	    lappend result $uline
	    set kline [set uline ""]
	} else {
	    # Use dictionary compare for "R r555" < "R r1234"
	    set less [lindex [lsort -dictionary [list $kkey $ukey]] 0]
	    if {$kkey eq $less} {
		lappend result $kline
		set kline ""
	    } else {
		lappend result $uline
		set uline ""
	    }
	}
    }

    # Done with one of the nodes files, just glomb the rest on
    if {$kline ne ""} { lappend result $kline }
    if {$uline ne ""} { lappend result $uline }
    lappend result {*}$klines
    lappend result {*}$ulines

    # Do some smart backing up
    set k2 [::Data::BackupFile $kname]
    ::Data::WriteAllText $kname [join $result \n]
    set u2 [::Data::BackupFile $uname]
    ::Data::WriteAllText $uname ""
    puts "$uname -> $u2"
    puts "$kname -> $k2"
}

## EON DATA
## BON SANITY
##+##########################################################################
#
# ::Sanity::Dialog -- posts the data sanity check window
#
proc ::Sanity::Dialog {} {
    variable W
    variable S

    if {[winfo exists $W]} return

    set WB $W.body
    set WBC $WB.c
    set WBTN $W.buttons
    set wtitle "$::state(progname) Data Sanity Check"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::sanity sanity.gif]
    wm protocol $W WM_DELETE_WINDOW ::Sanity::_TearDown
    bind $W <Control-w> ::Sanity::_TearDown


    ::ttk::button $WBTN.cancel -text Dismiss -command ::Sanity::_TearDown
    ::Display::GridChildren $WBTN 0

    ::Sanity::_Notebook $WB

    ::Display::RightWindow $W
    wm deiconify $W
    wm resizable $W 1 1
}
##+##########################################################################
#
# ::Sanity::_TearDown -- cleans up after the sanity dialog
#
proc ::Sanity::_TearDown {} {
    ::Balloon::ClearText sanity *
    destroy $::Sanity::W
}
##+##########################################################################
#
# ::Sanity::_Notebook -- Creates a tabbed notebook widget
#
proc ::Sanity::_Notebook {W} {
    variable WNB
    variable S

    set WNB $W.nb
    ::Display::MakeImage ::img::info info.gif

    ::ttk::notebook $WNB
    ::ttk::notebook::enableTraversal $WNB
    bind $WNB <<NotebookTabChanged>> ::Sanity::_TabChange

    ::ttk::frame $WNB.node
    $WNB add $WNB.node -text "Node Elevation"
    ::Sanity::_TabWindow $WNB.node node

    ::ttk::frame $WNB.road
    $WNB add $WNB.road -text "Road Climbing"
    ::Sanity::_TabWindow $WNB.road road

    ::ttk::frame $WNB.droad
    $WNB add $WNB.droad -text "Road Distance"
    ::Sanity::_TabWindow $WNB.droad droad

    pack $WNB -side top  -fill both -expand 1

    set tab [expr {$S(what) eq "node" ? 0 : $S(what) eq "road" ? 1 : 2}]
    $WNB select $tab
}
##+##########################################################################
#
# ::Sanity::_TabWindow -- Creates each of our sanity check window inside a tab
#
proc ::Sanity::_TabWindow {W what} {
    variable WW
    variable S

    set What [string totitle $what]
    set F $W.f
    set SB $F.sb
    set T $F.t
    set EBTN $W.buttons

    set WW(T,$what) $T

    eval destroy [winfo child $W]
    ::my::frame $F -borderwidth 2 -relief sunken
    ::my::frame $EBTN
    ::ttk::scrollbar $SB -orient vertical -command [list $T yview]
    text ${T}2 -height 1 -bd 1 -relief ridge
    #::Display::TileBGFix ${T}2
    text $T -yscroll [list $SB set] -wrap none -cursor arrow -spacing1 1 -bd 0
    #::Display::TileBGFix $T
    $T config -font {Helvetica 8}
    bind $T <Double-Button-1> break

    set ts [::Sanity::_GetTabs $what]
    $T config -tabs $ts
    ${T}2 config -tabs $ts

    set thisBoldFont [::Display::Embolden $T]
    ${T}2 tag configure HEADER -font boldFont
    $T tag configure ERROR -font $thisBoldFont -foreground red
    $T tag configure LINE0 -background $::Sanity::bgColor

    ::my::frame $EBTN.who
    ::my::label $EBTN.who.lbl -text "Which ${What}s" -font boldFont
    ::ttk::radiobutton $EBTN.who.this -text "This Region" -value this \
	-variable ::Sanity::S(who,$what) -command ::Sanity::_Fill$What
    ::ttk::radiobutton $EBTN.who.all -text "All Regions" -value all \
	-variable ::Sanity::S(who,$what) -command ::Sanity::_Fill$What
    pack $EBTN.who.lbl -side top
    if {$what eq "droad"} {
	$EBTN.who.lbl config -text "Which Roads"
	::ttk::checkbutton $EBTN.who.skip -variable ::Sanity::S(skip,$what) \
	    -text "Skip unbent roads"
    }
    eval pack [winfo child $EBTN.who] -side top -anchor w -padx 10

    ::my::frame $EBTN.filter
    ::my::label $EBTN.filter.lbl -text "Error Filter" -font boldFont
    set values [::Sanity::_GetFilter $what]
    ::ttk::combobox $EBTN.filter.cb -values $values -width 8 -takefocus 0 \
	-state readonly -textvariable ::Sanity::S(err,$what) \
	;# -selectbackground white
    ::Data::UniqueTrace ::Sanity::S(err,$what) ::Sanity::_Tracer
    ::Data::UniqueTrace ::Sanity::S(skip,droad) ::Sanity::_Tracer

    pack $EBTN.filter.lbl -side top
    pack $EBTN.filter.cb -side top -fill x -padx 10

    if {$what eq "node"} {
	::ttk::button $EBTN.all -text "USGS All" -command ::Sanity::_DoAll
    }

    ::Display::GridChildren $EBTN
    catch {grid config $EBTN.all -sticky {}}

    pack $F -side top  -fill both -expand 1
    pack $EBTN -side top -fill x
    pack $SB -side right -fill y
    pack ${T}2 -side top -fill x
    pack $T -side left -fill both -expand 1

    ::Sanity::_Fill$What
}
##+##########################################################################
#
# ::Sanity::_TabChange -- Called when user selects a different tab
#
proc ::Sanity::_TabChange {} {
    variable WNB
    variable S

    set idx [$WNB index current]
    array set whats {0 node 1 road 2 droad}
    set S(what) $whats($idx)
    set S(What) [string totitle $S(what)]
}
##+##########################################################################
#
# ::Sanity::_Tracer -- Called when user changes filter or who
#
proc ::Sanity::_Tracer {var1 var2 op} {
    variable W
    variable S

    if {! [winfo exists $W]} return
    if {$var2 eq "err,$S(what)"} {
	set num 0
	scan $S(err,$S(what)) %f num
	set S(value,$S(what)) [::Data::RConvert $num climb]
	::Sanity::_Fill$S(What)
    } elseif {$var2 eq "skip,droad"} {
	::Sanity::_Fill$S(What)
    }
}
##+##########################################################################
#
# ::Sanity::_FillNode -- Fills in the Node Elevation tab
#
proc ::Sanity::_FillNode {} {
    global bad
    variable WW
    variable S

    set T $WW(T,node)
    $T config -state normal
    $T delete 1.0 end
    ${T}2 config -state normal

    ${T}2 delete 1.0 end
    ${T}2 insert end "\tID\tName\tElevation\tUSGS\tError\n" HEADER
    ${T}2 config -state disabled

    if {$S(who,$S(what)) eq "all"} {
	set who [lsort -dictionary [array names ::nodes]]
    } else {
	set who [lsort -dictionary $::region(node,visible)]
    }
    unset -nocomplain bad
    set bad(nodes) {}
    set cnt 1
    foreach nid $who {
	foreach {name elev . . . usgs} $::nodes($nid) break
	set validUSGS [string is double -strict $usgs]

	set err ""
	if {! [::BadMath::IsBad $elev] && $validUSGS} {
	    set err [expr {$elev - $usgs}]
	}
	if {$err ne "" && abs($err) < $S(value,$S(what))} continue

	incr cnt
	set pnid [::Edit::PrettyNode $nid]
	lappend bad(nodes) $nid

	$T image create insert -image ::img::info -padx 5
	$T tag add I$nid insert-1c
	$T tag bind I$nid <Button-1> [list ::Sanity::_Info node $nid]

	$T insert insert \t$pnid\t$name\t[::Data::Units $elev climb 1 2]\t
	set idx [$T index insert]
	if {! $validUSGS} {
	    ::ttk::button $T.b$cnt -image ::img::star2 \
		-command [list ::Sanity::_DoElev $nid $idx]
	    $T window create insert -window $T.b$cnt
	    ::Balloon::Create $T.b$cnt sanity b$cnt "Query USGS for elevation" ""
	} else {
	    ::Sanity::_EnterUSGS $idx $usgs $err
	}
	$T insert insert \n
	if {! ($cnt & 1)} {
	    $T tag add LINE0 "$idx linestart" "$idx lineend +1c"
	}
    }
    if {$cnt == 1} {				;# Nothing matched
	$T insert end "\n\tno matches"
    }
    $T config -state disabled
}
##+##########################################################################
#
# ::Sanity::_FillRoad -- Fills in the Road Climbing tab
#
proc ::Sanity::_FillRoad {} {
    variable WW
    variable S

    set T $WW(T,road)
    $T config -state normal
    $T delete 1.0 end
    ${T}2 config -state normal
    ${T}2 delete 1.0 end
    ${T}2 insert end "\tID\tName\tID1\tID2\tClimb\tDesc\tGot\tError\n" HEADER
    ${T}2 config -state disabled

    if {$S(who,$S(what)) eq "all"} {
	set who [lsort -dictionary [array names ::roads]]
    } else {
	set who [lsort -dictionary $::region(road,visible)]
    }
    set cnt 1
    foreach rid $who {
	foreach {. name start end climb desc got err} \
	    [::Sanity::CheckRoadClimb $rid] break
	regsub {\s*\(.*\)\s*} $name {} name
	set climb [::Data::Units $climb climb 1]
	set desc [::Data::Units $desc climb 1]
	set got [::Data::Units $got climb 1]
	set err2 [::Data::Units $err climb 1]
	set start [::Edit::PrettyNode $start]
	set end [Edit::PrettyNode $end]

	if {$err eq "?" || abs($err) < $S(value,$S(what))} continue
	incr cnt

	$T image create end -image ::img::info -padx 5
	$T tag add I$rid end-2c
	$T tag bind I$rid <Button-1> [list ::Sanity::_Info road $rid]

	$T insert end \t$rid\t$name\t$start\t$end\t$climb\t$desc\t$got\t$err2
	set idx [$T index insert]
	$T insert end \n
	if {! ($cnt & 1)} {
	    $T tag add LINE0 "$idx linestart" "$idx lineend +1c"
	}
    }
    if {$cnt == 1} {				;# Nothing matched
	$T insert end "\n\tno matches"
    }
    $T config -state disabled
}
##+##########################################################################
#
# ::Sanity::_FillDroad -- Fills in the Road Distance tab
#
proc ::Sanity::_FillDroad {} {
    variable WW
    variable S

    set T $WW(T,droad)
    $T config -state normal
    $T delete 1.0 end
    ${T}2 config -state normal
    ${T}2 delete 1.0 end
    ${T}2 insert end "\tID\tName\tID1\tID2\tDistance\tEstimate\tError\n" HEADER
    ${T}2 config -state disabled

    if {$S(who,$S(what)) eq "all"} {
	set who [lsort -dictionary [array names ::roads]]
    } else {
	set who [lsort -dictionary $::region(road,visible)]
    }

    set cnt 1
    foreach rid $who {
	if {$S(skip,droad) && [lindex $::roads($rid) 8] eq {}} continue
	foreach {. name start end dist guess err} \
	    [::Sanity::CheckRoadDistance $rid] break
	regsub {\s*\(.*\)\s*} $name {} name
	set dist [::Data::Units $dist dist 1]
	set guess [::Data::Units $guess dist 1]
	set err2 [::Data::Units $err dist 1]
	set start [::Edit::PrettyNode $start]
	set end [Edit::PrettyNode $end]

	if {abs($err) < $S(value,$S(what))} continue
	incr cnt

	$T image create end -image ::img::info -padx 5
	$T tag add I$rid end-2c
	$T tag bind I$rid <Button-1> [list ::Sanity::_Info road $rid]

	$T insert end \t$rid\t$name\t$start\t$end\t$dist\t$guess\t$err2
	set idx [$T index insert]
	$T insert end \n
	if {! ($cnt & 1)} {
	    $T tag add LINE0 "$idx linestart" "$idx lineend +1c"
	}
    }
    if {$cnt == 1} {				;# Nothing matched
	$T insert end "\n\tno matches"
    }
    $T config -state disabled
}
##+##########################################################################
#
# ::Sanity::_Info -- Causes the node/road info dialog to get posted
#
proc ::Sanity::_Info {what id} {
    set what [string totitle $what]

    if {[::Display::Clip${what}2 $id]} {
	::Display::Locate${what} $id
    }
    ::Edit::Create${what} $id
}
##+##########################################################################
#
# ::Sanity::_DoElev -- Queries the USGS for a node elevation
#
proc ::Sanity::_DoElev {nid idx {query 0}} {
    variable WW

    set T $WW(T,node)
    foreach {. elev lat lon} $::nodes($nid) break
    set latlon [concat [int2lat $lat] [int2lat $lon]]
    set ::USGS::S(msg) "Querying node [::Edit::PrettyNode $nid]"

    if {$query} {
	set usgs [::USGS::Query "" $latlon]
    } else {
	set usgs [::USGS::Dialog [winfo toplevel $T] $latlon]
    }

    lset ::nodes($nid) 5 $usgs
    ::Data::MarkModified node $nid
    set err [::BadMath::Sub $elev $usgs]

    set end [$T index "$idx lineend"]
    $T config -state normal
    $T delete $idx $end
    ::Sanity::_EnterUSGS $idx $usgs $err
    $T config -state disabled
}
##+##########################################################################
#
# ::Sanity::_DoAll -- Gets USGS for all entries
#
proc ::Sanity::_DoAll {{dlg ""}} {
    variable WW

    set T $WW(T,node)
    if {$dlg eq ""} {
	# Post dialog box for all queries
	set dlg [::USGS::_MakeWaitDialog [winfo toplevel $T]]
	after idle ::Sanity::_DoAll $dlg
	DoGrab $dlg $dlg
	return
    }
    for {set i 2} {$i < [$T index end]} {incr i} {
	if {! [winfo exists $dlg]} break

	set idx [$T index "$i.0 lineend -1c"]
	set nid [::Sanity::_GetNID $idx]
	if {! [info exists ::nodes($nid)]} continue

	set usgs [lindex $::nodes($nid) 5]
	if {[string is double -strict $usgs]} continue

	::Sanity::_DoElev $nid $idx 1
	$T see $idx
	update
    }
    destroy $dlg
}
##+##########################################################################
#
# ::Sanity::_EnterUSGS -- Updates display with USGS elevation data
#
proc ::Sanity::_EnterUSGS {idx usgs err} {
    variable WW

    set T $WW(T,node)
    if {$err eq ""} {set err "0+?"}
    set txt [::Data::Units $usgs climb 1 2]\t[::Data::Units $err climb 1 2]
    $T insert $idx $txt
}
##+##########################################################################
#
# ::Sanity::_GetNID -- Extracts NID from text line
#
proc ::Sanity::_GetNID {idx} {
    variable WW

    set T $WW(T,node)
    set line [$T get "$idx linestart" "$idx lineend"]
    set nid [lindex [split $line "\t"] 1]
    set nid [::Edit::FindNode $nid]
    return $nid
}
##+##########################################################################
#
# ::Sanity::CheckRoadClimb -- Returns climbing data for a given road
# Returns: rid name start end climb desc expected error
#
proc ::Sanity::CheckRoadClimb {rid} {
    foreach {nid1 nid2 north . south . name} $::roads($rid) break
    set alt1 [lindex $::nodes($nid1) 1]
    set alt2 [lindex $::nodes($nid2) 1]

    set exp ?
    set err ?
    if {! [::BadMath::IsBad $alt1] && ! [::BadMath::IsBad $alt2]} {
	set exp [expr {$alt1+[::BadMath::Real $south]-[::BadMath::Real $north]}]
	set err [expr {$exp - $alt2}]
    }
    return [list $rid $name $alt1 $alt2 $south $north $exp $err]
}
##+##########################################################################
#
# ::Sanity::CheckRoadDistance -- Returns distance data for a given road
# Returns: rid name start end distance estimate error
#
proc ::Sanity::CheckRoadDistance {rid} {
    foreach {nid1 nid2 . dist . . name} $::roads($rid) break
    set guess [::Data::RoadDistance $rid 1]
    set guess [Round1 [::BadMath::Real $guess]]
    set err [Round1 [expr {$guess - [::BadMath::Real $dist]}]]
    return [list $rid $name $nid1 $nid2 $dist $guess $err]
}
##+##########################################################################
#
# ::Sanity::_GetFilter -- Returns values to be used in the filter widget
#
proc ::Sanity::_GetFilter {what} {
    if {$what eq "droad"} {
	if {$::state(units,external) eq "metric"} {
	    return {<none> ".1 km" ".2 km" ".3 km" ".4 km" ".5 km" "1 km" "2 km"}
	}
	return {<none> " .1 mile" " .2 mile" " .3 mile" " .4 mile" " .5 mile" " 1 mile"}
    }
    if {$::state(units,external) eq "metric"} {
	return {<none> "5 m" "10 m" "15 m" "20 m" "30 m" "60 m"}
    }
    return {<none> "10 ft" "15 ft" "20 ft" "30 ft" "40 ft" "50 ft" "100 ft" "200 ft"}
}
##+##########################################################################
#
# ::Sanity::_GetTabs -- Returns tabs stops to be used
#
proc ::Sanity::_GetTabs {what} {
    variable WW

    set T $WW(T,$what)
    set font [$T cget -font]
    if {$what eq "node"} {set name [string repeat "W" 27]}
    if {$what eq "road"} {set name [string repeat "W" 15]}
    if {$what eq "droad"} {set name [string repeat "W" 18]}
    if {$what eq "node"} {set num "___12,345"}
    if {$what eq "road"} {set num " 23,456,789"}
    if {$what eq "droad"} {set num " 123,456,789"}

    set idWidth [font measure $font "r9999"]
    set id2Width [font measure $font "r99999"]
    set nameWidth [font measure $font $name]
    set numWidth [font measure $font $num]

    set pos [expr {[image width ::img::info] + 10}]
    set ts $pos
    lappend ts [incr pos $idWidth]
    lappend ts [incr pos $nameWidth] right
    if {$what eq "node"} {
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
    } elseif {$what eq "road"} {
	lappend ts [incr pos $id2Width] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
    } else {
	lappend ts [incr pos $id2Width] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
	lappend ts [incr pos $numWidth] right
    }
    return $ts

    set t2 [expr {$t1 + $idWidth}]
    set t3 [expr {$t2 + [font measure $font $name]}]
    set t4 [expr {$t3 + [font measure $font $num]}]
    set t5 [expr {$t4 + [font measure $font $num]}]
    set t6 [expr {$t5 + [font measure $font $num]}]
    set t7 [expr {$t6 + [font measure $font $num]}]
    set ts [list $t1 $t2 $t3 right $t4 right $t5 right $t6 right $t7 right]
    return $ts
}
##+##########################################################################
#
# ::Sanity::WaypointRoad -- Shows all road waypoints
#
proc ::Sanity::WaypointRoad {{who ?}} {
    global roads route
    set sz 3

    if {$who eq "?"} {
	set who [expr {$route(nodes) ne {} ? "route" : "all"}]
    }
    if {$who eq "all"} {
	set who [array names roads]
    } elseif {$who eq "route"} {
	set who $route(roads)
    } elseif {! [info exists roads($who)]} {
	WARN "NOn-existent road '$rid'"
	return
    }

    .c delete debug
    foreach rid $who {
	foreach {lat1 lat2 lat3 lon1 lon2 lon3} [lindex $roads($rid) 8] {
	    set lat [lat2int $lat1 $lat2 $lat3]
	    set lon [lat2int $lon1 $lon2 $lon3]
	    set xy [::Display::pos2canvas root $lat $lon]
	    set box [::Display::MakeBox $xy $sz]
	    .c create oval $box -tag debug -fill yellow -outline black
	}
    }
}
##+##########################################################################
#
# ::Sanity::CanDoDialog -- Shows results of the cando tests
#
proc ::Sanity::CanDoDialog {} {
    set W .cando
    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Can Do Test"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::sanity sanity.gif]
    #wm protocol $W WM_DELETE_WINDOW {}

    ::ttk::button $WBTN.cancel -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    set results [::Data::DoCanDoTest]
    set rows [expr {([llength $results]+3) / 4}]
    text $WB.t -height $rows -tabs {5 140 180 315}
    set width [expr {350 / [font measure [$WB.t cget -font] "m"]}]
    $WB.t config -width $width
    $WB.t tag configure ok ;# -background green
    $WB.t tag configure No -background red
    pack $WB.t -fill both -expand 1

    set cnt -1
    foreach {pkg n} $results {
	set val [expr {$n ? "ok" : "No"}]
	$WB.t insert end \t
	$WB.t insert end " $pkg\t$val" $val
	if {([incr cnt] % 2) == 1} { $WB.t insert end \n }
    }
    $WB.t config -state disabled

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Sanity::PageSizeTest -- Prints test page to determine page size
#
proc ::Sanity::PageSizeTest {} {
    if {! [::Data::CanDo printMaps]} {
	WARN $::Print::WhyNot
	return
    }
    set txt "This prints a page that lets you check KLIMB's estimate "
    append txt "of the printed page size."
    set txt [WRAPUNIX [::Data::WordWrap $txt 50]]
    set ok [tk_messageBox -message $txt -type okcancel \
		-title "KLIMB Printer Page Size"]
    if {$ok ne "ok"} return

    foreach {hdc status} [printer dialog select] break
    if {! $status} return

    printer job start -name "KLIMB Page Size Test"
    printer page start

    foreach {pw ph ppiH} [::Print::GuessPageSize] break
    set w2 [expr {$pw/2}]

    set y [expr {2*$ppiH}]
    set txt "KLIMB Page Size Test"
    set n [gdi text $hdc $w2 $y -anchor n -text $txt -font {Arial 48 bold}]
    incr y $n
    set txt "Estimated size: [comma $pw]x[comma $ph]"
    set n [gdi text $hdc $w2 $y -anchor n -text $txt -font {Arial 18}]

    set x [expr {$pw/2}]
    set y [expr {$ph/2}]
    set max 15000
    gdi line $hdc 0 $y $max $y -width 5
    gdi line $hdc $x 0 $x $max -width 5

    for {set i 0} {$i <= $max} {incr i 50} {
	set dd 30
	if {($i % 100) == 0} { set dd 60 }
	if {($i % 500) == 0} { set dd 120 }
	if {($i % 1000) == 0} { set dd 180 }
	set y2 [expr {$y - $dd}]
	gdi line $hdc $i $y $i $y2 -width 1
	set x2 [expr {$x + $dd}]
	gdi line $hdc $x $i $x2 $i -width 1
	if {($i % 500) == 0} {
	    set txt [comma $i]
	    gdi text $hdc $i [expr {$y+10}] -anchor n -text $txt -font {Arial 8}
	    gdi text $hdc [expr {$x+200}] $i -anchor w -text $txt -font {Arial 8}
	}
    }

    printer page end
    printer job end
    printer close
}
##+##########################################################################
#
# ::Sanity::WebServicesDialog -- Checks all the web services we use
#
proc ::Sanity::WebServicesDialog {} {
    variable WEB

    destroy $WEB
    set WB $WEB.body
    set WBF $WB.f
    set WBTN $WEB.buttons
    set wtitle "$::state(progname) Web Services Check"
    set title $wtitle
    ::Display::MakeDialogBox $WEB $wtitle $title \
	[list ::img::sanityWeb webServices.gif]
    wm protocol $WEB WM_DELETE_WINDOW ::Sanity::_TearDownWeb

    ::ttk::button $WBTN.cancel -text Dismiss -command ::Sanity::_TearDownWeb
    ::Display::GridChildren $WBTN 0

    ::ttk::button $WB.usgs -text "Check USGS Elevation" \
	-command ::Sanity::USGS
    ::ttk::button $WB.terra -text "Check Terraserver" \
	-command ::Sanity::Terraserver
    ::ttk::button $WB.noaa -text "Check NOAA Weather" \
	-command ::Sanity::Weather

    frame $WBF -width 200 -height 230 -bg white -bd 2 -relief ridge
    pack propagate $WBF 0
    pack $WBF -side right -fill both -expand 1 -padx {10 0}
    pack $WB.usgs -side top -fill x
    pack $WB.terra -side top -fill x -pady 10
    pack $WB.noaa -side top -fill x
    ::Sanity::WebWarn "Check web services\nKLIMB utilizes"

    ::Display::CenterWindow $WEB .
    wm resizable $WEB 1 1
    wm deiconify $WEB
}
##+##########################################################################
#
# ::Sanity::_TearDownWeb -- cleans up after the sanity Web dialog
#
proc ::Sanity::_TearDownWeb {} {
    catch {image delete ::img::sanityTerra}
    destroy $::Sanity::WEB
}

##+##########################################################################
#
# ::Sanity::WebWarn -- Puts up warning message for web services dialog
#
proc ::Sanity::WebWarn {txt} {
    if {! [winfo exists $::Sanity::WEB]} return
    set WBF $::Sanity::WEB.body.f

    destroy [winfo child $WBF]
    label $WBF.msg -text $txt -background white -justify left
    $WBF.msg config -font boldFont -foreground red -justify center \
	-wraplength 190
    pack $WBF.msg -expand 1
}
##+##########################################################################
#
# ::Sanity::WebMsg -- display message or image or warning for the
# web services dialog
#
proc ::Sanity::WebMsg {txt {img ""}} {
    if {! [winfo exists $::Sanity::WEB]} return
    set WBF $::Sanity::WEB.body.f

    destroy [winfo child $WBF]

    if {$img ne ""} {
	label $WBF.msg -text $txt -background white -justify left \
	    -image $img -compound bottom -font boldFont
	place $WBF.msg -x 0 -y 0
    } else {
	text $WBF.txt -width 5 -height 5 -bd 0 -wrap none
	pack $WBF.txt -fill both -expand 1
	$WBF.txt insert end $txt
    }
}
##+##########################################################################
#
# ::Sanity::USGS -- Checks the USGS web service
#
proc ::Sanity::USGS {} {
    ::Sanity::WebWarn "Checking USGS..."

    foreach {lat lon} $::Sanity::granville break
    set lon [expr {- $lon}]
    set n [catch {::USGS::GetElevation $lat $lon usgsData} emsg]
    if {$n} {
	::Sanity::WebWarn "USGS ERROR:\n$emsg"
	return
    }
    array set M $usgsData
    set result "SUCCESS"
    set n [regexp {<Elevation>(.*?)</Elevation>} $M(xml) => elev]
    if {! $n} {
	set result "FAILURE: Bad XML reply"
    } elseif {abs($elev-960) > 10} { ;# was 961.397826828045, 3/2010 became
	set result "FAILURE: Bad elevation returned: $elev"
    }
    ::Sanity::WebMsg "$result\n\n$M(xml)"
}
##+##########################################################################
#
# ::Sanity::Terraserver -- Checks the terraserver web service
#
proc ::Sanity::Terraserver {} {
    set utm [eval ::Data::ll2utm $::Sanity::granville]
    foreach {XX YY} [::Zoom::ChunkUTM $utm 11] break

    ::Zoom::Init
    set ::Zoom::ZMAP(theme) "topo"
    set ::Zoom::ZMAP(zone) [lindex $utm 2]
    set url [::Zoom::GetURL $XX $YY]
    ::Sanity::WebWarn "Checking terraserver...\n$url"
    set n [catch {set token [::http::geturl $url -timeout 10000]} emsg]
    if {$n} {
	::Sanity::WebWarn "TERRASERVER ERROR:\n$emsg"
	return
    }
    if {[::http::status $token] eq "timeout"} {
	::Sanity::WebWarn "TERRASERVER ERROR: timeout"
	return
    }
    set ncode [::http::ncode $token]
    #set meta [set [set token](meta)]
    #array set M $meta
    set data [::http::data $token]
    ::http::cleanup $token
    if {$ncode != 200} {
	::Sanity::WebWarn "TERRASERVER ERROR:\nncode ($ncode) != 200"
	return
    }

    catch {image delete ::img::sanityTerra}
    set n [catch {image create photo ::img::sanityTerra -data $data} emsg]
    if {$n} {
	::Sanity::WebWarn "Terraserver image error:\n$emsg"
	return
    }
    set result [expr {[string length $data] == 14022 \
			  ? "SUCCESS" : "FAILURE"}]

    ::Sanity::WebMsg $result ::img::sanityTerra
}
##+##########################################################################
#
# ::Sanity::Weather -- Checks NOAA weather web service
#
proc ::Sanity::Weather {} {
    set emsg [::Weather::CanDo 1]
    if {$emsg ne ""} {
	::Sanity::WebWarn "NOAA Error\n$emsg"
	return
    }

    ::Sanity::WebWarn "Checking NOAA Weather..."

    foreach {lat lon} $::Sanity::granville break
    set lon [expr {- $lon}]

    set url [::Weather::GetUrl $lat $lon]
    set n [catch {set token [::URL::GetUrlFollowRedirects $url]} emsg]
    if {$n} {
	::Sanity::WebWarn "NOAA ERROR:\n$emsg"
	return
    }
    set ncode [::http::ncode $token]
    if {$ncode != 200} {
	::http::cleanup $token
	::Sanity::WebWarn "NOAA ERROR:\nncode ($ncode) != 200"
	return
    }
    #set meta [set [set token](meta)]
    #array set M $meta

    set xml [::http::data $token] ; list
    ::http::cleanup $token
    ::Sanity::WebMsg $xml
}
## EON SANITY
## BON DISPLAY
##+##########################################################################
#
# ::Display::Create
#
# Sets up our GUI.
#
proc ::Display::Create {} {
    global state

    set state(title) "$state(progname) : $state(zone) zone : "
    append state(title) "$state(region) region"
    if {[info exists ::region($state(locale),label)]} {
	append state(title) $::region($state(locale),label)
    }
    if {$state(zoomout)} {append state(title) " (zoomed out)"}

    if {[winfo exists .c]} {			 ;# Already made
	.c delete all				 ;# Then just delete everything
	.c configure -scrollregion [list 0 0 [winfo width .c] [winfo height .c]]
	wm title . $state(title)
	return
    }
    set state(bbar) $state(init,bbar)
    set state(sbar) [expr {$state(init,sbar) eq "Visible"}]
    ::Display::SetPanningGain

    INFO "creating the display..."
    destroy .c
    wm title . $state(title)
    catch {wm iconbitmap . $state(iconfile)}
    wm geometry . +2+2 ; update
    wm protocol . WM_DELETE_WINDOW ::Display::Cleanup

    ::Display::DoMenus

    # Button bar
    pack [::my::frame .fbbar] -side top -fill x
    ::my::frame .bbar -relief sunken -borderwidth 2
    ::Display::MakeBBar .bbar
    pack .bbar -side top -fill x -pady 5 -in .fbbar
    ::Display::ToggleWindow bbar

    # Embedded profile window
    ::my::frame .fprofile
    canvas .epro -bd 2 -relief ridge -background green -height 100 \
	-highlightthickness 0

    # Status window
    ::my::frame .bottom				;# For easier toggling
    ::my::frame .b
    canvas .b.msg  -bd 1 -relief sunken -height 15 -highlightthickness 0
    ::Display::TileBGFix .b.msg
    .b.msg xview moveto 0 ; .b.msg yview moveto 0
    .b.msg create text 2 0 -tag txt -anchor nw

    foreach {who width} {title 30 dist 15 climb 12 desc 12} {
	::my::label .b.$who -textvariable msg($who) -anchor c -borderwidth 1 \
	    -relief sunken -width $width
    }
    .b.title config -textvariable ::route(title)

    ::Balloon::Create .b.title static title "route title" ""
    ::Balloon::Create .b.dist static dist "total route distance"   ""
    ::Balloon::Create .b.climb  static climb  "total route climbing"   ""
    ::Balloon::Create .b.desc static desc "total route descending" ""

    # Main window
    ::my::frame .main -borderwidth 3 -relief sunken
    ::ttk::scrollbar .sb_x -command {.c xview} -orient horizontal
    ::ttk::scrollbar .sb_y -command {.c yview} -orient vertical
    ::my::frame .cf -borderwidth 2 -relief ridge
    canvas .c -width $state(cw) -height $state(ch) -highlightthickness 0 \
	-takefocus 1 -bg \#a0a0a0 -bd 0
    .c config -yscrollcommand {::Display::MyScroller y .sb_y}
    .c config -xscrollcommand {::Display::MyScroller x .sb_x}

    bind .c <2> ".c config -cursor fleur ; ::Display::TextScanMark %W %x %y"
    bind .c <B2-Motion>	[list ::Display::TextScanDrag %W %x %y]
    bind .c <ButtonRelease-2> ".c config -cursor [list [.c cget -cursor]]"
    .c bind maps <1> [bind .c <2>]
    .c bind maps <B1-Motion> [bind .c <B2-Motion>]
    .c bind maps <ButtonRelease-1> [bind .c <ButtonRelease-2>]

    ;#bind .c <2>		 [bind Text <2>]	 ;# Enable dragging w/ <2>
    ;#bind .c <2> ".c config -cursor fleur ; [bind Text <2>]"
    ;#bind .c <B2-Motion>	 [bind Text <B2-Motion>]
    ;#bind .c <ButtonRelease-2> ".c config -cursor [list [.c cget -cursor]]"
    ;#if {1} {
    ;#	.c bind maps <1> ".c config -cursor fleur ; [bind Text <2>]"
    ;#	.c bind maps <B1-Motion>	 [bind Text <B2-Motion>]
    ;#	.c bind maps <ButtonRelease-1> ".c config -cursor [list [.c cget -cursor]]"
    ;#}

    #bind .c <Control-Button-3> [list PointMe %W %x %y];# For debugging
    bind .c <Leave> [list ::Balloon::Go 0 . .]	;# Cancel balloon help
    event add <<MenuMousePress>> <Button-3>
    if {$state(macosx)} {
	event add <<MenuMousePress>> <Control-Button-1>
    }
    focus .c

    ::Display::MouseWheelBind

    # Bottom from with messages
    pack .bottom -side bottom -fill x
    pack .b -side bottom -fill x -in .bottom
    pack .b.desc .b.climb .b.dist .b.title -side right
    pack .b.msg -side left -expand 1 -fill both
    ::Display::ToggleWindow status

    #pack .fprofile -side bottom -fill x
    #pack .epro -side bottom -fill x -in .fprofile

    # Frame for the overview map
    ::my::frame .right

    # Use grid here for better looking scrollbar placement
    pack .main -side right -fill both -expand 1 -padx 3
    grid configure .cf	 -column 0 -row 0 -sticky news -in .main
    pack .c -in .cf -fill both -expand 1
    grid configure .sb_y -column 1 -row 0 -sticky ns   -in .main
    grid configure .sb_x -column 0 -row 1 -sticky ew   -in .main
    grid columnconfig .main 0 -weight 1
    grid rowconfig .main 0 -weight 1

    # Balloon help stuff
    # Create the widget to display the message.
    toplevel .balloonhelp -class balloonhelp -background black \
	-borderwidth 1 -relief flat
    ::tk::label .balloonhelp.info -bg \#ffffe1 -fg black -wraplength 3i \
	-justify left -font $state(balloon,font)

    pack .balloonhelp.info -side left -fill y
    wm overrideredirect .balloonhelp 1
    wm transient .balloonhelp .
    wm withdraw .balloonhelp

    bind all <Alt-c> DoConsole
    bind all <Alt-F2> DoConsole
    #bind .c <Control-Button-3> "::Display::BendRoad 0 %x %y ; break"
    #bind .c <Control-Button-2> [list ::Display::BendRoad 1 0 0]
    .c bind all <Control-Button-3> "::Display::BendRoad 0 %x %y ; break"
    .c bind all <Control-Button-2> [list ::Display::BendRoad 1 0 0]
}
##+##########################################################################
#
# ::Display::Cleanup -- prompts for saving before exiting
#
proc ::Display::Cleanup {} {
    if {[::Data::SaveData] ne "cancel"} {
	destroy .
	exit
    }
}
##+##########################################################################
#
# ::Display::MakeBBar -- puts up our button bar with nice sexy icons
#
proc ::Display::MakeBBar {w} {
    foreach fname {trace describe clear 3dprofile profile google undo overview
	legend nodes weather info hills milepost atlas arrow favorites} {
	set iname "::bbar::$fname"
	if {[info commands $iname] ne ""} continue ;# Already exists
	set fname2 [file join $::state(idir) buttonbar "${fname}.gif"]
	image create photo $iname -file $fname2
    }

    eval destroy [winfo child $w]
    ::ttk::button $w.clear -image ::bbar::clear -text "Clear" \
	-compound top -command ::Route::ClearRoute
    ::Balloon::Create $w.clear static clear "Clear Route" ""
    ::ttk::button $w.undo -image ::bbar::undo -text "Undo" \
	-compound top -command ::Route::UndoRoute2
    ::Balloon::Create $w.undo static undo "Undo" ""

    ::Display::MySeparator $w.sep1 -orient vertical
    ::ttk::button $w.describe -image ::bbar::describe -text "Describe" \
	-compound top -command ::Description::Dialog
    ::Balloon::Create $w.describe static describe "Describe Route" ""
    ::ttk::button $w.profile -image ::bbar::profile -text "Profile" \
	-compound top -command ::Profile::Profile
    ::Balloon::Create $w.profile static profile "Profile Route" ""
    ::ttk::button $w.3dprofile -image ::bbar::3dprofile -text "3D Profile" \
	-compound top -command ::3D::RunGnuplot
    ::Balloon::Create $w.3dprofile static 3dprofile "3D Profile" ""
    ::ttk::button $w.google -image ::bbar::google -text "Google" \
	-compound top -command ::Google::Dialog
    ::Balloon::Create $w.google static google "Google" ""

    ::ttk::button $w.info -image ::bbar::info -text "Info" \
	-compound top -command ::RInfo::Dialog
    ::Balloon::Create $w.info static info "Route Info" ""

    ::ttk::button $w.trace -image ::bbar::trace -text "Trace" \
	-compound top -command ::Trace::Trace
    ::Balloon::Create $w.trace static trace "Trace Route" ""

    ::ttk::button $w.hills -image ::bbar::hills -text "Hills" \
	-compound top -command ::Hills::Dialog
    ::Balloon::Create $w.hills static hills "Hills" ""

    ::Display::MySeparator $w.sep2 -orient vertical

    ::ttk::checkbutton $w.milepost -image ::bbar::milepost -text "Mileposts" \
	-compound top -variable state(milepost) -command {::MilePost::Go .c}
    ::Balloon::Create $w.milepost static mileposts "Route Mileposts"
    ::ttk::checkbutton $w.arrow -image ::bbar::arrow -text "Arrows" \
	-compound top -variable state(arrow) -command {::Arrow::Go .c}
    ::Balloon::Create $w.arrow static arrows "Route Arrows"

    ::ttk::checkbutton $w.weather -image ::bbar::weather -text "Weather" \
	-variable state(weather) \
	-compound top -command ::Weather::Toggle
    ::Balloon::Create $w.weather static weather "Weather Forecast"
    ::ttk::checkbutton $w.atlas -image ::bbar::atlas -text "Atlas" \
	-variable state(atlas) \
	-compound top -command ::Atlas::Toggle
    ::Balloon::Create $w.atlas static atlas "Route Atlas"
    ::ttk::checkbutton $w.favorites -image ::bbar::favorites -text "Favorites" \
	-variable state(favorites) \
	-compound top -command ::Favorites::Toggle
    ::Balloon::Create $w.favorites static favorites "Favorites"

    ::ttk::checkbutton $w.overview -image ::bbar::overview -text "Overview" \
	-variable state(overview) \
	-compound top -command ::Overview::Toggle
    ::Balloon::Create $w.overview static overview "Overview Map" ""
    ::ttk::checkbutton $w.legend -image ::bbar::legend -text "Legend" \
	-variable state(legend) \
	-compound top -command ::Legend::Toggle
    ::Balloon::Create $w.legend static legend "Map Legend" ""
    ::ttk::checkbutton $w.nodes -image ::bbar::nodes -text "Nodes" \
	-variable state(nodelist) \
	-compound top -command ::NodeList::Toggle
    ::Balloon::Create $w.nodes static nodes "Node List" ""

    # Under tile, checkbuttons need Toolbutton style
    foreach child [winfo child $w] {
	set class [winfo class $child]
	if {$class eq "TButton" || $class eq "TCheckbutton"} { ;# Tile classes
	    $child config -style Toolbutton
	} elseif {$class eq "Checkbutton"} {
	    $child config -relief raised -indicatoron 0
	}
    }
    eval pack [winfo child $w] -side left
    pack forget $w.3dprofile
    pack config $w.sep1 -fill y -padx 5 -pady 5
    pack config $w.sep2 -fill y -padx 5 -pady 5
    return
}
##+##########################################################################
#
# ::Display::MySeparator -- creates a separator widget using either
# a frame or tile's version
#
proc ::Display::MySeparator {w args} {
    eval ::ttk::separator $w $args
    return $w
}
##+##########################################################################
#
# ::Display::MouseWheelBind -- better mouse wheel handling
#
proc ::Display::MouseWheelBind {} {
    # Taken from tip #171

    # Remove existing class MouseWheel bindings
    set mw_classes [list Text Listbox Table TreeCtrl TCombobox]
    foreach class $mw_classes { bind $class <MouseWheel> {} }
    if {[tk windowingsystem] eq "x11"} {
	foreach class $mw_classes {
	    bind $class <4> {}
	    bind $class <5> {}
	}
    }
    proc ::tk::MouseWheel {wFired D X Y {dir y}} {
	# do not double-fire in case the class already has a binding
	if {[bind [winfo class $wFired] <MouseWheel>] ne ""} { return }
	# obtain the window the mouse is over
	set w [winfo containing $X $Y]
	# if we are outside the app, try and scroll the focus widget
	if {![winfo exists $w]} { catch {set w [focus]} }
	if {[winfo exists $w]} {
	    # scrollbars have different call conventions
	    if {[string match "*Scrollbar" [winfo class $w]]} {
		catch {tk::ScrollByUnits $w \
			   [string index [$w cget -orient] 0] \
			   [expr {-($D/30)}]}
	    } else {
		catch {$w ${dir}view scroll [expr {- ($D / 120) * 4}] units}
	    }
	}
    }
    bind all <MouseWheel> [list ::tk::MouseWheel %W %D %X %Y]
    bind all <Shift-MouseWheel> [list ::tk::MouseWheel %W %D %X %Y x]
    if {[tk windowingsystem] eq "x11"} {
	# Support for mousewheels on Linux/Unix commonly comes through
	# mapping the wheel to the extended buttons.
	bind all <4> [list ::tk::MouseWheel %W 120 %X %Y]
	bind all <Shift-4> [list ::tk::MouseWheel %W 120 %X %Y x]
	bind all <5> [list ::tk::MouseWheel %W -120 %X %Y]
	bind all <Shift-5> [list ::tk::MouseWheel %W -120 %X %Y x]
    }
}
##+##########################################################################
#
# ::Display::ToggleWindow -- toggles display of various parts of the GUI
#
proc ::Display::ToggleWindow {who} {
    if {$who eq "bbar"} {
	if {$::state(bbar) eq "None"} {
	    pack forget .bbar
	    .fbbar config -height 1
	    return
	}
	if {! [winfo ismapped .bbar]} {
	    pack .bbar -in .fbbar -pady 5 -side top -fill x
	}
	if {$::state(bbar) eq "Text"} {
	    foreach c [winfo child .bbar] { catch {$c config -image {}}}
	} else {
	    set how [expr {$::state(bbar) eq "Images" ? "none" : "top"}]
	    foreach c [winfo child .bbar] {
		set img [string map {".bbar." ::bbar::} $c]
		catch [list $c config -compound $how -image $img]
	    }
	}
	return
    }

    # Status window
    if {$::state(sbar)} {
	pack .b -in .bottom -side top -fill x
    } else {
	pack forget .b
	.bottom config -height 1
    }
}
##+##########################################################################
#
# ::Display::MyScroller
#
# Pass through routine for scrolling the canvas. Needed so we
# can update the overview window as the canvas scrolls.
#
proc ::Display::MyScroller {xy w top bottom} {
    $w set $top $bottom				 ;# Call the scrollbar
    ::Overview::Do				 ;# Update overview window
    if {$::state(atlas)} {::ClipBox::Onscreen .c}
}
##+##########################################################################
#
# Busy -- Disables widgets when we're "busy"
#
#proc ::Display::Busy {busy} {
#    set how normal
#    if {$busy} { set how disabled }
#
#    foreach w [concat [winfo child .m] .popup .apopup] {
#	for {set e 0} {$e < 20} {incr e} {
#	    catch {$w entryconfigure $e -state $how}
#	}
#    }
#}
##+##########################################################################
#
# ::Display::HideToplevels -- withdraws all top levels so the
# main window is not obscured
#
proc ::Display::HideToplevels {hide} {
    variable tops

    if {$hide} {
	set tops {}
	foreach w [winfo child .] {
	    if {[winfo class $w] ne "Toplevel"} continue
	    if {[wm state $w] eq "normal"} {
		lappend tops $w [wm state $w]
		wm withdraw $w
	    }
	}
	::Balloon::Enable 0
	raise .
	update
    } else {
	foreach {w wstate} $tops {
	    if {$wstate eq "normal"} { wm deiconify $w }
	}
	::Balloon::Enable 1
    }
}
##+##########################################################################
#
# ::Display::DoMenus
#
# Creates the menus for our GUI
#
proc ::Display::DoMenus {} {

    menu .m -tearoff 0
    . configure -menu .m			 ;# Attach menu to main window

    if {0 && $::tcl_platform(platform) eq "windows"} {
	menu .m.system -tearoff 0
	.m.system add separator
	.m.system add command -label "Console" -command DoConsole
	.m add cascade -label System -menu .m.system
    }

    # Top level menu buttons
    .m add cascade -menu .m.file   -label "File"  -underline 0
    .m add cascade -menu .m.edit   -label "Edit"  -underline 0
    .m add cascade -menu .m.view   -label "View"  -underline 0
    .m add cascade -menu .m.route  -label "Route" -underline 0
    .m add cascade -menu .m.tools  -label "Tools" -underline 0
    .m add cascade -menu .m.xhelp  -label "Help"  -underline 0

    set fileMenus {
	{"&Load Route..." ::Route::Load}
	{"&Save Route..." {::Route::Save 1}}
	{"---"}
	{"Save &User Data" ::Save::SaveUserDataCmd {-state disabled}}
	{"---"}
    }
    ::Display::BuildMenu .m.file $fileMenus

    .m.file add cascade -label "Change Zone" -under 7 -menu .m.file.zone
    .m.file add cascade -label "Change Region" -under 0 -menu .m.file.region
    .m.file add checkbutton -label "Zoom Out Current Region" \
	-underline 1 -variable state(zoomout) -command ::Region::GoRegion
    .m.file add separator
    .m.file add command -label "Print..." -under 0 -command ::Print::Dialog
    .m.file add separator
    .m.file add command -label "Exit" -underline 1 -command exit

    # Fill in the cascading menu
    menu .m.file.zone -tearoff 0
    foreach name [lsort -dictionary $::state(zone,names)] {
	.m.file.zone add radiobutton -label "$name" \
	    -command [list ::Zone::NewZone $name] \
	    -variable state(menu,zone) -value "$name"
    }
    ::Display::FillRegionMenu

    set editMenus {
	{"&Clear" ::Route::ClearRoute}
	{"&Undo" ::Route::UndoRoute2}
	{"---"}
	{"&Revert" ::Region::Revert}
    }
    ::Display::BuildMenu .m.edit $editMenus

    menu .m.view -tearoff 0
    .m.view add cascade -label "Button Bar" -underline 0 -menu .m.view.bbar
    menu .m.view.bbar -tearoff 0
    foreach name {Images Text Both None} {
	.m.view.bbar add radiobutton -label $name -underline 0 -value $name \
	    -variable state(bbar) -command {::Display::ToggleWindow bbar}
    }
    .m.view add checkbutton -label "Status Bar" -underline 0 \
	-variable state(sbar) -command {::Display::ToggleWindow status}
    .m.view add separator
    .m.view add checkbutton -label "Overview Map" -underline 0 \
	-variable state(overview) -command ::Overview::Toggle
    .m.view add checkbutton -label "Node List" -underline 0 \
	-variable state(nodelist) -command ::NodeList::Toggle
    .m.view add checkbutton -label "Legend" -underline 0 \
	-variable state(legend) -command ::Legend::Toggle

    .m.view add separator
    .m.view add command -label "Ride Log..." -underline 0 \
	-command ::RideLog::Dialog
    .m.view add checkbutton -label "Region Info..." -underline 7 \
	-variable state(regionInfo) -command ::Info::Toggle
    .m.view add checkbutton -label "Weather Forecast..." -underline 0 \
	-variable state(weather) -command ::Weather::Toggle
    .m.view add checkbutton -label "Favorites..." -underline 0 \
	-variable state(favorites) -command ::Favorites::Toggle
    .m.view add checkbutton -label "Mileposts" -underline 0 \
	-variable state(milepost) -command {::MilePost::Go .c}
    .m.view add checkbutton -label "Arrows" -underline 0 \
	-variable state(arrow) -command [list ::Arrow::Go .c]

    set routeMenus {
	{"&Describe Route" ::Description::Dialog}
	{"&Profile Route" ::Profile::Profile}
	{"&3D Profile" ::3D::RunGnuplot}
	{"&Google Earth" ::Google::Dialog}
	{"Route &Info" ::RInfo::Dialog}
	{"&Trace Route" ::Trace::Trace}
	{"&Zoom Route" {::Zoom::Go route route}}
	{"&Hills" ::Hills::Dialog}
	{"Add to &Ride Log..." ::RideLog::Edit}
	{"&Email Route" ::Route::Email}
	{"---"}
	{"&Annotate Route" {::Postit::DoRoute 1}}
	{"&Clear Annotations" ::Postit::Reset}
    }
    ::Display::BuildMenu .m.route $routeMenus

    set toolsMenus {
	{"Coordinate &Locator..." {::Coords::Dialog menu}}
	{"&Snapshot..." ::Snapshot::Dialog}
	{"G&PS Tracks..." ::Tracks::Dialog}
	{"&Geocaches..." ::Geocache::Dialog}
	{"C&alorie Calculator" ::Power::Dialog}
	{"---"}
	{"&Customize..." ::Config::Dialog}
	{"&Options..." ::Options::Dialog}
    }
    ::Display::BuildMenu .m.tools $toolsMenus

    set helpMenus {
	{"KLIMB &Help..." ::Help::Help}
	{"---"}
	{"&License..." {::About::License license}}
	{"&Copyright..." {::About::License copyright}}
	{"---"}
    }
    lappend helpMenus [list "&Visit $::state(progname) Website" \
			   [list WebPage $::state(homepage)]]
    lappend helpMenus {"Send &Feedback" Feedback}
    lappend helpMenus {"---"}
    if {$::state(beta)} {
	lappend helpMenus {"&Beta Info..." {::About::License BETA}}
    } else {
	lappend helpMenus {"What's &New..." {::About::License NEW}}
    }
    lappend helpMenus {"&Web Update..." ::WUpdate::Dialog}
    lappend helpMenus {"---"}
    lappend helpMenus {"&Gallery..." ::Gallery::Dialog}
    lappend helpMenus {"&Quotes..." ::About::Quotes}
    lappend helpMenus {"&About KLIMB..." ::About::About}
    ::Display::BuildMenu .m.xhelp $helpMenus

    # This menu only appears in superuser mode
    set sanityMenus {
	{"&Data Check..." ::Sanity::Dialog}
	{"&Node Renumber..." ::Renumber::Dialog}
	{"&Config Dump..." ::Config::Dump}
	{"CanDo &Test..." ::Sanity::CanDoDialog}
	{"&Printer Page Size..." ::Sanity::PageSizeTest}
	{"Web &Services..." ::Sanity::WebServicesDialog}
	{"---"}
	{"Show &Bad Data" ::Display::HighlightMissingData}
	{"Show &Missing Elevation" ::Display::HighlightMissingElev}
	{"Show &Waypoints" ::Sanity::WaypointRoad}
	{"&Clear All" ::Display::ClearAllHighlighting}
    }
    ::Display::BuildMenu .m.special $sanityMenus

    set popupMenus {
	{"&Undo" ::Route::UndoRoute2}
	{"&Clear Route" ::Route::ClearRoute}
	{"&Describe Route" ::Description::Dialog}
	{"&Profile Route" ::Profile::Profile}
	{"---"}
	{"Create New &Node at point" ::Edit::CreateNode}
	{"Update Node &Info" {::Edit::CreateNode popup}}
	{"Create New &Road" ::Edit::CreateRoad}
	{"Update Road In&fo" {::Edit::CreateRoad popup}}
	{"&Split Road at point" ::Edit::CreateSplit}
	{"E&xtend Route to" {::Route::ExtendRoute popup}}
	{"---"}
	{"Node Neigh&borhood" {::Within::Dlg popup}}
	{"Create &Annotation" {::Postit::Go popup ?}}
	{"Create Ph&oto" ::Edit::CreatePhoto}
	{"Create Arro&w" {::Arrow::Dialog .c "" {0 0}}}
	{"&Google Maps" {::Zoom::Google popup ?}}
	{"&Zoom" {::Zoom::Go popup ?}}
	{"---"}
    }
    ::Display::BuildMenu .popup $popupMenus

    set turnMenus {
	{"Turn &Left" {::Route::Turn L}}
	{"Turn &Right" {::Route::Turn R}}
	{"&U Turn" {::Route::Turn U}}
	{"Go &Straight" {::Route::Turn S}}
	{"&None" {::Route::Turn N}}
	{"&Zigzag Right then Left" {::Route::Turn Z}}
	{"Z&igzag Left then Right" {::Route::Turn Y}}
	{"---"}
	{"&Omit" {::Route::Turn O}}
    }
    ::Display::BuildMenu .popup.turn $turnMenus
    .popup add cascade -label "Route Turnings" -under 6 -menu .popup.turn

    set aboutMenus {
	{"&Large version" ::About::Large}
	{"---"}
	{"&Next picture" {::About::_Abouter next}}
	{"&Previous picture" {::About::_Abouter prev}}
	{"&Random picture" {::About::_Abouter random}}
	{"---"}
	{"&Gallery" ::Gallery::Dialog}
    }
    ::Display::BuildMenu .apopup $aboutMenus

    menu .delpopup -tearoff 0			;# Profile/arrow label click
    .delpopup add command -label "Delete ????" -underline 0
}
##+##########################################################################
#
# ::Display::DoPopupMenu
#
# Puts up a popup menu. Many of the entries are disabled depending on
# what was clicked.
#
proc ::Display::DoPopupMenu {x y what who} {
    set ss(0) disabled ; set ss(1) normal
    set row 10					;# Default to Extend Route

    ::Balloon::Cancel
    set px [winfo pointerx .c]			;# Work in window coordinates
    set py [winfo pointery .c]
    set cx [.c canvasx $x]
    set cy [.c canvasy $y]

    set ::state(popup)	    [list $x $y]	;# Where popup occurred
    set ::state(popup,p)    [list $px $py]	;# Window origin points
    set ::state(popup,c)    [list $cx $cy]	;# Canvas coordinates
    set ::state(popup,what) $what
    set ::state(popup,who)  $who
    set ::state(popup,ll) [lrange [::Display::canvas2pos $x $y] 4 5]

    set sMap       $ss([expr {$what eq "map" || $what eq "embellishment"}])
    set sNode      $ss([expr {$what eq "node"}])
    set sRoad      $ss([expr {$what eq "road"}])
    set sPostit    $ss([expr {$what eq "postit"}])
    set sNodeRoute $ss([expr {$what eq "node" && $::route(nodes) ne {}}])

    set mRow 4
    .popup entryconfig [incr mRow] -state $sMap	;# Create node
    .popup entryconfig [incr mRow] -state $sNode ;# Edit node
    .popup entryconfig [incr mRow] -state $sMap	;# Create road
    .popup entryconfig [incr mRow] -state $sRoad ;# Edit road
    .popup entryconfig [incr mRow] -state $sRoad ;# Split road
    .popup entryconfig [incr mRow] -state $sNodeRoute ;# Extend route
    incr mRow					;# Separator
    .popup entryconfig [incr mRow] -state $sNode ;# Node neighborhood

    if {$what eq "wpt"} { .popup entryconfig 5 -state normal }
    if {$what eq "postit"} { .popup entryconfig 5 -state normal }
    if {$what eq "track"} { .popup entryconfig 5 -state normal }

    # Postit
    incr mRow
    if {$what eq "postit"} {
	.popup entryconfig $mRow -label "Update Annotation" \
	    -command [list ::Postit::Dialog $who]
	set row $mRow
    } else {
	set txt "Add Annotation"
	if {$what eq "node"} { set txt "Add Node Annotation"}
	if {$what eq "road"} { set txt "Add Road Annotation"}
	if {$what eq "poi"} { set txt "Add POI Annotation"}
	if {$what eq "wpt"} { set txt "Add Waypoint Annotation"}
	if {$what eq "geo"} { set txt "Add Geocache Annotation"}
	.popup entryconfig $mRow -label $txt \
	    -command [list ::Postit::Go popup ?]
    }

    # Photo
    incr mRow
    if {$what eq "photo"} {
	.popup entryconfig 14 -label "Update Photo" -state normal \
	    -command [list ::Edit::CreatePhoto $who]
	set row $mRow
    } else {
	.popup entryconfig $mRow -state $sMap -label "Create Photo" \
	    -command ::Edit::CreatePhoto
    }

    # Arrow
    incr mRow
    if {$what eq "arrow"} {
	.popup entryconfig $mRow -label "Update Arrow" -state normal \
	    -command [list ::Arrow::Dialog .c $who]
	set row $mRow
    } else {
	.popup entryconfig $mRow -state $sMap -label "Create Arrow" \
	    -command [list ::Arrow::Dialog .c "" $::state(popup,c)]
    }

    # Google Map
    incr mRow
    .popup entryconfig $mRow -state \
	[expr {$what eq "postit" ? "disabled" : "normal"}]

    # zoom
    incr mRow
    set txt "Zoom"
    if {$what eq "node"} { set txt "Zoom Node"}
    if {$what eq "road"} { set txt "Zoom Road"}
    if {$what eq "poi"} { set txt "Zoom POI"}
    if {$what eq "wpt"} { set txt "Zoom Waypoint"}
    if {$what eq "geo"} { set txt "Zoom Geocache"}
    if {$what eq "map"} { set txt "Zoom Point" }
    set sZoom [expr {$txt ne "Zoom" ? "normal" : "disabled"}]
    .popup entryconfig $mRow -label $txt -state $sZoom

    # Separator
    incr mRow

    # Route turnings
    incr mRow
    .popup entryconfig $mRow -state disabled	;# Route turnings
    if {$what eq "node" && [lsearch $::route(nodes) $who] > -1} {
	.popup entryconfig $mRow -state normal
	set row $mRow
    }

    if {[tk windowingsystem] eq "x11"} { set row "" }
    tk_popup .popup $px $py $row
}
##+##########################################################################
#
# ::Display::GetMenuKey -- Extract menu accelerator key "&" from menu label
#
proc ::Display::GetMenuKey {str} {
    set n [string first "&" $str]
    if {$n == -1} { return [list $n $str]}

    set str2 [string range $str 0 [expr {$n-1}]]
    set str2 "$str2[string range $str [expr {$n+1}] end]"
    return [list $n $str2]
}
##+##########################################################################
#
# ::Display::BuildMenu -- Creates a menu of command entries from a list
#
proc ::Display::BuildMenu {m menus} {

    if {! [winfo exists $m]} {menu $m -tearoff 0}
    foreach mentry $menus {
	foreach {lbl cmd extra} $mentry break
	if {[string index $lbl 0] eq "\#"} continue

	if {$lbl eq "---"} {
	    $m add separator
	} else {
	    foreach {under lbl} [::Display::GetMenuKey $lbl] break
	    eval [list $m add command -label $lbl -underline $under \
		      -command $cmd] $extra
	}
    }
}
##+##########################################################################
#
# ::Display::FillRegionMenu -- fills in the cascading region menu
#
proc ::Display::FillRegionMenu {} {

    if {! [winfo exists .m.file]} return
    destroy .m.file.region
    menu .m.file.region -tearoff 0

    .m.file.region add command -label "Advanced..." -underline 0 \
	-command ::Region::Select
    .m.file.region add command -label "Revert" -underline 0 \
	-command ::Region::Revert
    .m.file.region add separator

    foreach which [lsort -dictionary [array names ::region *,maps]] {
	foreach {name mag} [split $which ,] break
	set lbl $name
	if {[info exists ::region($name,$mag,label)]} {
	    append lbl $::region($name,$mag,label)
	}
	.m.file.region add radiobutton -label $lbl \
	    -command [list ::Region::GoRegion $name $mag] \
	    -variable state(menu,region) -value "$name,$mag"
    }
}
##+##########################################################################
#
# ::Display::FirstMap
#
# Loads the first map for this region. We need to do this early on
# to get scaling information.
#
proc ::Display::FirstMap {} {
    global map state region
    variable coords

    set maps $region($state(locale),maps)	 ;# List of maps
    set start [lindex $maps 0]			 ;# First map of the list
    set steps [expr {[llength $maps] + 5}]

    ::Display::DoProgressBar 1 $steps
    INFO "loading starting map $start..."
    set mapid [::Display::CreateOneMap $start $state(images)]
    ::Display::DoProgressBar

    # Get map coordinates and image size so we can get the
    # scaling factors to place everything correctly on the canvas
    if {$region(UTM)} {
	foreach {coords(root,top) coords(root,left) zone1
	    coords(root,bottom) coords(root,right) zone2} $map($start) break

    } else {
	foreach x {top left bottom right} {d m s} $map($start) {
	    set coords(root,$x) [lat2int $d $m $s]
	}
	if {$region(slippy) && [::Data::CanDo slippy]} {
	    set n [regexp {(\d+)_(\d+)_(\d+)(__\d+x\d+)?\.} $start . zoom col row]
	    if {! $n} { error "cannot parse slippy map $start" }

	    set tile [list $zoom $row $col]
	    set coords(root,slippy,point) [::map::kpv_slippy tile 2point $tile]
	    #set geo [::map::kpv_slippy tile 2geo $tile]
	    #set coords(root,slippy,tile) $tile
	    #set coords(root,slippy,geo) $geo
	    #set coords(root,slippy,point) [::map::kpv_slippy geo 2point $geo]
	}
    }
    set coords(root,h)  [expr {$coords(root,bottom) - $coords(root,top)}]
    set coords(root,w)  [expr {$coords(root,right) - $coords(root,left)}]
    set coords(root,ih) [image height $mapid]
    set coords(root,iw) [image width $mapid]
}
##+##########################################################################
#
# ::Display::CreateOneMap
#
# Creates an image and places it on the canvas in the correct position
#
proc ::Display::CreateOneMap {mapname {show 1}} {
    global map state region
    variable coords

    if {![info exists map($mapname)]} return	 ;# Unknown map
    set tag "::map::$mapname"

    if {[lsearch [image names] $tag] == -1} {
	set fname [::Init::LocateZoneFile $mapname]
	if {$state(zoomout) || $state(zoomin)} {
	    set state(isZoomed) 1
	    image create photo tmp -file $fname
	    image create photo $tag
	    if {$state(zoomout)} {
		$tag copy tmp -subsample $state(zoomlevel) $state(zoomlevel)
	    } else {
		set z 2
		if {$state(zoomin) > 2} {
		    set z $state(zoomin)
		}
		$tag copy tmp -zoom 2 2
	    }
	    image delete tmp
	} else {
	    set state(isZoomed) 0
	    image create photo $tag -file $fname
	}
    }
    if {! $show} { return $tag }
    if {[.c find withtag $tag] ne ""} { return $tag }

    # Figure out where to put the image on the canvas. If we don't have
    # the image information then we default to (0,0)
    set xy [list 0 0]				 ;# Default placing it here
    if {[info exists coords(root,top)]} {
	if {$region(UTM)} {
	    foreach {northing easting zzone} $map($mapname) break
	    set xy [::Display::pos2canvas root $northing $easting $zzone]
	} else {
	    foreach {d m s d2 m2 s2} $map($mapname) break
	    set lat [lat2int $d $m $s]
	    set lon [lat2int $d2 $m2 $s2]
	    set xy [::Display::pos2canvas root $lat $lon]
	}
    }
    foreach {X Y} $xy break
    .c create image $X $Y -image $tag -anchor nw -tag [list maps $tag]
    catch {.c lower $tag roads}
    #.c bind $tag <Button-3> [list ::Display::DoPopupMenu %x %y map $tag]
    .c bind $tag <<MenuMousePress>> [list ::Display::DoPopupMenu %x %y map $tag]

    return $tag
}
proc ::Display::DebugMaps {} {
    .c delete debug
    foreach id [.c find withtag maps] {
	set tag [lindex [.c itemcget $id -tag] 1]
	foreach {x0 y0 x1 y1} [.c bbox $tag] break
	set x [expr {($x0+$x1)/2}]
	set y [expr {($y0+$y1)/2}]
	.c create rect $x0 $y0 $x1 $y1 -outline magenta -width 5 -tag debug
	set txt [file rootname [file tail $tag]]
	if {[regexp {/(\d+)/(\d+)/(?:C_)?(\d+)} $tag . z r c]} {
	    set txt "$z/$r/$c"
	}
	.c create text $x $y -text $txt -tag debug -font {Helvetica 18 bold}
	continue

	set txt ""
	if {[regexp {(\d+)_(\d+)_(\d+)\.} $tag . xChunk yChunk zChunk]} {
	    set txt "$xChunk,$yChunk,$zChunk"
	} elseif {[regexp {_(\d+)_(\d+)\.} $tag . xChunk yChunk]} {
	    set txt "$xChunk,$yChunk"
	} elseif {[regexp {(\d\d)(\d\d)(_top|_bot)?\.(gif|jpg)} $tag \
		 . icol irow tb]} {
	    set txt "$icol,$irow$tb"
	} elseif {[regexp {(C\d*_)?(\d+)_(\d+)_\d} $tag . . xChunk yChunk]} {
	    set txt "$xChunk,$yChunk"
	} else {
	    set txt [file rootname [file tail $tag]]
	}
	if {$txt ne ""} {
	    .c create text $x $y -text $txt -tag debug -font {Helvetica 18 bold}
	}
    }
}
##+##########################################################################
#
# ::Display::WhichMap -- determines which map of this region a lat/lon is in
#
proc ::Display::WhichMap {lat lon} {
    global region state map

    if {$region(UTM)} {
	foreach {north east z} [::Data::ll2utm $lat $lon] break
    }

    foreach m $region($state(locale),maps) {	;# List of maps
	if {$region(UTM)} {
	    foreach {n0 e0 z0 n1 e1 z1} $map($m) break
	    if {$north > $n0 || $north < $n1} continue
	    if {$east < $e0 || $east > $e1} continue
	    return $m
	} else {
	    foreach {a b c} $map($m) who {lat0 lon0 lat1 lon1} {
		set $who [lat2int $a $b $c]
	    }
	    if {$lat > $lat0 || $lat < $lat1} continue
	    if {$lon > $lon0 || $lon < $lon1} continue
	    return $m
	}
    }
    return {}
}
##+##########################################################################
#
# ::Display::CreateAllMaps
#
# Creates all but the initial map. This can be time consuming.
#
proc ::Display::CreateAllMaps {} {
    global map state region

    if {$state(images) >= 2} {			;# Debugging time saver
	INFO "loading maps images"

	set maps $region($state(locale),maps)	;# List of maps
	set num [expr { 2 + [llength $maps]}]

	foreach mapname [lrange $maps 1 end] {
	    INFO "loading map $mapname"
	    ::Display::CreateOneMap $mapname
	    ::Display::DoProgressBar
	}
	.c lower maps
	INFO "all maps loaded"
    }
    ::Display::DoProgressBar 0 0		;# Erase progress bar
    set state(zoomin) 0				;# Always turn this off
}
##+##########################################################################
#
# ::Display::DeleteAllMaps
#
# Deletes all the existing maps images, except those needed in the new region.
#
proc ::Display::DeleteAllMaps {} {
    set next [string tolower $::region($::state(locale),maps)] ;# Maps needed
    if {$::state(isZoomed) || $::state(zoomin) || $:::state(zoomout)} {
	set next {}
    }

    foreach map1 [image names] {
	if {! [string match "::map::*" $map1]} continue
	set map2 [string tolower $map1]
	regsub {^::map::} $map2 {} map2
	if {[lsearch $next $map2] == -1} {
	    image delete $map1
	}
    }
}
##+##########################################################################
#
# ::Display::DrawNodes
#
# Draws the nodes on the map. If clip is true, we don't draw nodes off
# the map.
#
proc ::Display::DrawNodes {{who {}} {clip 1}} {
    global nodes state region

    set item oval

    if {$who eq {}} {				;# All the nodes
	INFO "drawing the nodes..."
	set who [array names nodes]
	array unset region nodes,*
	set single 0
    } else {					;# Single node
	set single 1
    }
    foreach node $who {
	foreach {name alt lat lon xy} $nodes($node) break
	if {$clip && ! [::Display::ClipNode $lat $lon]} continue
	if {$clip && ! $single} { lappendUnique region(node,visible) $node }

	set pos [::Display::MakeBox $xy $state(N,size)]
	set item oval
	if {[string match "X*" $node]} {	;# All X* nodes are square
	    set item rectangle
	}
	if {$single} { .c delete inode_$node }
	.c create $item $pos -fill $state(n,0,color) \
	     -tag [list nodes node_$node inode_$node node_oval]

	if {0} {				;# Cross hairs for nodes
	    puts "node: $node"
	    foreach {x1 y1 x2 y2} $pos break
	    .c delete node_$node
	    .c create line $pos -fill magenta -width 5 \
		     -tag [list nodes node_$node inode_$node node_oval]
	    .c create line $x1 $y2 $x2 $y1 -fill magenta -width 5 \
		     -tag [list nodes node_$node inode_$node node_oval]
	    .c create line $pos -fill black -width 1 \
		     -tag [list nodes node_$node inode_$node node_oval]
	    .c create line $x1 $y2 $x2 $y1 -fill black -width 1 \
		     -tag [list nodes node_$node inode_$node node_oval]
	}

	regexp {[A-Za-z0-9]+} [string map {n {} N {}} $node] txt
	if {$state(N,size) >= 8 && ! $state(n,hide)} {
	    .c create text $xy -text $txt -font nodeFont \
	       -tag [list nodes node_text text_$node inode_$node]
	    .c move text_$node 0 1
	}

	::Balloon::Create [list .c inode_$node] node $node
	.c bind inode_$node <Button-1> [list ::Display::PickRoad node $node]
	.c bind inode_$node <Double-Button-1> [list ::Edit::CreateNode $node]
	.c bind inode_$node <Button-2> [list ::Route::ExtendRoute $node]
	.c bind inode_$node <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y node $node]
    }
}
##+##########################################################################
#
# ::Display::DrawRoads -- draws the roads on the map
#
proc ::Display::DrawRoads {{who {}}} {
    global nodes roads state zone region

    if {$who eq {}} {
	INFO "drawing the roads..."
	set who [array names roads]
	array unset region roads,*
	set single 0
    } else {
	INFO "drawing road $who"
	set single 1
	.c delete road_$who
    }

    catch {unset clipped}
    foreach rid $who {
	foreach {id1 id2 north distance south type . . xy . quality} \
	    $roads($rid) break
	if {![info exists nodes($id1)] || ![info exists nodes($id2)]} continue

	foreach {name1 alt1 lat1 lon1 xy1} $nodes($id1) break
	foreach {name2 alt2 lat2 lon2 xy2} $nodes($id2) break

	# Clip nodes not on the map--unless they're directly connected
	# to a node on the map
	set clip1 [::Display::ClipNode $lat1 $lon1]
	set clip2 [::Display::ClipNode $lat2 $lon2]
	if {! $clip1 && ! $clip2} continue	;# Both outside
	if {! $clip1 && ![info exists clipped($id1)]} {
	    set clipped($id1) 1
	}
	if {! $clip2 && ![info exists clipped($id2)]} {
	    set clipped($id2) 1
	}
	lappendUnique region(road,visible) $rid

	# road_$type used by config; q$quality ???
	set tag [list roads road_$rid road_$type q$quality]
	set tag [list roads road_$rid road_$type]
	set XY [::Display::GetRoadPoints $rid]
	.c create line $XY -tag $tag -width $state(r,0,$type,width) \
	    -fill $state(r,0,$type,color)

	::Balloon::Create [list .c road_$rid] road $rid
	.c bind road_$rid <Button-1> [list ::Display::PickRoad road $rid]
	.c bind road_$rid <Double-Button-1> [list ::Edit::CreateRoad $rid]
	.c bind road_$rid <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y road $rid]
	.c bind road_$rid <Alt-Button-1> [list ::Display::BendRoad 2 $rid 0]

	if {$single} {
	    .c raise inode_$id1
	    .c raise inode_$id2
	}
	# Make incomplete roads dashed
	if {$quality > $zone(goodData)} {
	    .c addtag bad withtag road_$rid
	    .c itemconfig road_$rid -dash "-"
	}
	continue
    }

    # Now draw all the nodes that are off the map but connected to nodes
    # on the map.
    foreach nodeid [array names clipped] {
	::Display::DrawNodes $nodeid 0
    }
    ::Display::Raise
    return
}
##+##########################################################################
#
# ::Display::GetRoadPoints
#
# Returns a list of canvas (x,y) points that is the road.
#
proc ::Display::GetRoadPoints {rid} {
    global nodes roads

    set edgedRoads 0

    foreach {id1 id2 north distance south type . . XY} $roads($rid) break
    foreach {name1 alt1 lat1 lon1 xy1} $nodes($id1) break
    foreach {name2 alt2 lat2 lon2 xy2} $nodes($id2) break

    foreach {x1 y1} $xy1 {x2 y2} $xy2 break

    set rxy $xy1
    foreach {a1 a2 a3 b1 b2 b3} $XY {
	set lat [lat2int $a1 $a2 $a3]
	set lon [lat2int $b1 $b2 $b3]

	foreach {x y} [::Display::pos2canvas root $lat $lon] break
	if {0 && $edgedRoads} {			;# Throw out points inside node
	    set dist [expr {hypot($x1-$x,$y1-$y)}]
	    if {$dist < $::state(n,size)} continue
	    set dist [expr {hypot($x2-$x,$y2-$y)}]
	    if {$dist < $::state(n,size)} continue
	}

	lappend rxy $x $y
    }
    lappend rxy $x2 $y2
    if {0 && $edgedRoads} {			;# Road ends at node's edge
	foreach {a b c d} [lrange $rxy 0 3] break
	set pt1 [::Display::NodeEdge $a $b $c $d]
	set rxy [eval lreplace [list $rxy] 0 1 $pt1]

	foreach {a b c d} [lrange $rxy end-3 end] break
	set pt2 [::Display::NodeEdge $c $d $a $b]
	set rxy [eval lreplace [list $rxy] end-1 end $pt2]
    }
    return $rxy
}
##+##########################################################################
#
# ::Display::NodeEdge -- returns point on node's edge where this line comes in
#
proc ::Display::NodeEdge {x0 y0 x1 y1} {
    global state

    set dx [expr {$x1-$x0}]
    set dy [expr {$y1-$y0}]
    set v [::Data::VReScale [list $dx $dy] $state(n,size)]
    return [::Data::VAdd [list $x0 $y0] $v]
}
##+##########################################################################
#
# ::Display::BendRoad -- makes a road pass through a given point.
# what: 0 add a point; 1 undo last point; 2 pick new road to bend
#
proc ::Display::BendRoad {what x y} {
    global rid roads

    #if {[winfo exists .zoom]} return
    if {$what == 2} {
	set rid $x
	INFO "Road $rid selected for bending (start: [lindex $roads($rid) 0])"
	return
    }

    if {! [info exists rid]} return
    if {! [info exists roads($rid)]} return

    set xy [lindex $roads($rid) 8]
    set z [lindex $roads($rid) 9]
    if {$what == 0} {				;# Add a point
	set ll [::Display::canvas2pos $x $y]
	foreach {lat lon} $ll break

	set a [lrange $xy end-5 end]
	set b [concat $lat $lon XX]
	foreach a $a b $b {
	    if {$a != $b} break
	}
	if {$b eq "XX"} return			;# Identical point
	set xy [concat $xy $lat $lon]
	lappend z "?"
    } elseif {$what == 1} {			;# Undo
	set xy [lrange $xy 0 end-6]
	set z [lrange $z 0 end-1]
    }
    lset roads($rid) 8 $xy
    lset roads($rid) 9 $z
    ::Display::DrawRoads $rid
    set newDist [::BadMath::Round1 [::Data::RoadDistance $rid]]
    lset roads($rid) 3 $newDist
    ::Data::ProcessRoads $rid
    ::Balloon::ClearText road $rid
}
##+##########################################################################
#
# DrawPOI
#
# Draws all or one POI (point of interest)
#
proc ::Display::DrawPOI {{who {}} {clip 1}} {
    global state poi region

    if {$who eq {}} {				;# All the POI
	INFO "drawing points of interest..."
	set who [array names poi]
    } else {					;# Single POI
	.c delete poi_$who
	INFO "drawing point of interest $who"
    }

    foreach p $who {
	foreach {type name lat lon location ldesc xy url} $poi($p) break
	if {$clip && ! [::Display::ClipNode $lat $lon]} continue

	set coords [::Display::MakeStar $xy $state(p,size)]
	.c create poly $coords -fill $state(p,color) \
	    -tag [list poi poi_$p] -outline black -width 2

	::Balloon::Create [list .c poi_$p] poi $p
	.c bind poi_$p <Double-Button-1> [list ::POI::ShowInfo $p]
	.c bind poi_$p <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y poi $p]
	lappend region(poi,visible) $p
    }
}
##+##########################################################################
#
# ::Display::Refresh -- Updates the display to reflect the values in
# the state array. NB. values can be illegal, such as empty road widths.
#
proc ::Display::Refresh {howChanged} {
    set n [catch {::Display::_Refresh $howChanged} errmsg]
    if {$n} {
	WARN "Customize Error: $errmsg"
	return 0
    }
    return 1
}
proc ::Display::_Refresh {howChanged} {
    global state

    for {set i 0} {[info exists state(r,0,$i,color)]} {incr i} {
	.c itemconfig road_$i -fill $state(r,0,$i,color) \
	    -width $state(r,0,$i,width)
    }
    set state(N,size) $state(n,size)
    ::Display::SetPanningGain

    if {$howChanged & 2} {		   ;# Node size
	.c delete nodes
	::Display::DrawNodes
    } else {
	.c itemconfig node_oval -fill $state(n,0,color)
    }
    if {$howChanged & 4} {			;# Poi size
	.c delete poi
	::Display::DrawPOI
    } else {
	.c itemconfig poi -fill $state(p,color)
    }

    if {$howChanged & 8} {			;# Waypoint--always redraw all
	::GPS::DrawWpts g 0
    }

    if {$howChanged & 16} {			;# Unit change
	::Balloon::ClearText road *
	::Balloon::ClearText node *
	if {[winfo exists .pro]} ::Profile::Redraw
	if {[winfo exists .d]} {::Description::Describe}
	::Trace::Units
	::Tracks::ReState 1
    }
    ::Route::StatRoute 1			;# Redo any road

    if {$howChanged & 32} {			;# Annotation color
	.c itemconfig a,box -fill $::state(a,color)
    }
    if {$howChanged & 64} {			;# Annotation font size
	::Postit::Redraw
    }

    if {$howChanged & 128} {			;# Stop and go signs
	::Arrow::StopGoIfNeeded
    }
    if {$howChanged & 256} {
	::Description::Describe
    }
    if {$howChanged & 512} {
	.c [expr {$state(n,hide) ? "lower" : "raise"}] node_text
    }

    # Profile stuff
    ::Profile::Redraw

    # Font stuff
    eval font config nodeFont [font actual $state(n,font)]
    eval font config descFont [font actual $state(desc,font)]
    eval font config descTitleFont [font actual $state(desc,titleFont)]
    eval font config descFixedFont "[font actual descFont] -family Courier"
    eval font config descHeaderFont "[font actual descFont] -weight bold"
    eval font config descBoldFont "[font actual descFont] -weight bold"

    # Now for some balloon help
    .balloonhelp.info configure -font $state(balloon,font)
    if {! [string is integer $state(balloon,delay)]} {
	error "Tooltip delay must be an integer."
    }

    ::Legend::Update
}
##+##########################################################################
#
# ::Display::ClipNode -- returns 1 if node is inside the scroll region
#
proc ::Display::ClipNode {lat lon} {
    variable coords

    # NB. coords(zone,*) now is lat/lon
    #if {$::region(UTM)} {
    #	foreach {north east z} [::Data::ll2utm $lat $lon] break
    #	if {$north > $coords(zone,top) || $north < $coords(zone,bottom) \
    #		|| $east < $coords(zone,left) || $east > $coords(zone,right)} {
    #	    return 0
    #	}
    #	return 1
    #}

    if {$lat > $coords(zone,top) || $lat < $coords(zone,bottom) \
	    || $lon > $coords(zone,left) || $lon < $coords(zone,right)} {
	return 0
    }
    return 1
}
##+##########################################################################
#
# ::Display::ClipNode2 -- ClipNode but w/ node id as input (called by sanity)
#
proc ::Display::ClipNode2 {nid} {
    return [eval ::Display::ClipNode [lrange $::nodes($nid) 2 3]]
}
##+##########################################################################
#
# ::Display::ClipRoad2 -- determines if a road is visible (called by sanity)
#
proc ::Display::ClipRoad2 {rid} {
    foreach {nid1 nid2} $::roads($rid) break
    return [expr {[::Display::ClipNode2 $nid1] || [::Display::ClipNode2 $nid2]}]
}
##+##########################################################################
#
# ::Display::GetBounds -- returns top/left bottom/right in lat/lon of region
#
proc ::Display::GetBounds {} {
    variable coords
    global region

    # NB. coords(zone,*) always in lat/lon
    #if {$region(UTM)} {				;# Convert to lat/lon
    #	set tl [::Data::utm2ll $coords(zone,top) $coords(zone,left) $region(UTMZONE)]
    #	set br [::Data::utm2ll $coords(zone,bottom) $coords(zone,right) $region(UTMZONE)]
    #	return [concat $tl $br]
    #}

    return [list $coords(zone,top) $coords(zone,left) \
		$coords(zone,bottom) $coords(zone,right)]
}
##+##########################################################################
#
# Debugging routine to help with MakeRegion tool
#
proc ::Display::GetBoundsWaypoints {} {
    foreach {lat0 lon0 lat1 lon1} [::Display::GetBounds] break
    set result "MakeWaypoint \x22$::state(region)_tl\x22 $lat0 $lon0\n"
    append result "MakeWaypoint \x22$::state(region)_br\x22 $lat1 $lon1\n"
    clipboard clear
    clipboard append $result
    return $result
}
##+##########################################################################
#
# ::Display::DoScale -- creates canvas $w with a map scale drawn in it
#
proc ::Display::DoScale {w width} {
    #puts "w: $w width $width" ; set ::w $w; set ::width $width
    set ppm [::Display::GetPixelsPerMile]
    set ppk [expr {$ppm / 1.609344}]		;# Pixels per kilometer

    set x0 10					;# Left margin
    set lh 50					;# Height of legend display
    set lh2 [expr {$lh / 2.0}]

    # Base tick interval on not-too-small kilometer ticks
    foreach tScale {.01 .1 .25 .5 1.0 2.0 5.0} {
	set pixels [expr {$ppk * $tScale}]
	if {$tScale == .1 && $pixels >= 4} break
	if {$pixels >= 6} break
    }

    set mi [expr {$width / $ppm}]		;# How many miles per width
    set mi [expr {$mi >= 1 ? int($mi) : $mi >= .5 ? .5 : int($mi*10)/10.0}]
    set mi [expr {round($mi / $tScale) * $tScale}]

    set km [expr {$mi * 1.609344}]
    set km [expr {$km >= 1 ? int($km) : $km >= .5 ? .5 : int($km*10)/10.0}]
    #set km [expr {round($km / $tScale) * $tScale}]

    set mTicks [expr {int($mi / $tScale)}]
    set kTicks [expr {int($km / $tScale)}]
    set tBig [expr {int(1.0 / $tScale)}]	;# Big tick interval
    set tMed [expr {$tBig / 2}]			;# Medium tick interval
    if {$tScale == .01} { set tBig 10}
    if {$tScale > 1.0} {set tBig [set tMed 1]}
    #if {$tBig > $mTicks} {set tBig $mTicks}

    set x1 [expr {$x0 + $mTicks * $ppm * $tScale}]
    destroy $w
    canvas $w -height $lh -width $width -bd 0 -highlightthickness 0
    ::Display::TileBGFix $w
    $w create line $x0 $lh2 $x1 $lh2

    set lastKLbl 9999				;# Last mile label x coordinate
    set lastMLbl 9999
    $w create text 0 0 -tag X; set font [$w itemcget X -font]; $w delete X
    set lblWidth [expr {2 * [font measure $font "0.0"]}] ;# Space between labels

    set numTicks [expr {$mTicks > $kTicks ? $mTicks : $kTicks}]
    for {set tick $numTicks} {$tick >= 0} {incr tick -1} {
	set h [expr {$tick % $tBig ? ($tick % $tMed) ? 6 : 9 : 12}]
	set big [expr {$tick && $h > 6 }]

	set txt [expr {$tScale >= 1.0 ? int($tick * $tScale) : $tick * $tScale}]
	if {$tick <= $mTicks} {			;# Mile ticks
	    set x [expr {$x0 + $tick * $ppm * $tScale}]
	    $w create line $x $lh2 $x [expr {$lh2 - $h}]
	    if {$big || $tick == $mTicks} {
		set d [expr {$lastMLbl - $x}]
		if {$d > $lblWidth} {
		    set lastMLbl $x
		    $w create text $x [expr {$lh2-10}] -text $txt -anchor s \
			-tag mi
		}
	    }
	}

	if {$tick <= $kTicks} {			;# Kilometer ticks
	    set x [expr {$x0 + $tick * $ppk * $tScale}]
	    $w create line $x $lh2 $x [expr {$lh2 + $h}]
	    if {$big || $tick == $kTicks} {
		set d [expr {$lastKLbl - $x}]
		if {$d > $lblWidth} {
		    set lastKLbl $x
		    $w create text $x [expr {$lh2+10}] -text $txt -anchor n \
			-tag km
		}
	    }
	}
    }

    foreach {. . x y} [$w bbox mi] break
    set x [lindex [$w bbox mi] 2]
    $w create text $x $y -text "mi" -anchor sw -tag lmi
    foreach {. yk xk .} [$w bbox km] break
    $w create text $xk $yk -text "km" -anchor nw -tag lkm

    set width [lindex [$w bbox all] 2]
    $w config -width $width
    return $w
}
##+##########################################################################
#
# ::Display::GetPixelsPerMile -- as the name says
#
proc ::Display::GetPixelsPerMile {} {
    foreach {l t r b w h} [::Display::GetScreenRect] break
    foreach {. . . . lat1 lon1} [::Display::canvas2pos $l $t] break
    foreach {. . . . lat2 lon2} [::Display::canvas2pos $r $b] break

    set dist [::Data::Distance $lat1 $lon1 $lat1 $lon2] ;# Horizontal distance
    set PixelsPerMile [expr {double($w) / $dist}]
}
##+##########################################################################
#
# ::Display::ShowRightFrame
#
# The right hand frame is to hold the overview window and the nodelist
# window, both of which may or may not be there. For nice boundaries we
# play around with several frames. This routine keeps track of which
# frames should or should not be mapped.
#
proc ::Display::ShowRightFrame {} {

    set over $::state(overview)
    set nodes $::state(nodelist)
    set legend $::state(legend)

    pack forget .over .nodes .legend
    if {$over || $nodes || $legend} {		;# Do we need the right frame?
	if {! [winfo ismapped .right]} {	;# Yes,
	    # Pack .right before .main to get better resizing behavior
	    eval pack .right .main [pack info .main]
	    pack configure .right -expand 0
	}
	if {$over} {
	    pack .over -side top -pady 3 -in .right -fill x
	}
	if {$legend} {
	    pack .legend -side top -pady 3 -in .right -fill x
	}
	if {$nodes} {
	    pack .nodes -side top -pady 3 -in .right -fill both -expand 1
	}
    } else {
	pack forget .right
    }
    return

    if {$over && $nodes} {			;# Both on
	pack .over  -side top -pady 3 -in .right -fill x
	pack .nodes -side top -pady 3 -in .right -fill both -expand 1
    } elseif {$over} {				;# Just overview on
	pack .over  -side top -pady 3 -in .right -fill both -expand 1
    } elseif {$nodes} {				;# Just nodes on
	pack .nodes -side top -pady 3 -in .right -fill both -expand 1
    } else {					;# Both off
	pack forget .right
    }
}
##+##########################################################################
#
# ::Display::pos2canvas
#
# Converts from lat/lon into canvas coordinates.
# We use the ratio of map height in degrees and the image height.
#    who: root, zone, overview##
#    Requires: top, left, w, h, iw, ih
#
proc ::Display::pos2canvas {who lat lon {utmZone 0}} {
    variable coords
    global region

    if {$who eq "root" && $region(slippy) && [::Data::CanDo slippy]} {
     	return [::Display::_pos2slippy2canvas $lat $lon]
    }
    if {$who eq "root" && $region(matrix) ne {}} {
	return [::Matrix::pos2canvas $lat $lon]
    }
    if {$who eq "zoom"} {
	return [::Zoom::ll2canvas $lat $lon]
    }

    if {! [info exists coords($who,top)]} { return [list 0 0] }
    if {! [string match "overview*" $who]} {
	if {$region(UTM) && ! $utmZone} {	;# Lat/lon on a UTM map
	    set utm [::Data::ll2utm $lat $lon $region(UTMZONE)]
	    foreach {lat lon utmZone} $utm break
	}

	# ERROR: assumes utm zone of incoming matches region's zone
	if {$region(UTM) && $utmZone != $region(UTMZONE)} {
	    WARN "UTM zone mismatch!"
	    # Convert to lat/lon then convert back to utm but w/ correct zone
	    foreach {a b} [::Data::utm2ll $lat $lon $utmZone] break
	    set utm [::Data::ll2utm $a $b $region(UTMZONE)]
	    foreach {lat lon utmZone} $utm break
	}
    }

    set lat [expr {$lat - $coords($who,top)}]
    set cy [expr {$lat * $coords($who,ih) / $coords($who,h)}]

    set lon [expr {$lon - $coords($who,left)}]
    set cx [expr {round(1.0 * $lon * $coords($who,iw) / $coords($who,w))}]

    return [list $cx $cy]
}
##+##########################################################################
#
# ::Display::canvas2pos
#
# Converts a canvas position into deg, min, sec of latitude and longitude
# Only works on main window
#
proc ::Display::canvas2pos {x y {adjust 1}} {
    variable coords

    if {$adjust} {
	set x [.c canvasx $x]
	set y [.c canvasy $y]
    }
    if {$::region(matrix) ne {}} {
	lassign [::Matrix::canvas2pos $x $y] lat lon
    } else {
	if {$::region(slippy) && [::Data::CanDo slippy]} {
	    set ll [::Display::_canvas2slippy2pos $x $y]
	    foreach {lat lon} $ll break
	} else {

	    set lat [expr { (double($y) * $coords(root,h) / $coords(root,ih)) + \
				$coords(root,top) }]
	    set lon [expr { (double($x) * $coords(root,w) / $coords(root,iw)) + \
				$coords(root,left)}]
	    if {$::region(UTM)} {
		foreach {lat lon} [::Data::utm2ll $lat $lon $::region(UTMZONE)] break
	    }
	}
    }

    set lat2 [int2lat $lat]
    set lon2 [int2lat $lon]

    return [list $lat2 $lon2 $x $y $lat $lon]
}
##+##########################################################################
#
# ::Display::_pos2slippy2canvas -- computes canvas position
# on slippy based maps which are not linear
#
proc ::Display::_pos2slippy2canvas {lat lon} {
    lassign $::Display::coords(root,slippy,point) zoom y0 x0

    set geo [list $zoom $lat [expr {-abs($lon)}]]
    set pt [::map::kpv_slippy geo 2point $geo]
    lassign $pt . y1 x1

    set cx [expr {$x1-$x0}]
    set cy [expr {$y1-$y0}]
    return [list $cx $cy]
}
##+##########################################################################
#
# ::Display::_canvas2slippy2pos -- computes lat/lon from canvas position
# for slippy based maps
#
proc ::Display::_canvas2slippy2pos {cx cy} {
    lassign $::Display::coords(root,slippy,point) zoom y0 x0

    set x [expr {$x0 + $cx}]
    set y [expr {$y0 + $cy}]
    set pt [list $zoom $y $x]
    set geo [::map::kpv_slippy point 2geo $pt]
    lassign $geo . lat lon
    set lon [expr {abs($lon)}]
    return [list $lat $lon]
}
##+##########################################################################
#
# ::Display::BboxAll
#
# Computes the top, left corner and width, height of all the maps
# combined in this region. Used by the overview map.
#
proc ::Display::BboxAll {} {
    global map state region

    set maps $region($state(locale),maps)	;# List of maps

    # UTM CHECK NEEDED
    if {$region(UTM)} {
	foreach {top left z bottom right .} $map([lindex $maps 0]) break
	foreach mapname $maps {
	    foreach {n0 e0 . n1 e1 .} $map($mapname) break
	    if {$n0 > $top} {set top $n0}
	    if {$n1 < $bottom} {set bottom $n1}
	    if {$e0 < $left} {set left $e0}
	    if {$e1 > $right} {set right $e1}
	}
	foreach {top left} [::Data::utm2ll $top $left $z] break
	foreach {bottom right} [::Data::utm2ll $bottom $right $z] break
    } else {
	# Get first map data
	foreach who {top left bottom right} {d m s} $map([lindex $maps 0]) {
	    set $who [lat2int $d $m $s]
	}

	# Check every map for bigger bbox
	foreach mapname $maps {
	    foreach who {xtop xleft xbottom xright} {d m s} $map($mapname) {
		set $who [lat2int $d $m $s]
	    }
	    if {$xtop    > $top} {set top    $xtop}
	    if {$xbottom < $bottom} {set bottom $xbottom}
	    if {$xleft   > $left} {set left   $xleft}
	    if {$xright  < $right} {set right  $xright}
	}

	# Some maps are upside down
	if {$top < $bottom} {
	    foreach top $bottom bottom $top left $right right $left break
	}
    }

    # NB. ::Display::coords(zone,*) always in lat/lon coordinates
    set ::Display::coords(zone,top)    $top
    set ::Display::coords(zone,left)   $left
    set ::Display::coords(zone,bottom) $bottom
    set ::Display::coords(zone,right)  $right
    set ::Display::coords(zone,height) [expr {$bottom - $top}]
    set ::Display::coords(zone,width)  [expr {$right  - $left}]
}
##+##########################################################################
#
# PointMe -- debugging routine
#
proc PointMe {W x y} {
    set X [$W canvasx $x]
    set Y [$W canvasy $y]
    INFO "($x,$y) => ($X,$Y)"
    puts "($x,$y) => ($X,$Y)"
    lappend ::foo $X $Y
}
##+##########################################################################
#
# ::Display::MakeBox
#
# Returns the coordinates of a box around point xy
#
proc ::Display::MakeBox {xy delta} {

    foreach {x y} $xy break

    set x1 [expr {$x - $delta}]
    set y1 [expr {$y - $delta}]
    set x2 [expr {$x + $delta}]
    set y2 [expr {$y + $delta}]

    return [list $x1 $y1 $x2 $y2]
}
##+##########################################################################
#
# ::Display::MakeStar
#
# Returns the coordinates of a 5 pointed star around point xy
#
proc ::Display::MakeStar {xy delta} {
    foreach {x y} $xy break

    set pi [expr {atan(1) * 4}]

    # Compute delta to inner corner
    set x1 [expr {$delta * cos(54 * $pi/180)}]
    set y1 [expr {$delta * sin(54 * $pi/180)}]
    set XY [expr {hypot($x1, $y1)}]
    set y2 [expr {$delta * sin(18 * $pi/180)}]
    set delta2 [expr {$XY * $y2 / $y1}]

    # Now get all coordinates of the 5 outer and 5 inner points
    for {set i 0} {$i < 10} {incr i} {
	set d [expr {($i % 2) == 0 ? $delta : $delta2}]
	set theta [expr {(90 + 36 * $i) * $pi / 180}]
	set x1 [expr {$x + $d * cos($theta)}]
	set y1 [expr {$y - $d * sin($theta)}]

	lappend coords $x1 $y1
    }
    return $coords
}
##+##########################################################################
#
# ::Display::Embolden
#
# Returns the default font of a widget emboldened.
#
proc ::Display::Embolden {w} {
    array set f [font actual [lindex [$w configure -font] 3]]
    set f(-weight) bold
    return [array get f]
}
##+##########################################################################
#
# ::Display::PickRoad
#
# Called on a left click on a road or node.
#
proc ::Display::PickRoad {what who} {
    global state roads

    ::Balloon::Cancel
    ::Route::CheckRoute $what $who
}
##+##########################################################################
#
# ::Display::HighlightNode
#
# Toggles the highlighting of a node
#
proc ::Display::HighlightNode {lvl nodeid} {
    global state lb2nodeid

    if {$nodeid != -1} {
	set color $state(n,$lvl,color)
	.c itemconfig node_$nodeid -fill $color
    }

    # Now highlight every appropriate row in the node list listbox
    if {$lvl == 0} {set color {}}
    if {[info exists lb2nodeid(r,$nodeid)]} {
	if {[winfo ismapped .nodes.lb]} {
	    foreach lbid $lb2nodeid(r,$nodeid) {
		.nodes.lb itemconfig $lbid -bg $color
		if {$lvl == 3} {
		    .nodes.lb see $lbid
		}
	    }
	}
    }
}
##+##########################################################################
#
# ::Display::HighlightNode2
#
# Puts up a large marker around a node so its obvious this is the chosen node
#
proc ::Display::HighlightNode2 {xy} {
    global nodes

    if {! [winfo exists .c]} return
    .c delete special_node
    if {$xy != -1} {
	set xy [::Display::MakeBox $xy 30]
	.c create oval $xy -width 10 -fill {} -tag special_node
    }
}
##+##########################################################################
#
# ::Display::HighlightRoad
#
# Toggles the highlighting of a road and its two end nodes
#
proc ::Display::HighlightRoad {lvl rid {noEnd ""}} {
    global roads state

    if {$rid == -1} return
    if {! [info exists roads($rid)]} return

    foreach {id1 id2 . . . type} $roads($rid) break
    if {$noEnd eq ""} {
	::Display::HighlightNode $lvl $id1
	::Display::HighlightNode $lvl $id2
    }

    .c itemconfig road_$rid -fill $state(r,$lvl,$type,color) \
	-width $state(r,$lvl,$type,width)
    .c raise road_$rid roads
}
##+##########################################################################
#
# ::Display::ClearAllHighlighting -- gets rid of all highlighting
#
proc ::Display::ClearAllHighlighting {} {
    Busy 1
    ::Display::HighlightNode2 -1
    foreach nid $::region(node,visible) {
	::Display::HighlightNode 0 $nid
    }
    foreach rid $::region(road,visible) {
	::Display::HighlightRoad 0 $rid
    }
    ::Route::StatRoute 1
    .c delete debug
    Busy 0
}
##+##########################################################################
#
# ::Display::ButtonEnable
#
# The undo, clear, describe and profile buttons, which appear
# as buttons, menus and popups, get enabled and disabled
# depending on the length of the route.
#
# 0 disable, 1 enable
#
proc ::Display::ButtonEnable {num} {

    set state1 [expr {$num > 0 ? "normal" : "disabled"}]
    set state2 [expr {$num > 1 ? "normal" : "disabled"}]
    set state3D [expr {[::Data::CanDo 3d] ? $state2 : "disabled"}]

    .bbar.undo config -state $state1
    .m.edit entryconfig "Undo" -state $state1
    .popup entryconfig "Undo" -state $state1

    .bbar.clear config -state $state1
    .m.edit entryconfig "Clear" -state $state1
    .popup entryconfig "Clear Route" -state $state1

    .bbar.describe config -state $state2
    .m.route entryconfig "Describe Route" -state $state2
    .popup entryconfig "Describe Route" -state $state2

    .bbar.profile config -state $state2
    .m.route entryconfig "Profile Route" -state $state2
    .popup entryconfig "Profile Route" -state $state2

    .bbar.3dprofile config -state $state3D
    .m.route entryconfig "3D Profile" -state $state3D

    .bbar.google config -state $state2
    .m.route entryconfig "Google Earth" -state $state2

    .bbar.info config -state $state2
    .m.route entryconfig "Route Info" -state $state2

    .bbar.trace config -state $state2
    .m.route entryconfig "Trace Route" -state $state2
    catch { ${::Trace::W}.buttons.stop config -state $state2}

    .bbar.hills config -state $state2
    .m.route entryconfig "Hills" -state $state2

    .m.route entryconfig "Add to Ride Log..." -state $state2

    .m.route entryconfig "Email Route" -state $state2

    .m.route entryconfig "Annotate Route" -state $state2

    .m.route entryconfig "Zoom Route" -state $state2
}
##+##########################################################################
#
# ::Display::LocateNode
#
# Makes sure a given node is visible, then highlights that node
#
proc ::Display::LocateNode {{nid -1}} {
    global lb2nodeid				;# Set up by NodeList

    if {$nid == -1} {
	set lbid [.nodes.lb curselection]	;# Which item is clicked
	if {! [info exists lb2nodeid($lbid)]} return
	set nid $lb2nodeid($lbid)		;# This is the node we want
    }
    set xy [::Display::ToCenter $nid]
    ::Display::HighlightNode2 $xy
    raise .
}
proc ::Display::LocateRoad {rid} {
    foreach {id1 id2} $::roads($rid) break
    ::Route::ClearRoute
    ::Route::CheckRoute node $id1
    ::Route::CheckRoute road $rid
    ::Display::LocateNode $id1
}
##+##########################################################################
#
# ::Display::CenterWindow
#
# Centers window $w in the canvas. If the canvas is not yet mapped, then
# we guess at it size.
#
proc ::Display::CenterWindow {w {W .}} {
    update idletasks				;# Need to get geometry correct
    set wh [winfo reqheight $w]	       ; set ww [winfo reqwidth $w]
    if {[winfo viewable $W]} {
	set sw [winfo width $W]	       ; set sh [winfo height $W]
	set sy [winfo y $W]	       ; set sx [winfo x $W]
    } else {
	set sw $::state(cw)	       ; set sh $::state(ch)
	set sy 2		       ; set sx 2
    }
    set x [expr {$sx + ($sw - $ww)/2}] ; set y [expr {$sy + ($sh - $wh)/2}]
    if {$x < 0} { set x 0 }	       ; if {$y < 0} {set y 0}

    wm geometry $w +$x+$y
}
proc ::Display::LeftWindow {w {W .}} {
    update idletasks
    set geom "+10+10"
    regexp {[+-].*$} [wm geom $W] geom
    wm geom $w $geom
}
##+##########################################################################
#
# ::Display::RightWindow -- Positions window on right edge of the main window
#
proc ::Display::RightWindow {w {W .}} {
    update idletasks

    set W [winfo toplevel $W]
    set y [expr {3 + [winfo y $W]}]		 ;# Top of main window
    set x [expr {15 + [winfo x $W] + [winfo width $W]}] ;# Right side

    set right [expr {$x + [winfo reqwidth $w]}]
    if {$right > [winfo screenwidth $W] + 20} {
	wm geom $w -0+$y
    } else {
	wm geom $w +$x+$y
    }
}
##+##########################################################################
#
# ::Display::MakeDialogbox -- creates template dialog box. After we're done
# the caller fills in $top.icon, $top.body and $top.buttons.
#
proc ::Display::MakeDialogBox {W wtitle title icon {padx 10}} {

    set WF $W.ftitle
    set WT $W.title
    set WT2 $W.title2
    set WB $W.body
    set WBTN $W.buttons

    destroy $W
    toplevel $W -bd 2 -relief ridge
    ::Display::TileBGFix $W
    wm withdraw $W
    wm title $W $wtitle
    wm transient $W .
    wm resizable $W 0 0

    if {$icon eq ""} {
	set iwidget $W.c
	canvas $iwidget -width 100 -height 100 -highlightthickness 0
	::Display::TileBGFix $iwidget
    } else {
	set iwidget $W.icon
	foreach {img fname} $icon break
	::Display::MakeImage $img $fname
	set w [image width $img]
	set h [image height $img]
	if {$w < 100} {set w 100}
	if {$h < 100} {set h 100}
	::my::label $iwidget -anchor n -image $img ;#-width $w -height $h
    }
    ::my::frame $WF -borderwidth 2 -relief sunken

    # See if title needs to go on two lines
    set rest ""
    regexp {^(.*?)\n(.*?)$} $title => title rest
    ::my::label $WT -text $title -borderwidth 0 -font boldFont -anchor c
    ::my::label $WT2 -text $rest -borderwidth 0 -anchor c -justify c

    if {[string length $title] < 20} { $WT config -width 20 }
    ::my::frame $WBTN -borderwidth 2 -relief ridge
    ::my::frame $WB -pad 15

    grid rowconfigure $W 0 -minsize 10
    grid $iwidget $WF - -row 1 -sticky new -ipadx 2
    grid  ^	   $WB x -sticky news
    grid $WBTN - - -sticky news
    grid config $iwidget -padx 5

    grid rowconfigure $W 2 -weight 1
    grid columnconfigure $W 1 -weight 1
    grid columnconfigure $W 2 -minsize $padx
    grid config $WF -padx {0 5}

    pack $WT $WT2 -in $WF -fill both -expand 1
    if {$rest eq ""} {pack forget $WT2}
}
##+##########################################################################
#
# ::Display::MakeNeededImages -- creates a bitmap in the shape of a star
#
proc ::Display::MakeNeededImages {} {
    if {[lsearch [image names] ::img::star] == -1} {
	image create bitmap ::img::star -data {
	    #define plus_width	11
	    #define plus_height 9
	    static char plus_bits[] = {
		0x00,0x00, 0x24,0x01, 0xa8,0x00, 0x70,0x00, 0xfc,0x01,
		0x70,0x00, 0xa8,0x00, 0x24,0x01, 0x00,0x00 }
	}
    }
    if {[lsearch [image names] ::img::star2] == -1} {
	image create bitmap ::img::star2 -data {
	    #define plus_width	7
	    #define plus_height 7
	    static char plus_bits[] = {
		0x49, 0x2a, 0x1c, 0x7f, 0x1c, 0x2a, 0x49}
	}
    }
    if {[lsearch [image names] ::img::chi] == -1} {
	image create bitmap ::img::chi -data {
	    #define x_width 7
	    #define x_height 7
	    static char x_bits = {
		0x63, 0x77, 0x3e, 0x1c, 0x3e, 0x77, 0x63
	    }
	}
    }
    if {[lsearch [image names] ::img::blank] == -1} {
	image create photo ::img::blank
    }
    ::Display::MakeImage ::img::go go.gif
    ::Display::MakeImage ::img::end end.gif
    ::Display::MakeImage ::img::endgo endgo.gif
}
##+##########################################################################
#
# ::Display::Raise -- makes sure everything on the canvas is in the right
# stacking order
#
proc ::Display::Raise {} {
    .c raise roads
    .c raise trk
    .c raise trkpt
    .c raise photo
    .c raise nodes
    .c raise poi
    .c raise geo
    .c raise wpt
    .c raise hill
    catch {.c raise nodes hill}
    .c raise milepost
    .c raise postit
    .c raise arrow
    .c raise BOX
    .c lower dash
}
##+##########################################################################
#
# ::Display::MakeProgressBar -- creates and places progressbar toplevel
#
proc ::Display::MakeProgressBar {master title {deiconify 1} {msgs 0}} {
    set W .pbar
    destroy $W
    toplevel $W
    wm withdraw $W
    wm title $W "$::state(progname) Status"
    wm transient $W $master
    catch {wm attributes $W -toolwindow 1}

    ::tk::label $W.title -text $title -font boldFont -anchor w

    canvas $W.c -width 300 -height 20 -bg yellow -bd 2 -relief solid
    $W.c create text 150 13 -text "0%" -tag percent -font boldFont

    pack $W.title -side top -fill x -pady 5 -padx 5
    pack $W.c -side top -fill both -expand 1 -pady 5 -padx 5
    if {$msgs} {
	canvas $W.msg -width 300 -height 20 -bd 0
	$W.msg create text 6 13 -tag txt -font boldFont -anchor w
	pack $W.msg -side bottom -fill both -expand 1 -pady {0 5} -padx 5
    }

    ::Display::CenterWindow $W $master
    if {$deiconify} {
	wm deiconify $W
    }
    update
    return $W
}
##+##########################################################################
#
# ::Display::DoProgressBar -- draws progress bar in best progress window
#  if no values are given, it works with one more than the last values given
#
proc ::Display::DoProgressBar {{num -1} {max -1}} {
    global state

    foreach w [list .pbar.c .splash.msg .b.msg] { ;# Where to draw bar
	if {[winfo exists $w]} break
    }
    if {! [winfo exists $w]} return
    $w delete progress
    if {$max == 0} {
	if {[winfo toplevel $w] ne "."} { destroy [winfo toplevel $w] }
	return
    }

    if {$num != -1} {				;# Num and max given
	set state(pbar,num) $num
	set state(pbar,max) $max
    } else {					;# Num and max not given
	set num [incr state(pbar,num)]
	set max $state(pbar,max)
    }
    if {$num > $max} {set num $max}

    set width  [winfo width $w]
    set height [winfo height $w]
    set x [expr {$num * $width / double($max)}]
    set perc [expr {round(100.0 * $num / $max)}]

    set clr cyan
    set clr [::Display::GetProgressColor $perc]
    #set clr [eval ::Display::GetProgressColor $perc $::myColors]
    $w create rect 0 0 $x $height -tag progress -fill $clr -outline $clr
    $w lower progress
    $w itemconfig percent -text "$perc%"
    update
}
##+##########################################################################
#
# ::Display::GetProgressColor -- returns a color based on morphing between
# multiple colors
#
proc ::Display::GetProgressColor {perc} {
    variable pColors

    set clr1 [lindex $pColors 0]
    set colors [lrange $pColors 1 end]
    set bar [expr {100.0 / [llength $colors]}]
    set cnt 0
    foreach clr2 $colors {
	set high [expr {$bar * [incr cnt]}]
	if {$perc <= $high} break
	set clr1 $clr2
    }
    set perc2 [expr {($perc - $high + $bar) / $bar}]

    # Color intensities are from 0 to 65535, 2 byte colors.
    foreach {r1 g1 b1} [winfo rgb . $clr1] break
    foreach {r2 g2 b2} [winfo rgb . $clr2] break

    # Normalize intensities to 0 to 255, 1 byte colors.
    foreach el {r1 g1 b1 r2 g2 b2} {
	set $el [expr {[set $el] * 255 / 65535}].0
    }

    set r [expr {int($r1 + ($r2 - $r1) * $perc2)}]
    set g [expr {int($g1 + ($g2 - $g1) * $perc2)}]
    set b [expr {int($b1 + ($b2 - $b1) * $perc2)}]
    return [format "#%02X%02X%02X" $r $g $b]
}
##+##########################################################################
#
# ::Display::MyComboBox -- puts up either a tile combobox or tk_optionMenu
#
proc ::Display::MyComboBox {w varName firstValue args} {

    if {[info commands ::ttk::combobox] eq ""} {
	return [eval tk_optionMenu $w $varName [list $firstValue] $args]
    }

    upvar #0 $varName var

    if {![info exists var]} {
	set var $firstValue
    }
    set values [concat $firstValue $args]
    set maxLen 5
    foreach value $values {
	set len [string length $value]
	if {$len > $maxLen} {set maxLen $len}
    }
    ::ttk::combobox $w -textvariable $varName -state readonly \
	-values $values -width [expr {$maxLen+2}] \
	-exportselection 0 -takefocus 0 \
	;# -selectbackground white -selectborderwidth 0
    return $w
}
##+##########################################################################
#
# ::Display::optionMenu -- like tk_optionMenu but using tile if present
#
proc ::Display::optionMenu { w varName firstValue args } {
    upvar #0 $varName var

    if {![info exists var]} {
	set var $firstValue
    }
    ::ttk::menubutton $w -textvariable $varName -menu $w.menu -direction flush
    menu $w.menu -tearoff 0
    $w.menu add radiobutton -label $firstValue -variable $varName
    foreach i $args {
	$w.menu add radiobutton -label $i -variable $varName
    }
    return $w.menu
}
##+##########################################################################
#
# ::Display::ToCenter
#
# Scrolls the window so that a specified node is in the center
# of the screen. Returns canvas x,y for convenience
#
proc ::Display::ToCenter {id} {
    global nodes poi photos

    set nid [::Edit::FindNode $id]
    if {[info exists nodes($nid)]} {
	foreach {x y} [lindex $nodes($nid) 4] break
    } elseif {[info exists poi($id)]} {
	foreach {x y} [lindex $poi($id) 6] break
    } elseif {[info exists photos($id)]} {
	foreach {lat lon} $photos($id) break
	foreach {x y} [::Display::pos2canvas root $lat $lon] break
    } elseif {[info exists ::GPS::wpts($id)]} {
	foreach {lat lon} $::GPS::wpts($id) break
	foreach {x y} [::Display::pos2canvas root $lat $lon] break
    } elseif {[llength $id] == 2} {
	foreach {x y} $id break
    } else {return [list 0 0]}

    if {! [::Display::IsVisible $x $y]} {
	::Display::ToCenter2 $x $y
    }
    return [list $x $y]
}
proc ::Display::ToCenter2 {x y} {
    foreach {l t r b} [.c cget -scrollregion] break

    set cw [winfo width .c]
    set ch [winfo height .c]

    set xview [expr {(($x - $cw/2.0) - $l) / ($r - $l)}]
    set yview [expr {(($y - $ch/2.0) - $t) / ($b - $t)}]

    .c xview moveto $xview
    .c yview moveto $yview
}
proc ::Display::IsVisibleID {id} {
    global nodes roads poi

    set nid [::Edit::FindNode $id]
    if {[info exists nodes($nid)]} {
	foreach {x y} [lindex $nodes($nid) 4] break
    } elseif {[info exists poi($id)]} {
	foreach {x y} [lindex $poi($id) 6] break
    } elseif {[info exists ::GPS::wpts($id)]} {
	foreach {lat lon} $::GPS::wpts($id) break
	foreach {x y} [::Display::pos2canvas root $lat $lon] break
    } elseif {[info exists roads($id)]} {
	foreach {id1 id2} $roads($id) break
	if {[::Display::IsVisibleID $id1] || [::Display::IsVisibleID $id2]} {
	    return 1
	}
	return 0
    } else {return 0}

    return [::Display::IsVisible $x $y]
}
##+##########################################################################
#
# ::Display::IsVisible
#
# Computes if a given (x,y) is visible on the screen.
#
proc ::Display::IsVisible {x y} {
    foreach {l t r b} [::Display::GetScreenRect] break

    if {$x < $l || $x > $r || $y < $t || $y > $b} {
	return 0
    }
    return 1
}
##+##########################################################################
#
# ::Display::GetScreenRect
#
# Returns the coordinates of the visible part of the canvas
#
proc ::Display::GetScreenRect {{w .c}} {

    set scroll [$w cget -scrollregion]
    if {$scroll eq ""} { set scroll [$w bbox all] }
    foreach {sl st sr sb} $scroll break

    set sw [expr {$sr - $sl}]			;# Scroll width
    set sh [expr {$sb - $st}]			;# Scroll height

    # Get canvas info (could have used scrollbar for this)
    foreach {xl xr} [$w xview] break
    foreach {yt yb} [$w yview] break

    set l [expr {round($sl + $xl * $sw)}]
    set r [expr {round($sl + $xr * $sw)}]
    set t [expr {round($st + $yt * $sh)}]
    set b [expr {round($st + $yb * $sh)}]

    set width [expr {$r - $l}]
    set height [expr {$b - $t}]

    return [list $l $t $r $b $width $height]
}
##+##########################################################################
#
# ::Display::BestFit -- Scrolls screen to best fit the route onto the screen.
# The start node has to be visible, along with centroid if possible.
#
proc ::Display::BestFit {} {

    if {$::route(nodes) eq {}} return
    foreach {l t r b} [::Route::GetBBox] break
    foreach {sx sy} [lindex $::nodes([lindex $::route(nodes) 0]) 4] break

    set cw [winfo width .c]			;# Canvas size
    set ch [winfo height .c]
    set ox [expr {($r+$l)/2}]			;# Center of bbox
    set oy [expr {($t+$b)/2}]
    set bw [expr {$r - $l}]			;# Bbox size
    set bh [expr {$b - $t}]

    if {$bw <= $cw && $bh <= $ch} {		;# Fits onto screen
	if {! [::Display::IsVisible $l $t] || ! [::Display::IsVisible $r $b]} {
	    ::Display::ToCenter2 $ox $oy
	}
	return
    }

    # Adjust center point so that start point is also visible
    if {abs($sx - $ox) > $cw/2} {
	if {$sx < $ox} {
	    set ox [expr {$sx + ($cw/2 - 100)}]	;# Too far left
	} else {
	    set ox [expr {$sx - ($cw/2 - 100)}]	;# Too far right
	}
    }
    if {abs($sy - $oy) > $ch/2} {
	if {$sy < $oy} {
	    set oy [expr {$sy + ($ch/2 - 100)}]
	} else {
	    set oy [expr {$sy - ($ch/2 - 100)}]
	}
    }

    if {! [::Display::IsVisible $sx $sy] || ! [::Display::IsVisible $ox $oy]} {
	::Display::ToCenter2 $ox $oy
    }
}
##+##########################################################################
#
# ::Display::Canvas2Screen -- returns screen coords for a canvas point
#
proc ::Display::Canvas2Screen {x y} {
    foreach {x0 y0 x1 y1 w h} [::Display::GetScreenRect] break

    set sx [expr {round([winfo width .c] * ($x - $x0) / double($w))}]
    set sy [expr {round([winfo height .c] * ($y - $y0) / double($h))}]
    return [list $sx $sy]
}
##+##########################################################################
#
# ::Display::GridChildren -- grids all children of $W either centered or right
#  Right == 2 special case
#
proc ::Display::GridChildren {W {right 0}} {
    set children [winfo children $W]
    if {[llength $children] == 1 && $right < 2} {set right 0}

    if {! $right} {
	eval grid x [join $children " x "] x -sticky news -pady 10

	grid columnconfig $W 0 -weight 1
	set col 0
	foreach child $children {
	    grid columnconfig $W [incr col] -uniform a
	    grid columnconfig $W [incr col] -weight 1
	}
    } else {
	eval grid x $children -sticky news -pady 10 -padx 5
	grid columnconfig $W 0 -weight 1
	set col 0
	foreach child $children {
	    grid columnconfig $W [incr col] -uniform a
	}
    }
}
proc ::Display::GridChildren2Lines {W} {
    set children [winfo children $W]
    set len [llength $children]

    set row 0
    set col 1
    foreach child $children {
	grid $child -pady 5 -row $row -column $col -sticky ew
	if {[incr col 2] > $len} {
	    set col 1
	    incr row
	}
    }
    for {set i 0} {$i <= $len} {incr i} {
	set n [expr {($i+1) & 1}]
	grid columnconfigure $W $i -uniform $n -weight $n
    }
}
##+##########################################################################
#
# ::Display::HighlightManyRoads -- highlights many roads with given color
#
proc ::Display::HighlightManyRoads {lvl color who} {
    if {$who eq {}} return

    ;# Put in our own highlight color
    if {[array names ::state r,$lvl,*,color] eq {}} {
	foreach a [array names ::state r,0,*,color] {
	    foreach {. . idx .} [split $a ","] break
	    set ::state(r,$lvl,$idx,color) $color
	}
	foreach b [array names ::state r,0,*,width] {
	    foreach {. . idx . } [split $b ","] break
	    set ::state(r,$lvl,$idx,width) 5
	}
	set ::state(n,$lvl,color) $color
    }
    ::Route::ClearRoute

    foreach rid $who {
	::Display::HighlightRoad $lvl $rid
    }
}
##+##########################################################################
#
# ::Display::HighlightMissingData -- highlights all roads with bad data
#   red:     elevation or distance
#   magenta: name
#   cyan:    unbent
#
proc ::Display::HighlightMissingData {} {
    global roads region zone
    global bad

    unset -nocomplain bad

    set bad(data) {}
    set bad(unbent) {}
    set bad(names) {}
    foreach rid [lsort -dictionary $region(road,visible)] {
	foreach {id1 id2 north distance south . name . xy . quality} \
	    $roads($rid) break

	# zone(goodData) -- see ::Data::ProcessOneRoad
	if {$quality > $zone(goodData) &&
	    ([::BadMath::IsBad $north] || [::BadMath::IsBad $distance]
		  || [::BadMath::IsBad $south])} {
	    lappend bad(data) $rid
	} elseif {$xy eq {}} {
	    lappend bad(unbent) $rid
	} elseif {$name eq ""} {
	    lappend bad(names) $rid
	}

    }
    ::Display::ClearAllHighlighting
    puts ""
    foreach {who clr} {data red unbent cyan names magenta} {
	set len [llength $bad($who)]
	if {$len == 0} {
	    unset bad($who)
	    continue
	}
	::Display::HighlightManyRoads bad_$who $clr $bad($who)
	puts "$who ($clr): [llength $bad($who)] : $bad($who)"
    }
}
proc ::Display::HighlightMissingElev {{who ""}} {
    global roads region route bad

    unset -nocomplain bad

    set bad(noXY) {}
    set bad(noZ_old) {}
    set bad(noZ) {}
    set bad(missingZ) {}
    set bad(zeroZ) {}
    set bad(minusZ) {}
    set rids [expr {$who eq "all" ? [array names roads] : $region(road,visible)}]
    if {$who eq "route"} { set rids $route(roads) }
    foreach rid [lsort -dictionary $rids] {
	foreach {. . . . . . . . xy z q survey} $roads($rid) break
	if {[llength $xy] == 0} {
	    lappend bad(noXY) $rid
	} elseif {[llength $z] == 0} {
	    if {$survey eq "zoom"} {
		lappend bad(noZ) $rid
	    } else {
		lappend bad(noZ_old) $rid
	    }
	} elseif {[lsearch -exact $z "?"] > -1} {
	    lappend bad(missingZ) $rid
	} elseif {[lsearch -exact $z "0"] > -1} {
	    lappend bad(zeroZ) $rid
	} elseif {[lsearch -glob $z "-*"] > -1} {
	    lappend bad(minusZ) $rid
	}
    }
    ::Display::ClearAllHighlighting
    puts ""
    foreach {who clr} {noXY red noZ_old cyan noZ magenta missingZ green zeroZ chocolate minusZ deeppink2} {
	set len [llength $bad($who)]
	if {$len == 0} {
	    unset bad($who)
	    continue
	}
	::Display::HighlightManyRoads bad_$who $clr $bad($who)
	puts "[format {%-10s %-12s : %-3s } $who $clr ($len)] $bad($who)"
    }
}
##+##########################################################################
#
# ::Display::MakeShadowPhoto -- creates a new image with a shadow border
#
proc ::Display::MakeShadowPhoto {img fname bg} {
    ::Display::_MakeBorderImages $bg
    set imgTemp [image create photo -file $fname]
    set w [image width $imgTemp]
    set h [image height $imgTemp]

    set w1 [expr {$w + 25}]
    set w2 [expr {$w + 50}]
    set h1 [expr {$h + 25}]
    set h2 [expr {$h + 50}]

    image create photo $img -width $w2 -height $h2
    $img copy ::img::border::TL
    $img copy ::img::border::T -to 25 0 $w1 25
    $img copy ::img::border::TR -to $w1 0
    $img copy ::img::border::L -to 0 25 25 $h1
    $img copy ::img::border::R -to $w1 25 $w2 $h1
    $img copy ::img::border::BL -to 0 $h1
    $img copy ::img::border::B -to 25 $h1 $w1 $h2
    $img copy ::img::border::BR -to $w1 $h1
    $img copy $imgTemp -to 25 25

    image delete $imgTemp
    if {$bg ne "white"} {
	foreach img [info commands ::img::border::*] {
	    image delete $img
	}
    }
    return $img
}
##+##########################################################################
#
# ::Display::_MakeBorderImages -- makes 8 images which form the shadow
# gradient for the four sides and four corners.
#
proc ::Display::_MakeBorderImages {bg} {
    if {[info commands ::img::border::T] ne ""} {
	if {$bg eq "white"} return
	foreach img [info commands ::img::border::*] {
	    image delete $img
	}
    }

    set gradient {white white white white white \#8d8d8d \#999999
	\#a6a6a6 \#b2b2b2 \#bebebe \#c8c8c8 \#d0d0d0 \#dadada \#e2e2e2 \#e8e8e8
	\#eeeeee \#f2f2f2 \#f7f7f7 \#fcfcfc \#fdfdfd \#fdfdfd \#ffffff \#ffffff
	\#ffffff \#ffffff \#ffffff \#ffffff \#ffffff \#ffffff \#ffffff \#ffffff
	\#ffffff \#ffffff \#ffffff \#ffffff \#ffffff \#ffffff \#ffffff \#ffffff}
    if {$bg ne "white"} {
	set gradient [::Display::_MungGradient $bg $gradient]
    }

    image create photo ::img::border::T -width 1 -height 25
    image create photo ::img::border::B -width 1 -height 25
    image create photo ::img::border::L -width 25 -height 1
    image create photo ::img::border::R -width 25 -height 1
    image create photo ::img::border::TR -width 25 -height 25
    image create photo ::img::border::TL -width 25 -height 25
    image create photo ::img::border::BR -width 25 -height 25
    image create photo ::img::border::BL -width 25 -height 25

    # Build two sides and a corner by hand
    for {set x 0} {$x < 25} {incr x} {
	::img::border::B put [lindex $gradient $x] -to 0 $x
	::img::border::R put [lindex $gradient $x] -to $x 0

	for {set y 0} {$y < 25} {incr y} {
	    set idx [expr {$x<5&& $y<5 ? 0 : round(hypot($x,$y))}]
	    ::img::border::BR put [lindex $gradient $idx] -to $x $y
	}
    }

    # Use image copy to get the other pieces
    ::img::border::TL copy ::img::border::BR -subsample -1 -1
    ::img::border::TR copy ::img::border::BR -subsample 1 -1
    ::img::border::BL copy ::img::border::BR -subsample -1 1

    ::img::border::L copy ::img::border::R -subsample -1 1
    ::img::border::T copy ::img::border::B -subsample 1 -1
}
proc ::Display::_MungGradient {bg gradient} {
    set new {}

    foreach {R G B} [winfo rgb . $bg] break

    foreach clr $gradient {
	if {[string match \#* $clr]} {
	    foreach {r g b} [winfo rgb . $clr] break
	    set r2 [expr {($R/256)*$r/65535}]
	    set g2 [expr {($G/256)*$g/65535}]
	    set b2 [expr {($B/256)*$b/65535}]
	    set r3 [expr {$r2 > 255 ? 255 : $r2}]
	    set g3 [expr {$g2 > 255 ? 255 : $g2}]
	    set b3 [expr {$b2 > 255 ? 255 : $b2}]
	    set clr [format "\#%02x%02x%02x" $r3 $g3 $b3]
	}
	lappend new $clr
    }
    return $new
}

##+##########################################################################
#
# ::Display::MakeImage -- creates an image if it doesn't exists yet
#
proc ::Display::MakeImage {iname fname} {
    if {[lsearch [image names] $iname] == -1} {
	if {$fname eq ""} {
	    image create photo $iname
	} else {
	    set fname [eval file join [list $::state(idir)] [list $fname]]
	    image create photo $iname -file $fname
	}
    }
}
##+##########################################################################
#
# ::Display::AddCopyright -- adds our copyright notice to an image
# See also ::Snapshot::_AddCopyright
#
proc ::Display::AddCopyright {img} {
    ::Display::MakeImage ::img::copyright copyright.gif

    set w1 [image width $img]
    set h1 [image height $img]
    set w2 [image width ::img::copyright]
    set h2 [image height ::img::copyright]

    if {$w1 < $w2} {				;# Not enough room
	set w $w1
	set h $h1
    } else {
	set w [expr {$w1 > $w2 ? $w1 : $w2}]
	set h [expr {$h1 + $h2}]
    }

    image create photo ::img::merge -width $w -height $h
    ::img::merge copy $img -from 0 0 1 1 -to 0 0 $w $h ;# Background color
    ::img::merge copy ::img::copyright -to [expr {$w-$w2}] [expr {$h-$h2}]
    ::img::merge copy $img -to 0 0

    return ::img::merge
}
##+##########################################################################
#
# ::Display::AnimateImage -- replaces a label's image with an
# animated biker image
#
proc ::Display::AnimateImage {w} {
    if {! [::Data::CanDo anigif]} { return 0 }

    $w config -width 0 -height 0
    ::anigif::anigif [file join $::state(idir) roadie.gif] $w
}
proc ::Display::MakeLetter {ch} {
    variable ALPHA				;# Alphabet images

    if {! [info exists ALPHA($ch)]} { set ch 63 }
    set iname "::img::rot::$ch"
    if {[lsearch [image names] $iname] == -1} {
	image create photo $iname -data $ALPHA($ch)
	::Display::Whiten $iname
    }
    return $iname
}
##+##########################################################################
#
# ::Display::Whiten -- our rotated font appears to be
# completely black when [$img data], so we replace all
# transparent bits with white
#
proc ::Display::Whiten {img} {
    return

    set w [image width $img]
    set h [image height $img]
    for {set row 0} {$row < $h} {incr row} {
	set row1 [expr {$row + 1}]
	for {set col 0} {$col < $w} {incr col} {
	    set col1 [expr {$col + 1}]
	    set t [$img transparency get $col $row]
	    if {$t} {
		$img put white -to $col $row $col1 $row1
		$img transparency set $col $row 1
	    }
	}
    }
}

proc ::Display::RotateTextImage2 {img txt wlen} {
    if {[lsearch [image names] $img] != -1} {return $img}

    set line {}
    set lines {}
    set maxLen -1

    regsub -all {\s+} $txt " " txt
    for {set i 0} {$i < [string length $txt]} {incr i} {
	set ch [string index $txt $i]

	set oline $line
	append line $ch
	set len [::Display::RotateFontMeasure $line]

	if {$len < $wlen} continue
	set n [regexp {^(.*) (.*)$} $oline => pre post]
	if {! $n} {
	    set pre $oline
	    set post ""
	}
	lappend lines [string trim $pre]
	set line [string trim "$post$ch"]
	set len [::Display::RotateFontMeasure [lindex $lines end]]
	if {$len > $maxLen} {set maxLen $len}
    }
    if {$line ne ""} {
	lappend lines $line
	set len [::Display::RotateFontMeasure [lindex $lines end]]
	if {$len > $maxLen} {set maxLen $len}
    }

    set lineHeight 13
    set x [expr {$lineHeight * [llength $lines]}]
    image create photo $img -width $x -height $maxLen

    # For PDF which can't handle black transparent pixels
    $img put white -to 0 0 $x $maxLen
    for {set row 0} {$row < $maxLen} {incr row} {
	for {set col 0} {$col < $x} {incr col} {
	    $img transparency set $col $row 1
	}
    }

    foreach line $lines {
	incr x -$lineHeight
	set y 0
	foreach ch [split $line ""] {
	    scan $ch %c ch
	    $img copy ::img::rot::$ch -to $x $y
	    incr y [image height ::img::rot::$ch]
	}
    }
    return $img
}
proc ::Display::RotateFontMeasure {txt} {
    variable ALPHA

    set h 0
    foreach ch [split $txt ""] {
	scan $ch %c ch
	if {! [info exists ALPHA($ch)]} { set ch 63 }

	set iname [::Display::MakeLetter $ch]
	set ih [image height $iname]

	incr h $ih
    }
    return $h
}
##+##########################################################################
#
# ::Display::KillChildren -- kills all toplevels except the main window
# and the splash window.
#
proc ::Display::KillChildren {} {
    foreach w [winfo child .] {
	if {[winfo class $w] eq "Toplevel" && $w ne ".splash"} {
	    eval [wm protocol $w WM_DELETE_WINDOW] ;# Do any cleanup
	    destroy $w
	}
    }
}
##+##########################################################################
#
# ::Display::RegularPolygon -- Returns x,y coordinate list for an n-sided
# polygon with start and extent parameters.
#
proc ::Display::RegularPolygon {xy args} {
    foreach {x0 y0 x1 y1} $xy break
    array set V {-sides 0 -start 90 -extent 360} ;# Default values
    foreach {a value} $args {
	if {! [info exists V($a)]} {error "unknown option $a"}
	if {$value == {}} {error "value of \"$a\" missing"}
	set V($a) $value
    }
    if {$V(-extent) == 0} {return {}}

    set xm [expr {($x0+$x1)/2.}]
    set ym [expr {($y0+$y1)/2.}]
    set rx [expr {$xm-$x0}]
    set ry [expr {$ym-$y0}]

    set n $V(-sides)
    if {$n == 0} {                              ;# 0 sides => circle
	set n [expr {round(($rx+$ry)*0.5)}]
	if {$n < 2} {set n 4}
    }

    set dir [expr {$V(-extent) < 0 ? -1 : 1}]   ;# Extent can be negative
    if {abs($V(-extent)) > 360} {
	set V(-extent) [expr {$dir * (abs($V(-extent)) % 360)}]
    }
    set step [expr {$dir * 360.0 / $n}]
    set numsteps [expr {1 + double($V(-extent)) / $step}]

    set xy {}
    set DEG2RAD [expr {4*atan(1)*2/360}]

    for {set i 0} {$i < int($numsteps)} {incr i} {
	set rad [expr {($V(-start) - $i * $step) * $DEG2RAD}]
	set x [expr {$rx*cos($rad)}]
	set y [expr {$ry*sin($rad)}]
	lappend xy [expr {$xm + $x}] [expr {$ym - $y}]
    }

    # Figure out where last segment should end
    if {$numsteps != int($numsteps)} {
	# Vecter V1 is last drawn vertext (x,y) from above
	# Vector V2 is the edge of the polygon
	set rad2 [expr {($V(-start) - int($numsteps) * $step) * $DEG2RAD}]
	set x2 [expr {$rx*cos($rad2) - $x}]
	set y2 [expr {$ry*sin($rad2) - $y}]

	# Vector V3 is unit vector in direction we end at
	set rad3 [expr {($V(-start) - $V(-extent)) * $DEG2RAD}]
	set x3 [expr {cos($rad3)}]
	set y3 [expr {sin($rad3)}]

	# Find where V3 crosses V1+V2 => find j s.t.  V1 + kV2 = jV3
	set j [expr {($x*$y2 - $x2*$y) / ($x3*$y2 - $x2*$y3)}]

	lappend xy [expr {$xm + $j * $x3}] [expr {$ym - $j * $y3}]
    }
    return $xy
}
##+##########################################################################
#
# ::Display::PrettyNodeText -- Returns nice text string of the node
#
proc ::Display::PrettyNodeText {nid} {
    set txt [lindex $::nodes($nid) 0]
    if {$txt eq ""} {
	set txt "Node [::Edit::PrettyNode $nid]"
    }
    return $txt
}
##+##########################################################################
#
# ::Display::PrettyLat -- returns lat/lon info in a pretty format
#  lat lon
#  {lat1 lat2 lat3} {lon1 lon2 lon3}
#  lat1 lat2 lat3 lon1 lon2 lon3
#
proc ::Display::PrettyLat {args} {
    if {[llength $args] == 2} {
	foreach {lat lon} $args break
	if {[llength $lat] == 1} {
	    set lat [int2lat $lat]
	    set lon [int2lat $lon]
	}
	foreach {lat1 lat2 lat3} $lat break
	foreach {lon1 lon2 lon3} $lon break
    } else {
	foreach {lat1 lat2 lat3 lon1 lon2 lon3} $args break
    }
    set lat "$lat1\xB0 $lat2' $lat3\x22 N"
    set lon "$lon1\xB0 $lon2' $lon3\x22 W"

    return [list $lat $lon]
}
##+##########################################################################
#
# ::Display::PrettyList -- Returns prettier list for reading
#
proc ::Display::PrettyList {l {and "and"}} {
    if {[llength $l] < 2} { return $l }
    set result "[join [lrange $l 0 end-1] ", "] $and [lindex $l end]"
    return $result
}
##+##########################################################################
#
# ::Display::TileBGFix -- non-tile widgets need to pick up the themed background
#
proc ::Display::TileBGFix {w} {
    $w config -bg [::ttk::style lookup . -background]
    bind $w <<ThemeChanged>> "$w config -bg \[::ttk::style lookup . -background]"
}
##+##########################################################################
#
# ::Display::RoundRectXY -- Returns coordinate list for rounded rectangle
#
proc ::Display::RoundRectXY {x0 y0 x3 y3 radius} {

    set r [winfo pixels . $radius]
    set d [expr {2 * $r}]

    # Make sure that the radius of the curve is less than 3/8
    # size of the box!

    set maxr 0.75

    if { $d > $maxr * ($x3 - $x0) } {
        set d [expr { $maxr * ($x3 - $x0) }]
    }
    if { $d > $maxr * ($y3 - $y0) } {
        set d [expr { $maxr * ($y3 - $y0) }]
    }

    set x1 [expr {$x0 + $d}]
    set x2 [expr {$x3 - $d}]
    set y1 [expr {$y0 + $d}]
    set y2 [expr {$y3 - $d}]

    set xy {}
    lappend xy $x0 $y0
    lappend xy $x1 $y0
    lappend xy $x2 $y0
    lappend xy $x3 $y0
    lappend xy $x3 $y1
    lappend xy $x3 $y2
    lappend xy $x3 $y3
    lappend xy $x2 $y3
    lappend xy $x1 $y3
    lappend xy $x0 $y3
    lappend xy $x0 $y2
    lappend xy $x0 $y1
    return $xy
}
##+##########################################################################
#
# ::Display::TextScanMark -- Clone of [bind Text <2>]
#
proc ::Display::TextScanMark { w x y } {
    variable scanning

    $w scan mark $x $y
    set scanning(x) $x
    set scanning(y) $y
    set scanning(mouseMoved) 0
}
##+##########################################################################
#
# ::Display::TextScanDrag -- Clone of [bind Text <B2-Motion>] but with gain=1
#
proc ::Display::TextScanDrag { w x y } {
    variable scanning
    # Make sure these exist, as some weird situations can trigger the
    # motion binding without the initial press.  [Bug #220269]
    if {![info exists scanning(x)]} {
	set scanning(x) $x
    }
    if {![info exists scanning(y)]} {
	set scanning(y) $y
    }
    if {($x != $scanning(x)) || ($y != $scanning(y))} {
	set scanning(mouseMoved) 1
    }
    if {[info exists scanning(mouseMoved)] && $scanning(mouseMoved)} {
	$w scan dragto $x $y $scanning(gain)
    }
}
##+##########################################################################
#
# ::Display::SetPanningGain -- Sets how fast panning moves the window
#
proc ::Display::SetPanningGain {} {
    variable scanning

    set scanning(gain) 1
    if {$::state(dragGain) eq "Very Slow"} { set scanning(gain) 1 }
    if {$::state(dragGain) eq "Slow"} { set scanning(gain) 3 }
    if {$::state(dragGain) eq "Medium"} { set scanning(gain) 5 }
    if {$::state(dragGain) eq "Fast"} { set scanning(gain) 10 }
    if {$::state(dragGain) eq "Very Fast"} { set scanning(gain) 15 }
}
##+##########################################################################
#
# ::Display::RibbonWidget -- widget to let user configure ribbon
# offset and direction
#
proc ::Display::RibbonWidget {pframe dir_var len_var} {
    set drawCmd [list ::Display::_DrawRibbonWidget $pframe.c $dir_var $len_var]
    canvas $pframe.c -bd 0 -highlightthickness 0 -width 150 -height 100 \
	-bg [::ttk::style lookup [$pframe cget -style] -background]
    ::ttk::scale $pframe.dir -from 175 -to 5 -variable $dir_var \
	-command $drawCmd -takefocus 0
    ::ttk::scale $pframe.len -from 50 -to 5 -variable $len_var -orient v \
	-command $drawCmd -length 55 -takefocus 0

    grid $pframe.c $pframe.len -sticky ns
    grid config $pframe.c -sticky news
    grid $pframe.dir -sticky ew

    update idletasks
    eval $drawCmd
    return $drawCmd
}
##+##########################################################################
#
# ::Display::_DrawRibbonWidget -- helper for RibbonWidget which
# draws a ribbon using current parameters
#
proc ::Display::_DrawRibbonWidget {W dir_var len_var args} {
    $W delete all
    set redraw [expr {[$W find withtag ribbon] ne ""}]

    set dir [set $dir_var]
    set len [set $len_var]
    set rad [expr {$dir * acos(-1) / 180}]
    set dx [expr {$len*cos($rad)}]
    set dy [expr {-$len*sin($rad)}]

    set w [winfo width $W]
    set h [winfo height $W]

    set x(0) [expr {$w / 4}]     ; set y(0) [expr {$h - 5}]
    set x(1) $x(0)               ; set y(1) [expr {$y(0) - 20}]
    set x(2) [expr {$w/2}]       ; set y(2) [expr {$y(0) - 40}]
    set x(3) [expr {$w - $x(0)}] ; set y(3) $y(1)
    set x(4) $x(3)               ; set y(4) $y(0)
    for {set i 0} {$i < 5} {incr i} {
	set xx($i) [expr {$x($i) + $dx}]
	set yy($i) [expr {$y($i) + $dy}]
    }

    if {$dir <= 90} {
	for {set i 1; set i2 0} {$i < 5} {incr i; incr i2} {
	    set clr [expr {$i == 1 || $i == 4 ? "gray9" : "gray71"}]
	    set xy [list $x($i2) $y($i2) $xx($i2) $yy($i2) \
			$xx($i) $yy($i) $x($i) $y($i)]
	    if {$redraw} {
		$W coords ribbon$i $xy
	    } else {
		$W create poly $xy -tag ribbon$i -fill $clr -outline black
	    }
	}
    } else {
	for {set i 4; set i2 3} {$i > 0} {incr i -1; incr i2 -1} {
	    set clr [expr {$i == 1 || $i == 4 ? "gray9" : "gray71"}]
	    set xy [list $x($i2) $y($i2) $xx($i2) $yy($i2) \
			$xx($i) $yy($i) $x($i) $y($i)]
	    $W create poly $xy -tag ribbon$i -fill $clr -outline black
	}
    }

    if {! $redraw} {
	set xy [list $x(0) $y(0) $x(1) $y(1) $x(2) $y(2) $x(3) $y(3) $x(4) $y(4)]
	$W create poly $xy -tag a -fill seagreen -outline seagreen
    }
}

proc Locate {who} {
    if {[info exists ::nodes($who)]} {
	::Display::LocateNode $who
    } else {
	::Display::LocateRoad $who
    }
}
## EON DISPLAY
## BON TILETABLE
##+##########################################################################
#
# ::TileTable::Create -- Creates a new tile table widget
#
proc ::TileTable::Create {w headers data} {
    ::Favorites::CreateImages
    ::ttk::treeview $w.tree -columns $headers -show headings \
        -yscroll "$w.vsb set" -xscroll "$w.hsb set" -selectmode browse
    scrollbar $w.vsb -orient vertical -command "$w.tree yview"
    scrollbar $w.hsb -orient horizontal -command "$w.tree xview"

    grid $w.tree $w.vsb -sticky nsew
    grid $w.hsb          -sticky nsew
    grid column $w 0 -weight 1
    grid row    $w 0 -weight 1

    set font [::ttk::style lookup [$w.tree cget -style] -font]
    foreach col $headers {
        set name [string totitle $col]
        $w.tree heading $col -text $name -image ::Favorites::arrowBlank \
            -command [list ::TileTable::SortBy $w.tree $col 0]
        $w.tree column $col -anchor c -width [font measure $font xxx$name]
    }
    ::TileTable::InsertData $w.tree $data $headers
    return $w.tree
}
##+##########################################################################
#
# ::TileTable::InsertData -- Erases then inserts new data into table
#
proc ::TileTable::InsertData {tree data headers} {
    $tree delete [$tree child {}]
    set font [::ttk::style lookup [$tree cget -style] -font]
    set lnum -1
    foreach datum $data {
        $tree insert {} end -values $datum -tag tag[incr lnum]

        # Fix up column widths
        foreach col $headers value $datum {
            if {$col eq ""} break
            set len [font measure $font "$value  "]
            if {[$tree column $col -width] < $len} {
                $tree column $col -width $len
            }
        }
    }
    ::TileTable::BandTable $tree
}
##+##########################################################################
#
# ::TileTable::SortBy -- Code to sort tree content when clicked on a header
#
proc ::TileTable::SortBy {tree col direction} {
    # Build something we can sort
    set data {}
    foreach row [$tree children {}] {
        lappend data [list [$tree set $row $col] $row]
    }

    set dir [expr {$direction ? "-decreasing" : "-increasing"}]
    set r -1

    # Now reshuffle the rows into the sorted order
    foreach info [lsort -dictionary -index 0 $dir $data] {
        $tree move [lindex $info 1] {} [incr r]
    }

    # Switch the heading so that it will sort in the opposite direction
    set cmd [list ::TileTable::SortBy $tree $col [expr {!$direction}]]
    $tree heading $col -command $cmd
    ::TileTable::BandTable $tree
    ::TileTable::ArrowHeadings $tree $col $direction
}
##+##########################################################################
#
# ::TileTable::ArrowHeadings -- Puts in up/down arrows to show sorting
#
proc ::TileTable::ArrowHeadings {tree sortCol dir} {
    set idx -1
    foreach col [$tree cget -columns] {
        incr idx
        set img ::Favorites::arrowBlank
        if {$col == $sortCol} {
            set img ::Favorites::arrow($dir)
        }
        $tree heading $idx -image $img
    }
}
##+##########################################################################
#
# ::TileTable::BandTable -- Draws bands on our table
#
proc ::TileTable::BandTable {tree} {
    array set colors {0 white 1 \#aaffff}

    set id 0
    foreach row [$tree children {}] {
        set id [expr {! $id}]
        set tag [$tree item $row -tag]
        $tree tag configure $tag -background $colors($id)
    }
}
## EON TILETABLE
## BON MISC
##+##########################################################################
#
# lat2int -- Converts degree minutes seconds into an integer
#
proc lat2int {lat1 lat2 lat3} {
    scan "$lat1 $lat2 $lat3" "%g %g %g" lat1 lat2 lat3
    set lat [expr {abs($lat1) + $lat2 / 60.0 + $lat3 / 3600.0}]
    return $lat
}
##+##########################################################################
#
# int2lat -- Reverse of lat2int
#
# proc int2lat {int} {
#     set int [expr {abs($int) * 3600}]
#
#     if {[string is integer -strict $int]} {
#	set sec [expr {$int % 60}]
#     } else {
#	#set fra [expr {$int - int($int)}]
#	#set fra [expr {round($fra * 10) / 10.0}]
#	#set int [expr {int($int)}]
#	#set sec [expr {$int % 60 + $fra}]
#
#	set v [expr {$int + .05}]		;# Round to 1 decimal place
#	foreach {int fra} [split $v "."] break	;# Use string representation
#	set fra [string range $fra 0 0]		;# 1 decimal place only
#
#	set sec [expr {$int % 60}]
#	if {$fra ne {0}} { append sec ".$fra"}
#     }
#     set int [expr {$int / 60}]
#     set min [expr {$int % 60}]
#     set deg [expr {$int / 60}]
#
#     return [list $deg $min $sec]
# }
proc int2lat {lat} {
    set deg [expr {int($lat)}]
    set lat [expr {($lat - $deg)*60}]
    set min [expr {int($lat)}]
    set sec [format "%.2f" [expr {($lat - $min)*60}]]
    regsub {(.)\.?0*$} $sec {\1} sec
    return [list $deg $min $sec]
}
##+##########################################################################
#
# comma
#
# Puts comma's into a number. Handles our "bad numbers" of form 3.5+?
#
proc comma { num } {
    while {[regsub {^([-+]?[0-9]+)([0-9][0-9][0-9])} $num {\1,\2} num]} {}
    return $num
}
proc Max {max args} {
    foreach val $args {if {$val > $max} {set max $val}}
    return $max
}
proc Min {min args} {
    foreach val $args {if {$val < $min} {set min $val}}
    return $min
}
proc Median {a b c} {
    return [Max [Min $a $b] [Min $a $c] [Min $b $c]]
}
proc Round0 {num} {
    if {! [string is integer -strict $num]} {
	set v [expr {$num + .5}]		;# Round to 0 decimal place
	set idx [string first "." $v]
	set num [string range $v 0 [incr idx -1]]
    }
    return $num
}
proc Round1 {num} {
    if {! [string is double -strict $num]} { return ""}
    if {! [string is integer -strict $num]} {
	set v [expr {$num + .05}]		;# Round to 1 decimal place
	set idx [string first "." $v]
	set num [string range $v 0 [incr idx]]
	regsub {\.0$} $num {} num
    }
    return $num
}
proc Round2 {num} {
    if {! [string is integer -strict $num]} {
	set v [expr {$num + .005}]		;# Round to 2 decimal place
	set idx [string first "." $v]
	set num [string range $v 0 [incr idx 2]]
	regsub {\.0+$} $num {} num
    }
    return $num
}
proc Round10 {num} {				;# Round to ten's place
    return [expr {round($num / 10.0) * 10}]
}
##+##########################################################################
#
# ldelete -- Removes all occurrences of elem from alist
#
proc ldelete {alist elem} {
    set all [lsearch -exact -all $alist $elem]
    for {set i [expr {[llength $all]-1}]} {$i >= 0} {incr i -1} {
	set n [lindex $all $i]
	set alist [lreplace $alist $n $n]
    }
    return $alist
}
proc lappendUnique {alist_name val} {
    upvar 1 $alist_name alist
    set n [lsearch $alist $val]
    if {$n == -1} {
	lappend alist $val
    }
    return ""
}
##+##########################################################################
#
# Feedback -- brings up mail agent to compose an email back to me
#
proc Feedback {} {
    set addr "mailto:klimb@klimb.org?subject=$::state(progname)%20Feedback"

    if {! $::state(windows)} {
	if {! [::Data::CanDo webPage]} {
	    WARN "Sorry, don't know how to send mail"
	} else {
	    WebPage $addr
	}
    } else {
	set cmd [auto_execok cmd]		;# Works better than 4dos
	if {$cmd ne ""} {
	    catch {exec $cmd /c start $addr}
	} else {
	    catch {eval exec [auto_execok start] [list $addr]}
	}
    }
}
##+##########################################################################
#
# WebPage -- Goes to a specified web page
#
proc WebPage {url} {
    if {! [::Data::CanDo webPage]} return

    INFO "fetching $url"
    if {$::state(macosx)} {
	_WebPageOSX $url
    } elseif {$::state(unix)} {
	_WebPageUNIX $url
    } else {
	_WebPageWINDOWS $url
    }
}
##+##########################################################################
#
# _WebPage: Broke out of WebPage for easier cross-platform handling
#
proc _WebPageWINDOWS {url} {

    #set n [catch {exec $::env(COMSPEC) /c start $url &}]
    #if {! $n} return

    # NB. eval exec [auto_execok start] [list $url] & works but is real slow

    # Also:
    #   regsub -all -nocase {htm} $url {ht%6D} url
    #   exec rundll32 url.dll,FileProtocolHandler $url &

    # Substitute the variable %1 for the name of the file
    if {[string first "%1" $::state(WebPage,cmd)] != -1} {
	set cmd [string map [list "%1" $url] $::state(WebPage,cmd)]
    } else {
	set cmd "$::state(WebPage,cmd) $url"
    }

    regsub -all {\\} $cmd / cmd			;# Protect against the eval
    eval exec $cmd &
}
proc _WebPageUNIX {url} {
    catch {exec {*}$::state(WebPage,cmd) $url &}
}
proc _WebPageOSX {url} {
    catch {exec open $url &}
}
##+##########################################################################
#
# CanLaunchBrowser -- returns boolean if we can launch a browser
#
proc CanLaunchBrowser {} {
    if {[info exists ::state(can,webPage)]} { return $::state(can,webPage)}

    set ::state(can,webPage) 1
    if {$::state(macosx)} { return $::state(can,webPage) }

    if {$::state(unix)} {
	if {[info exists ::env(BROWSER)]} {
	    set ::state(WebPage,cmd) $::env(BROWSER)
	} elseif {[info exists ::env(NETSCAPE)]} {
	    set ::state(WebPage,cmd) $::env(NETSCAPE)
	} else {
	    foreach browser {firefox netscape iexplorer gnome-open} {
		set ::state(WebPage,cmd) [lindex [auto_execok $browser] 0]
		if {$::state(WebPage,cmd) ne ""} {
		    if {$browser eq "firefox" || $browser eq "netscape"} {
			append ::state(WebPage,cmd) " -new-window "
		    }
		    break
		}
	    }
	    if {$::state(WebPage,cmd) eq ""} {
		set ::state(can,webPage) 0
	    }
	}
	return $::state(can,webPage)
    }

    # Windows
    set n [catch {
	package require registry
	set app [registry get {HKEY_CLASSES_ROOT\.html} {}]
	set ::state(WebPage,cmd) \
	    [registry get HKEY_CLASSES_ROOT\\$app\\shell\\open\\command {}]
    }]
    set ::state(can,webPage) [expr {! $n}]
    return $::state(can,webPage)
}
##+##########################################################################
#
# CanPrintText -- returns boolean if we can print a text file. Only works
# on windows for now.
#
proc CanPrintText {} {
    global state

    if {[info exists state(can,printText)]} { return $state(can,printText) }

    set state(can,printText) 0			;# Assume we can't
    if {$::tcl_platform(platform) ne "windows"} { return 0 }
    if {[auto_execok "start"] eq {}} {return 0}
    if {! [::Data::CanDo registry]} {return 0}

    if {[catch {
	set app [registry get {HKEY_CLASSES_ROOT\.txt} {}]
	set cmd [registry get HKEY_CLASSES_ROOT\\$app\\shell\\print\\command {}]
    }]} {
	return 0
    }
    set state(can,printText) 1
    set state(printcmd) $cmd
    return 1
}
##+##########################################################################
#
# PrintText -- prints a text file by invoking the print command for text files.
#
proc PrintText {fname} {
    global state

    if {! [::Data::CanDo printText]} return
    set pcmd $state(printcmd)
    regsub -all {%1} $pcmd [file normalize $fname] pcmd
    set command "[auto_execok start] /min [regsub -all {\\} $pcmd {\\\\}]"
    #puts "execing $command"
    eval exec $command &
}
##+##########################################################################
#
# DoGrab
#
# Does a grab to a given window and points the focus to a widget.
# It then waits for the window to be destroyed then releases the grab.
#
proc DoGrab {w f} {

    # 7. Set a grab and claim the focus too.
    # (taken from the tk_dialog function)
    set oldFocus [focus]
    set oldGrab [grab current $w]
    if {[string compare $oldGrab ""]} {
	set grabStatus [grab status $oldGrab]
    }
    grab $w
    focus $f

    # Wait for the dialog to be closed
    tkwait window $w

    # 8. Wait for the user to respond, then restore the focus and
    # return the index of the selected button. Restore the focus
    # before deleting the window, since otherwise the window manager
    # may take the focus away so we can't redirect it. Finally,
    # restore any grab that was in effect.

    catch {focus $oldFocus}
    catch {
	# It's possible that the window has already been destroyed,
	# hence this "catch". Delete the Destroy handler so that
	# tkPriv(button) doesn't get reset by it.

	bind $w <Destroy> {}
	destroy $w
    }
    if {[string compare $oldGrab ""]} {
	if {[string compare $grabStatus "global"]} {
	    grab $oldGrab
	} else {
	    grab -global $oldGrab
	}
    }
}
##+##########################################################################
#
# DoConsole -- brings up the console window, using tkcon if available
#
proc DoConsole {} {
    global state argc argv argv0

    while {1} {
	if {$state(console) ne ""} break
	set state(console) "console show"	;# Assume no tkcon

	if {[info commands tkcon] ne ""} {	;# Already loaded???
	    set state(console) "tkcon show"
	    break
	}
	set fname [file join $state(pdir) tkcon.tcl]
	set fname [file join $state(pdir) tkcon_klimb.tcl]
	if {! [file exists $fname]} break	;# No tkcon.tcl file
	catch {set fname [file attributes $fname -shortname]}

	namespace eval ::tkcon {}		;# from Jeffrey Hobbs
	set ::tkcon::OPT(exec) ""
	set ::tkcon::OPT(gets) ""
	set ::tkcon::OPT(overrideexit) 0
	set ::tkcon::PRIV(root) .tkcon
	set ::tkcon::PRIV(protocol) "tkcon hide"

	set ::tkcon::OPT(rows) 13		;# Stuff that I like
	set ::tkcon::OPT(cols) 70
	set ::tkcon::OPT(font) "{Courier} 10"
	append ::tkcon::OPT(maineval) {
	    wm geometry .tkcon +150-60
	    bind TkConsole <Control-p> [bind TkConsole <<TkCon_PreviousSearch>>]
	    bind TkConsole <Up> [bind TkConsole <<TkCon_PreviousSearch>>]
	    bind TkConsole <Control-n> [bind TkConsole <<TkCon_NextSearch>>]
	    bind TkConsole <Down> [bind TkConsole <<TkCon_NextSearch>>]
	}

	# Setup argv0 and argv so the tkcon will init w/ no rcfile
	foreach a {argv0 argc argv} v [list $fname 1 -rcfile] {
	    foreach [list X$a $a] [list [set $a] $v] break
	}
	uplevel \#0 source $fname
	foreach a {argv0 argc argv} {		;# Restore argv0, argc and argv
	    set $a [set X$a]
	}

	if {[info commands tkcon] eq ""} break
	set state(console) "tkcon show"
	break
    }
    set n [catch {eval $state(console)} err]
    if {$n} {WARN $err}
}
##+##########################################################################
#
# INFO -- puts information in the status bar's message box
#
proc INFO {txt {nolog ""}} {
    global msg state

    if {$nolog eq ""} {
	lappend ::Data::log $txt
	if {[llength $::Data::log] > $state(logMax)} {
	    set ::Data::log [lrange $::Data::log 500 end]
	}
    }
    if {! $state(verbose)} return
    #lappend ::info [list $txt [clock click -milliseconds]]

    foreach w [list .b.msg .splash.msg .pbar.msg] {
	if {[winfo exists $w]} {
	    $w itemconfig txt -text $txt
	}
    }
    if {$state(verbose) > 1 && $::tcl_interactive} {
	puts "INFO: $txt"
    }
    update
}
##+##########################################################################
#
# DoInfo -- puts up an info messagebox
#
proc DoInfo {msg title} {
    set msg [WRAPUNIX $msg]
    tk_messageBox -message $msg -icon info -title $title -parent . -type ok
}
##+##########################################################################
#
# DIE -- puts up an error message then exits the program
#
proc DIE {emsg} {
    WARN $emsg
    exit
}
##+##########################################################################
#
# WARN -- puts up an error message
#
proc WARN {emsg} {
    set emsg [WRAPUNIX $emsg]
    tk_messageBox -message $emsg -icon error -title "$::state(progname) Error"
    return 0
}
##+##########################################################################
#
# WRAPUNIX -- Unix messageBox looks better if you let it do word wrap.
# Remove all single line ends from the txt.
#
proc WRAPUNIX {txt} {
    if {$::state(unix)} {
        set txt [string map {\n\n \x01} $txt]
        regsub -all { *\n *} $txt " " txt
        set txt [string map {\x01 \n\n} $txt]
    }
    return $txt
}
##+##########################################################################
#
# Busy
#
# Kludge to disable the GUI during a long operation by grabbing the focus
# into a junk window.
#
proc Busy {onoff} {
    destroy .grabber
    if {$onoff} {
        . config -cursor watch                  ;# Doing a long operation
        update
        toplevel .grabber
        wm withdraw .grabber
        grab set .grabber
    } else {
        . config -cursor {}
    }
}

## EON MISC
## BON BADMATH
##+##########################################################################
#
# ::BadMath::Add, ::BadMath::Min, ::BadMath::Real, ::BadMath::IsBad,
# ::BadMath::Round
#
# ONLY Fix(), IsValid() can handle arbitrary user data
#
# ALL NUMBERS WILL BE OF THE FOLLOWING FORM:
#   3   3.14  3.14+?  0+?
# except for Fix()
#
proc ::BadMath::Fix {num} {
    regsub -all {[, ]*} $num {} num
    if {[string is double -strict $num]} { return $num }
    if {$num eq ""} {return "0+?"}
    foreach {n1 b1} [split $num "+"] break
    if {[string is double -strict $n1]} { return "$n1+?" }
    return "0+?"
}
proc ::BadMath::Add {num1 num2} {
    foreach {n1 b1} [split $num1 "+"] break
    foreach {n2 b2} [split $num2 "+"] break
    set n3 [expr {$n1 + $n2}]
    if {$b1 ne {} || $b2 ne {}} { append n3 "+?" }
    return $n3
}
proc ::BadMath::Sub {num1 num2} {
    foreach {n1 b1} [split $num1 "+"] break
    foreach {n2 b2} [split $num2 "+"] break
    set n3 [expr {$n1 - $n2}]
    if {$b1 ne {} || $b2 ne {}} { append n3 "+?" }
    return $n3
}
proc ::BadMath::Min {num1 args} {
    foreach num2 $args {
	set n3 [::BadMath::Sub $num1 $num2]	;# Subtract the two
	if {[string match "-*" $n3]} continue	;# Negative, so 1st is min
	set num1 $num2
    }
    return $num1
}
proc ::BadMath::Max {num1 args} {
    foreach num2 $args {
	set n3 [::BadMath::Sub $num1 $num2]	;# Subtract the two
	if {! [string match "-*" $n3]} continue	;# Not negative, so 2nd is max
	set num1 $num2
    }
    return $num1
}
proc ::BadMath::2Sort {num1 num2} {
    set n [::BadMath::Real [::BadMath::Sub $num1 $num2]]
    if {$n <= 0} { return [list $num1 $num2]}
    return [list $num2 $num1]
}
proc ::BadMath::IsBad {num} {
    if {$num eq "?"} {return 1}
    return [string match "*+?" $num]
}
proc ::BadMath::Split {num} {
    foreach {n b} [split $num "+"] break
    if {$b eq {}} {
	return [list $n 0]
    }
    return [list $n 1]
}
proc ::BadMath::Real {num} {
    return [lindex [split $num "+"] 0]
}
proc ::BadMath::MakeGood {num} {
    regsub {\+\?$} $num {} num
    return $num
}
proc ::BadMath::Round1 {num} {
    foreach {num isbad} [::BadMath::Split $num] break
    set num [::Round1 $num]
    if {$isbad} {append num "+?"}
    return $num
}
proc ::BadMath::StillGood {num bad} {
    foreach {n1 b1} [split $num "+"] break
    if {$b1 ne {}} {set bad 1}
    return [list $n1 $bad]
}
## EON BADMATH
## BON BALLOON
##+##########################################################################
#
# ::Balloon::Go
#
# On <Enter> into a node or road display information about that item. We
# now create the balloon help text only on demand for roads and nodes.
#
proc ::Balloon::Go {onoff what who} {
    global state
    variable btext
    variable stext
    variable enabled

    ::Balloon::Cancel
    if {! $onoff} return
    if {! $enabled} return

    # Create if it doesn't exist yet
    ::Balloon::SetText $what $who

    # Status line
    if {[info exists stext($what,$who)]} {
	INFO $stext($what,$who) nolog
    }

    # Balloon help
    if {! [info exists btext($what,$who)]} return

    set txt $btext($what,$who)
    if {[string equal $what "node"]} {
	append txt [::Route::Turnings $who]
	append txt [::Within::HowFar $who]
    }
    set delay $state(balloon,delay)
    set state(balloon,afterid) \
	[after $delay [list ::Balloon::Show $txt $what $who]]
}
##+##########################################################################
#
# ::Balloon::Create
#
# Creates the binding and the global variables needed to set up
# balloon help on a widget. This doesn't handle balloon help on
# a canvas item.
#
proc ::Balloon::Create {w what who {btxt {}} {stxt ""}} {
    variable btext ; variable stext

    if {$btxt ne "" || $stxt ne ""} {
	set btext($what,$who) $btxt
	set stext($what,$who) $stxt
    }

    if {[winfo exists $w]} {
	bind $w <Enter> [list ::Balloon::Go 1 $what $who]
	bind $w <Leave> [list ::Balloon::Go 0 $what $who]
    } else {					;# Canvas item
	foreach {canv tag} $w break
	if {[winfo exists $canv]} {
	    $canv bind $tag <Enter> [list ::Balloon::Go 1 $what $who]
	    $canv bind $tag <Leave> [list ::Balloon::Go 0 $what $who]
	}
    }
}
##+##########################################################################
#
# ::Balloon::Delete -- deletes balloon help for a widget
#
proc ::Balloon::Delete {w} {
    if {[winfo exists $w]} {
	bind $w <Enter> {}
	bind $w <Leave> {}
    } else {					;# Canvas item
	foreach {canv tag} $w break
	$canv bind $tag <Enter> {}
	$canv bind $tag <Leave> {}
    }
}
##+##########################################################################
#
# ::Balloon::Cancel -- Cancels balloon help by withdrawing the window
# and cancelling any after events.
#
proc ::Balloon::Cancel {} {
    global state route
    variable lastID

    after cancel $state(balloon,afterid)
    after cancel $state(balloon,fadeid)
    set state(balloon,afterid) ""
    set state(balloon,fadeid) ""
    #wm withdraw .balloonhelp
    ::Balloon::Fade

    if {$lastID(rid) ne ""} {
	set lvl [expr {[lsearch $::route(roads) $lastID(rid)] > -1}]
	::Display::HighlightRoad $lvl $lastID(rid) noEnd
	set lastID(rid) ""
    } elseif {$lastID(nid) ne ""} {
	set n [lsearch $::route(nodes) $lastID(nid)]
	if {$n == -1} {
	    set lvl 0
	} elseif {$n == 0} {
	    set lvl start
	} elseif {$n+1 == [llength $route(nodes)]} {
	    set lvl end
	} else {
	    set lvl 1
	}
	::Display::HighlightNode $lvl $lastID(nid)
	set lastID(nid) ""
    }
}
##+##########################################################################
#
# ::Balloon::Fade -- slowly fades away balloon help window
#
proc ::Balloon::Fade {} {
    global state
    variable fadeStep

    set w .balloonhelp
    if {! [winfo ismapped $w]} return
    if {[catch {wm attributes $w -alpha} alpha] || $alpha <= 0.0} {
        catch { wm withdraw $w }
        catch { wm attributes $w -alpha 0.99 }
    } else {
        wm attributes $w -alpha [expr {$alpha-$fadeStep}]
        set state(balloon,fadeid) [after 50 ::Balloon::Fade]
    }
}

##+##########################################################################
#
# ::Balloon::Show
#
# Called when we want to actually show the balloon help
#
proc ::Balloon::Show {txt what who} {
    variable enabled
    variable lastID
    if {! $enabled} return

    .balloonhelp.info configure -text $txt	;# Put in our help text
    update idletasks

    set x [expr {[winfo pointerx .] - [winfo reqwidth  .balloonhelp.info] / 2}]
    set y [expr {[winfo pointery .] - [winfo reqheight .balloonhelp.info] - 5}]
    set y [expr {[winfo pointery .] + 25}]
    if {$x < 0} {set x 2}

    wm geometry .balloonhelp +$x+$y
    wm deiconify .balloonhelp
    raise .balloonhelp

    if {$what eq "road"} {
	set lastID(rid) $who
	::Display::HighlightRoad balloon $who noEnd
    } elseif {$what eq "node"} {
	set lastID(nid) $who
	::Display::HighlightNode balloon $who
    }

    set state(balloon,afterid) [after 15000 ::Balloon::Cancel] ;# Turn off soon
}
##+##########################################################################
#
# ::Balloon::Enable -- a way to turn balloon help off (for snapshot)
#
proc ::Balloon::Enable {onoff} {
    variable disabled
    if {! $onoff} ::Balloon::Cancel
    set enabled $onoff
}
##+##########################################################################
#
# ::Balloon::SetText -- adds balloon help text
#
proc ::Balloon::SetText {what who} {
    variable btext ; variable stext
    global roads nodes zone poi

    if {[info exists btext($what,$who)]} return

    if {$what eq "road"} {
	foreach who [array names roads $who] {
	    foreach {id1 id2 north dist south type name comment xy z q w} \
		$roads($who) break

	    set btext(road,$who) [set stext(road,$who) ""]
	    set roadname [::Data::GuessRoadName $name $id1 $id2 $who]
	    if {$roadname ne ""} {
		set stext(road,$who) "$roadname : "
		set btext(road,$who) "$roadname\n"
		lset roads($who) 6 $roadname
	    }

	    if {$q <= $zone(goodData)} {
		set north [::BadMath::MakeGood $north]
		set south [::BadMath::MakeGood $south]
		set dist  [::BadMath::MakeGood $dist]
	    }
	    set dist [::Data::Units $dist dist]
	    set north [::Data::Units $north climb 1 2]
	    set south [::Data::Units $south climb 1 2]
	    append stext(road,$who) "$north / $dist / $south $comment"
	    append btext(road,$who) "$dist\n$north / $south"

	    if {$comment ne ""} {
		append btext(road,$who) "\n$comment"
	    }
	    append btext(road,$who) [::RideLog::Info last $who]
	}
    } elseif {$what eq "node"} {
	foreach who [array names nodes $who] {
	    foreach {name alt} $nodes($who) break
	    set alt [::Data::Units $alt climb 1 2]
	    if {$name eq ""} {
		set stext(node,$who) "Elevation: $alt"
		set btext(node,$who) "Elevation: $alt"
	    } else {
		set stext(node,$who) "$name : $alt"
		set btext(node,$who) "$name\nElevation: $alt"
	    }
	}
    } elseif {$what eq "poi"} {
	# NB. ::Postit::GetText uses btext
	foreach {type name . . location} $poi($who) break

	set txt [::POI::Type2Text $type $name]
	if {$location ne ""} { append txt " at $location" }
	set btext(poi,$who) $txt
	set stext(poi,$who) $txt
    } elseif {$what eq "wpt" || $what eq "geo"} { ;# Geocache
	# NB. ::Postit::GetText uses btext
	foreach {b s} [::GPS::BalloonText $who] break
	set btext(wpt,$who) $b
	set stext(wpt,$who) $s
    }
}
##+##########################################################################
#
# ::Balloon::ClearText -- clears any balloon text for given item
#
proc ::Balloon::ClearText {what who} {
    variable btext ; variable stext

    ::Postit::ClearText $what $who

    set bsave [array get btext static,*]	;# Never delete these
    set ssave [array get stext static,*]

    array unset btext $what,$who
    array unset stext $what,$who

    array set btext $bsave
    array set stext $ssave
}
## EON BALLOON
## BON ROUTE
#_ ##+##########################################################################
#_ #
#_ # ::Route::UndoRoute
#_ #
#_ # Takes off the last road on the route. The item clicked MUST be either
#_ # one of the last two nodes or the last road.
#_ #
#_ # This routine just checks for validity, UndoRoute2 does the actual undoing.
#_ #
#_ proc ::Route::UndoRoute {what who} {
#_     global route roads
#_
#_     if {$route(start) == -1} return		 ;# No route yet
#_
#_     set last [lindex $route(roads) end]		 ;# Last road in route
#_     if {$last eq {}} {				 ;# Special case, no last road
#_	set id1 $route(start)
#_	set id2 $route(tail)
#_     } else {
#_	foreach {id1 id2} $roads($last) break
#_     }
#_
#_     if {$what eq "road"} {			 ;# Road clicked
#_	foreach {end1 end2} $roads($who) break	 ;# Ends of the road clicked on
#_	if {($end1==$id1 && $end2==$id2) || ($end1==$id2 && $end2==$id1)} {
#_	    ::Route::UndoRoute2
#_	}
#_     } else {					 ;# Node clicked
#_	if {$who == $id1 || $who == $id2} ::Route::UndoRoute2
#_     }
#_ }
##+##########################################################################
#
# ::Route::UndoRoute2
#
# Removes the last road off the route
#
proc ::Route::UndoRoute2 {} {
    global route roads

    set lastroad     [lindex $route(roads) end]
    set route(roads) [lrange $route(roads) 0 end-1]
    set lastnode     [lindex $route(nodes) end]
    set route(nodes) [lrange $route(nodes) 0 end-1]
    set route(turns) [lrange $route(turns) 0 end-1]

    if {$lastroad eq {}} {			 ;# Special case, no last road
	::Route::ClearRoute
	return
    }

    # Find the new tail node
    foreach {id1 id2} $roads($lastroad) break
    if {$route(tail) == $id1} {set route(tail) $id2} else {set route(tail) $id1}

    # Turn off its highlighting if not used twice
    if {[lsearch $route(roads) $lastroad] == -1} {
	::Display::HighlightRoad 0 $lastroad
    }
    set n [lsearch $route(nodes) $lastnode]
    ::Display::HighlightNode [expr {$n < 0 ? 0 : 1}] $lastnode

    # Recompute route statistics
    ::Route::StatRoute 0

    ::Route::DoButtons
    ::Arrow::RemoveLeg [lindex $route(roads) end] [lindex $route(nodes) end] \
	$lastroad
}
##+##########################################################################
#
# ::Route::ClearRoute
#
# Resets any route information, allowing you to start a new route.
#
proc ::Route::ClearRoute {} {
    global route msg

    ::Trace::Clear 0
    ::MilePost::Clear .c
    ::RInfo::Clear
    ::Arrow::RemoveAllLegs
    ::Postit::Reset

    ::Display::HighlightNode 0 $route(start)
    ::Display::HighlightNode2 -1

    foreach rid $route(roads) {
	catch {::Display::HighlightRoad 0 $rid}
    }
    set route(start) -1
    set route(tail)  -1
    set route(roads) {}
    set route(nodes) {}
    set route(turns) {}
    set route(title) ""
    ::RInfo::Refresh?

    set msg(dist)   "distance"
    set msg(climb)  "climbing"
    set msg(desc)   "descending"
    set msg(dist2)  0
    set msg(climb2) 0
    set msg(desc2)  0

    catch {
	::Route::DoButtons
    }
}
##+##########################################################################
#
# ::Route::DoButtons -- figures out which route specific widgets need to
# be on and which need to be off
#
proc ::Route::DoButtons {} {
    global route

    ::Display::ButtonEnable [llength $route(nodes)]
}
##+##########################################################################
#
# ::Route::CheckRoute
#
# Checks to see if it okay to add node WHO to the current route
#
proc ::Route::CheckRoute {what who} {
    global route roads NR

    if {$route(start) == -1} {			 ;# No route started yet
	if {$what eq "road"} {return 0}		 ;# Must start w/ a node

	set route(start) $who
	set route(tail) $who
	lappend route(nodes) $who
	lappend route(turns) "B"

	::Display::HighlightNode 1 $who
	::Route::DoButtons
	return 1
    }

    # If we get a road, figure out the equivalent node and fall through
    if {$what eq "road"} {
	set rid $who

	if {$who == $route(tail)} {return 0}	 ;# No doubling back

	foreach {id1 id2} $roads($who) break
	if {$id1 == $route(tail)} {
		set who $id2
	} elseif {$id2 == $route(tail)} {
		set who $id1
	} else {return 0}
    } else {					 ;# Figure out the rid
	set a [lindex [array names NR *,$who,$route(tail)] 0]
	if {$a eq ""} {return 0}
	set rid [lindex $NR($a) 0]
    }

    lappend route(roads) $rid
    lappend route(nodes) $who
    if {[lindex $route(turns) end] eq "E"} {
	lset route(turns) end "N"
    }
    lappend route(turns) "E"
    set route(tail) $who

    ::Display::HighlightRoad 1 $rid
    ::Route::DoButtons
    ::Route::StatRoute
    ::Arrow::AddLeg
    ::Display::Raise
    return 1
}
##+##########################################################################
#
# ::Route::StatRoute
#
# Computes distance and climbing of the current route
#
proc ::Route::StatRoute {{highlight 0}} {
    global msg route roads NR

    if {$route(start) == -1} {
	::Route::ClearRoute
	return
    }
    set tdist  0
    set tclimb 0
    set tdesc  0
    set from $route(start)
    set to -1

    ::Trace::Clear 0

    foreach rid $route(roads) {
	if {$highlight} { ::Display::HighlightRoad 1 $rid }
	foreach {id1 id2} $roads($rid) break

	if {$from == $id1} { set to $id2 } else { set to $id1 }
	foreach {. dist climb desc type} $NR($rid,$from,$to) break

	# Add to totals but careful about unknown values
	set tdist  [::BadMath::Add $tdist  $dist]
	set tclimb [::BadMath::Add $tclimb $climb]
	set tdesc  [::BadMath::Add $tdesc  $desc]

	set from $to
    }
    ::Display::HighlightNode start $route(start) ;# Mark start of current route
    ::Display::HighlightNode end $to		;# Mark end of current route

    if {$highlight} {
	::Route::DoButtons
    }

    set tdesc [::BadMath::Sub 0 $tdesc]

    set msg(dist)   [::Data::Units $tdist dist]
    set msg(climb)  [::Data::Units $tclimb climb]
    set msg(desc)   [::Data::Units $tdesc climb]
    set msg(dist2)  [::Data::Convert $tdist dist]
    set msg(climb2) [::Data::Convert $tclimb climb]
    set msg(desc2)  [::Data::Convert $tdesc climb]

    #set route(dist) $tdist
    #set route(climb) $tclimb
    set route(desc) $tdesc			;# Used in profile
    ::MilePost::Go .c
}
##+##########################################################################
#
# ::Route::Turn
#
# Handles the turn popup up menu, specify how a route turns at a
# specific node.
#
proc ::Route::Turn {how} {
    global route state

    set where [lindex [::Route::NodeWhere $state(popup,who)] end]
    if {$where eq ""} return

    if {$where == 0 && $how eq "O"} {set how B} ;# Can't omit starting node
    set route(turns) [lreplace $route(turns) $where $where $how]

    if {$how eq "O"} {
	foreach {in out} [lrange $route(roads) [expr {$where-1}] $where] break
	::Arrow::RemoveLeg $in $state(popup,who) $out
    }
}
##+##########################################################################
#
# ::Route::NodeWhere
#
# Locates all occurrences of a node in the current route.
#
proc ::Route::NodeWhere {nid} {
    global route

    return [lsearch -all $route(nodes) $nid]
    set where {}
    set idx -1
    foreach who $route(nodes) {
	incr idx

	if {[string equal $who $nid]} {
		lappend where $idx
	}
    }
    return $where
}
##+##########################################################################
#
# ::Route::Turnings
#
# Returns a string describing all the turns a route does through a given node.
#
proc ::Route::Turnings {nid} {
    global route
    variable tlabel

    set result ""
    set where [::Route::NodeWhere $nid]
    set last [expr {[llength $route(nodes)] - 1}]
    set prefix "\nRoute: "

    foreach idx $where {
	set how [lindex $route(turns) $idx]
	if {$idx == $last && $how eq "N"} {
	    set how E
	}
	if {$how eq ""} {set how N}
	append result $prefix $tlabel($how)

	set prefix "; "
    }
    return $result
}
##+##########################################################################
#
# ::Route::Save
#
# Saves the current route to a file. If saveas is true or we don't have
# a current file, then we ask the user for a filename.
#
proc ::Route::Save {saveas} {
    variable saveName
    global state

    set types {{{KLIMB Files} {.klm}} {{All Files} *}}

    set fname $saveName
    if {$saveas || $fname eq ""} {
	set fname [tk_getSaveFile -defaultextension ".klm" \
		       -title "$state(progname) Save Route" -filetypes $types \
		       -initialdir [file dirname $saveName] \
		       -initialfile [file tail $saveName]]
	if {$fname eq ""} return
    }

    set saveName $fname
    ::Route::Save2 $fname
}
proc ::Route::Save2 {fname} {
    global state route nodes roads splits photos

    set n [catch {set fout [open $fname "w"]} err]
    if {$n} {
	WARN "Save Error: $err"
	return
    }

    # Get all user defined stuff for this route
    ::Route::GetNewStuff nnodes nroads nsplits nphotos

    # Now write the data to the output file
    puts -nonewline $fout "# This is a route file for the KLIMB bike mapping"
    puts $fout " program available at"
    puts $fout "# $state(homepage)\n"
    puts $fout "set Rversion $state(version)"
    puts $fout "set Rdate [clock format [clock seconds] -format %Y-%m-%d]"
    puts $fout "set Rzone \"$state(zone)\""
    puts $fout "set Rregion \[list $state(region,multi) \]"
    puts $fout "set Rmag $state(mag)"
    puts $fout "set Runits $state(units,internal)"
    puts $fout "set Rtitle \x22[string map {\x22 \\\x22} $route(title)]\x22"
    set line "array set Rroute {\n  nodes \{$route(nodes)\}\n"
    append line "  roads \{$route(roads)\}\n  turns \{$route(turns)\}\n}"
    puts $fout $line

    # Write out the three sections of a route
    foreach what {nnodes nroads nsplits nphotos} {
	if {! [info exists $what]} continue
	upvar 0 $what local
	puts $fout "\n\# User defined [string range $what 1 end]"
	puts $fout "array set R$what \{"
	foreach id [array names $what] {
	    puts $fout "    $id [list $local($id)]"
	}
	puts $fout "\}"
    }
    puts $fout [::Arrow::DumpArrowInfo]
    close $fout

    #wm title . "$state(title) -- [file rootname [file tail $fname]]"
    INFO "saved $fname"
}
##+##########################################################################
#
# ::Route::Load
#
# Loads in a route file. The route file is a tcl script which we load
# into a safe interp and extract out the relevant data.
#
# Returns true if we succeeded in loading a new route
#
proc ::Route::Load {{fname ""} {forceLoadRegion 0}} {
    variable saveName
    global state route
    global R

    if {$fname eq ""} {
	set types {{{KLIMB Files} {.klm}} {{All Files} *}}
	set fname [tk_getOpenFile -defaultextension ".klm" \
		       -title "$state(progname) Open Route" -filetypes $types \
		       -initialdir [file dirname $saveName] \
		       -initialfile [file tail $saveName]]
	if {$fname eq ""} { return 0 }
    }

    if {[interp exists newInterp]} {
	interp delete newInterp
    }
    interp create -safe newInterp
    newInterp eval set Rzone SFBay		;# V1.0 compatible
    newInterp eval set Runits english
    newInterp eval set Rtitle {""}
    newInterp eval set Rregion "ignore"
    set n [catch {newInterp invokehidden source $fname} err]
    if {$n} {
	WARN "Load error ($fname): $err"
	interp delete newInterp
	return 0
    }
    set a [newInterp eval info exists Rversion]
    set b [newInterp eval info exists Rregion]
    set c [newInterp eval info exists Rmag]
    set d [newInterp eval info exists Rroute]
    set e [newInterp eval info exists Rzone]
    if {! $a || ! $b || ! $c || ! $d || ! $e} {
	interp delete newInterp
	set emsg "Load error: badly formatted route file"
	if {! $a && ($b || $c || $d)} {
	    append emsg "\npossibly an incompatible version--"
	    append emsg "see HELP for conversion details"
	}
	WARN $emsg
	return 0
    }

    # Grab out the data that we need
    set R(Rversion) [newInterp eval set Rversion]
    set R(Rtitle)   [newInterp eval set Rtitle]
    set R(Rzone)    [newInterp eval set Rzone]
    set R(Rregion)  [newInterp eval set Rregion]
    set R(Rmag)	    [newInterp eval set Rmag]
    set R(Rroute)   [newInterp eval array get Rroute]
    set R(Rarrows)  [newInterp eval array get Rarrows]

    # Get new node and road data
    set R(Rnnodes) [newInterp eval array get Rnnodes]
    set R(Rnroads) [newInterp eval array get Rnroads]
    set R(Rnsplits) [newInterp eval array get Rnsplits]
    set R(Rnphotos) [newInterp eval array get Rnphotos]

    interp delete newInterp

    # Ignore region data from file, and instead compute it ourselves
    set nids [dict get $R(Rroute) nodes]
    set whichRegions [::Route::RegionsNeeded $R(Rmag) $nids]
    if {$whichRegions ne {}} {
	lassign $whichRegions R(Rregion) R(Rmag) changeRegion
	if {$changeRegion} { set R(Rarrows) {} }
    }

    if {$state(zone) eq "none"} {		;# Loading command line file
	::Zone::GoZone $R(Rzone)
    } elseif {$R(Rzone) ne $state(zone)} {
	set msg "This route belongs to the $R(Rzone) zone.\n"
	append msg "Please change to that zone and reload the file."
	WARN $msg
	return 0
    }

    foreach {err emsg} [::Route::LoadX R $forceLoadRegion] break
    set fname2 [file tail $fname]
    if {$emsg ne ""} {
	WARN "Error loading $fname2\n\n$emsg"
	return $err
    }

    set saveName $fname
    #wm title . "$state(title) -- [file rootname $fname2]"
    INFO "loaded $fname"

    return $err
}
##+##########################################################################
#
# ::Route::LoadX
#
# R(Rversion) 1.01
# R(Rzone)    SFBay
# R(Rregion)  Peninsula
# R(Rmag)     3
# R(Rroute)   [array get route]
# R(Rnnodes)  <new node array data>
# R(Rnroads)  <new road array data>
# R(Rnsplits) <split data>
# R(Rtitle)   My Route Title
#
proc ::Route::LoadX {n_R forceLoadRegion} {
    global state route

    upvar 1 $n_R R
    #::Route::Fixup4 R
    ::Route::FixMag R

    if {[llength $R(Rregion)] == 0 || $R(Rmag) eq ""} {
	set txt "Missing region and magnification information"
	return [list 0 $txt]
    }

    foreach r $R(Rregion) {
	if {! [info exists ::region($r,$R(Rmag),maps)]} {
	    set txt "This route is for a missing region. "
	    append txt "Please download and install the $r region."
	    return [list 0 $txt]
	}
    }

    # Do we need to change region???
    if {$forceLoadRegion} {
	::Region::GoRegion2 $R(Rregion) $R(Rmag)
    } else {
	set n [::Region::IsSubset $R(Rregion)]
	if {$state(region) ne "all" && $n == 0} {
	    set rnames [join $R(Rregion) ", "]
	    set msg "Do you want to change to the $rnames region?"
	    if {[llength $R(Rregion)] > 1} {
		set msg "Do you want to load in multiple regions: $rnames"
	    }

	    set n [tk_messageBox -icon question -message $msg -parent . \
		       -type yesno -title "$state(progname) Open Route"]
	    if {$n ne "yes"} {
		INFO "Loading route cancelled"
		return [list 0 ""]
		}
	    ::Region::GoRegion2 $R(Rregion) $R(Rmag)
	}
    }

    # Add in new node, road and split info
    set n [::Route::LoadNew $R(Rnnodes) $R(Rnroads) $R(Rnsplits) $R(Rnphotos)]
    if {$n == 0} { return [list 0 ""] }

    ::Route::ClearRoute
    set route(title) $R(Rtitle)
    array set route $R(Rroute)			;# Install the loaded route
    set route(start) [lindex $route(nodes) 0]
    set route(tail) [lindex $route(nodes) end]
    ::Route::ApplySplits			;# Handle any split roads
    if {$route(nodes) eq {}} ::Route::ClearRoute;# Empty route case

    set n [catch {
	# Make sure the turn array is okay
	set len [llength $route(nodes)]
	if {! [info exists route(turns)] || [llength $route(turns)] != $len} {
	    set route(turns) "B"
	    append route(turns) [string repeat " N" [expr {$len - 2}]]
	    if {$len > 1} { lappend route(turns) "E"}
	}
	::Display::BestFit
	::Route::StatRoute 1
    } err]

    if {$n} {
	::Route::ClearRoute
	return [list 0 $err]
    }

    if {[info exists R(Rarrows)] && [llength $R(Rarrows)] > 0} {
	array set Rarrows $R(Rarrows)
	::Arrow::UnDumpArrowInfo Rarrows
    } elseif {$state(arrow)} {
	::Arrow::Go .c
    }
    ::RInfo::Refresh?

    return [list 1 ""]
}
##+##########################################################################
#
# ::Route::RegionsNeeded -- returns list of regions needed to
# cover all nodes in $nids. Uses current list of regions if
# possible.
#
# Returns "" if all nodes are outside regions
#
proc ::Route::RegionsNeeded {suggestedMag nids} {
    global state
    # see also ::Favorites::IsRouteVisible

    # Try current region/mag
    set missing [::Data::SetCover::MissingFromCover \
		     $state(region,multi) \
		     $state(mag) \
		     $nids]
    if {$missing eq {}} { return [list $state(region,multi) $state(mag) 0] }

    # If current covers some, try adding in some regions
    if {[llength $missing] < [llength $nids]} {
	set cover [::Data::SetCover::Get $state(mag) $missing]
	lassign $cover rnames missing
	if {$missing eq {}} {
	    return [list [concat $state(region,multi) $rnames] $state(mag) 1]
	}
    }

    # Try with suggested mag
    set cover [::Data::SetCover::Get $suggestedMag $nids]
    lassign $cover rnames missing
    if {$missing eq {}} { return [list $rnames $suggestedMag 1] }


    # Try any mag, from most to least zoomed
    set all {}
    foreach mag $::zone(mags) {
	set cover [::Data::SetCover::Get $mag $nids]
	lassign $cover rnames missing
	if {$missing eq {}} { lappend all [list $rnames $mag 1] ; break}
    }
    return $all
}
##+##########################################################################
#
# ::Route::Fixup4 -- in moving to version 4.0, mag levels changed from
# 2,3 to 14 for the SFBay zone.
#
proc ::Route::Fixup4 {n_R} {
    upvar 1 $n_R R

    if {$R(Rzone) ne "San Francisco Bay Area"} return
    set n [scan $R(Rversion) %f version]
    if {$n == 1 && $version >= 4.0} return
    if {$R(Rmag) == 2 || $R(Rmag) == 3} { set R(Rmag) 14 }
}
proc ::Route::FixMag {n_R} {
    upvar 1 $n_R R

    unset -nocomplain COUNT
    set COUNT($R(Rmag)) 0

    foreach r $R(Rregion) {
	foreach arr [array names ::region $r,*,maps] {
	    set mag [lindex [split $arr ","] 1]
	    incr COUNT($mag)
	}
    }
    if {$COUNT($R(Rmag)) == [llength $R(Rregion)]} return
    foreach mag [lsort -decreasing -integer [array names COUNT]] {
	if {$COUNT($mag) == [llength $R(Rregion)]} {
	    set R(Rmag) $mag
	    return
	}
    }
    return
}
##+##########################################################################
#
# ::Route::LoadNew
#
# Helper for LoadRoute, handles user created roads, nodes and splits. A
# new node/road name consists of two parts: (X1.987654 => 1 & 987654).
# If a new node/road from the route file matches both parts of an existing
# one then we assume they're the same. But if we find a conflict on the
# second part, then we delete ALL existing new nodes/roads.
#
proc ::Route::LoadNew {nnodes nroads nsplits nphotos} {
    global nodes roads route state

    set bad 0
    foreach {nodeid ndata} $nnodes {
	if {[info exists nodes($nodeid)]} continue;# Exact match--same node
	set a -999
	regexp {X(.*)\.(.*)} $nodeid {} a b
	set x [array names nodes "X$a.*"]
	if {[llength $x] > 0} {
	    set bad 1
	    break
	}
    }
    if {! $bad} {
	foreach {rid rdata} $nroads {
	    if {[info exists roads($rid)]} continue ;# Exact match--same road
	    set a -999
	    regexp {Xr(.*)\.(.*)} $rid {} a b
	    set x [array names roads "Xr$a.*"]
	    if {[llength $x] > 0} {
		set bad 1
		break
	    }
	}
    }

    if {$bad} {
	set txt "Do you want to overwrite your newly created roads and nodes\n"
	append txt "with ones for this route?"

	set n [tk_messageBox -icon question -message [WRAPUNIX $txt] -parent . \
		   -type yesno -title "$state(progname) Open Route"]
	if {$n ne "yes"} {
	    INFO "Loading route cancelled"
	    return 0
	}
	::Region::Revert	   ;# Delete all the conflicting nodes and roads
    }

    INFO "Loading custom roads, nodes and splits"
    # Put in the new nodes and roads
    foreach {nodeid ndata} $nnodes {
	if {[info exists nodes($nodeid)]} continue
	::Edit::AddNode2 $nodeid $ndata
    }
    foreach {rid rdata} $nroads {
	if {[info exists roads($rid)]} continue

	set xyz [eval ::Data::AddZ2XY [lrange $rdata 8 9]] ;# Merge Z into XY
	lset rdata 8 $xyz
	::Edit::AddRoad2 $rid $rdata
    }
    foreach {rid sdata} $nsplits {
	set line "S $rid => $sdata"
	::Data::ProcessOneSplit $line
    }

    foreach {phid phdata} $nphotos {
	foreach {lat lon url sdesc ldesc} $phdata break
	::Photo::AddNew $phid $lat $lon $url $sdesc $ldesc
    }

    return 1
}
##+##########################################################################
#
# ::Route::ApplySplits
#
# Takes a route and sees if any road no longer exists because it was split.
# If so, we update the route data. Because split roads can be split again,
# we do multiple passes until all split problems are fixed.
#
proc ::Route::ApplySplits {} {
    global route splits NR

    while {1} {
	set didSplit 0
	set rnodes [lindex $route(nodes) 0]
	set rroads {}
	set rturns [lindex $route(turns) 0]
	foreach nid [lrange $route(nodes) 1 end] rid $route(roads) turn [lrange $route(turns) 1 end] {
	    if {[info exists splits(f,$rid)]} {	;# The road was split
		foreach {nnid rid1 rid2} $splits(f,$rid) break
		lappend rnodes $nnid
		lappend rturns N
		if {[info exists NR($rid1,$nnid,$nid)]} {
		    foreach {rid1 rid2} [list $rid2 $rid1] break
		}
		lappend rroads $rid1
		set rid $rid2

		set didSplit 1
	    }
	    lappend rnodes $nid
	    lappend rturns $turn
	    lappend rroads $rid
	}

	if {! $didSplit} break
	set route(nodes) $rnodes
	set route(roads) $rroads
	set route(turns) $rturns
    }
}
##+##########################################################################
#
# ::Route::GetNewStuff
#
# Returns all the new nodes, new roads and splits that a route
# encounters.
#
proc ::Route::GetNewStuff {n_nnodes n_nroads n_nsplits n_nphotos} {
    global state route nodes roads splits photos

    upvar 1 $n_nnodes nnodes;   unset -nocomplain nnodes
    upvar 1 $n_nroads nroads;   unset -nocomplain nroads
    upvar 1 $n_nsplits nsplits; unset -nocomplain nsplits
    upvar 1 $n_nphotos nphotos; unset -nocomplain nphotos

    foreach nodeid $route(nodes) {		;# All new nodes
	if {! [string match "X*" $nodeid]} continue
	foreach {name alt lat lon cxy} $nodes($nodeid) break
	set nnodes($nodeid) [concat [list $name] $alt [int2lat $lat] \
				 [int2lat $lon]]
    }

    foreach rid $route(roads) {		;# All new roads
	if {! [string match "Xr*" $rid]} continue
	set nroads($rid) $roads($rid)
    }

    foreach rid $route(roads) {
	while {[info exists splits(r,$rid)]} {	;# Road comes from a split???
	    set rid $splits(r,$rid)		;# Yes, here's old road
	    set nsplits($rid) $splits(f,$rid)

	    # Make sure the roads on both sides of a split are remembered
	    foreach ridx [lrange $splits(f,$rid) 1 end] {
		if {[info exists roads($ridx)]} {
		    set nroads($ridx) $roads($ridx)
		}
	    }
	}
    }
    foreach phid [array names photos X*] {
	set nphotos($phid) $photos($phid)
    }
}
##+##########################################################################
#
# ::Route::GetBounds -- returns the extreme lat/lon/alt of a route
#
proc ::Route::GetBounds {{xyz {}}} {
    global route

    if {$xyz eq {}} {
	set xyz [::Route::GetXYZ]
    }
    if {$xyz eq {}} {return [list {} {} {} {} {} {}]}

    foreach {. . lat0 lon0 . . . alt0} [lindex $xyz 0] break
    foreach {. . lat1 lon1 . . . alt1} [lindex $xyz 0] break
    foreach pt $xyz {
	foreach {. . lat lon . . . alt} $pt break
	if {$alt < $alt0} {set alt0 $alt} elseif {$alt > $alt1} {set alt1 $alt}
	if {$lat < $lat0} {set lat0 $lat} elseif {$lat > $lat1} {set lat1 $lat}
	if {$lon < $lon0} {set lon0 $lon} elseif {$lon > $lon1} {set lon1 $lon}
    }
    return [list $lat0 $lon0 $lat1 $lon1 $alt0 $alt1]
}
##+##########################################################################
#
# ::Route::GetBBox -- Returns bounding box (in canvas units) of the route
#
proc ::Route::GetBBox {} {
    global route
    if {$route(nodes) eq ""} { return "" }

    foreach {l t r b} [.c bbox node_[lindex $route(nodes) 0]] break
    foreach {l1 t1 r1 b1} [.c bbox node_[lindex $route(nodes) 0]] break
    foreach rid $route(roads) {
	foreach {l1 t1 r1 b1} [.c bbox road_$rid] break
	set l [Min $l $l1]
	set t [Min $t $t1]
	set r [Max $r $r1]
	set b [Max $b $b1]
    }
    foreach nid $route(nodes) {
	foreach {l1 t1 r1 b1} [.c bbox node_$nid] break
	set l [Min $l $l1]
	set t [Min $t $t1]
	set r [Max $r $r1]
	set b [Max $b $b1]
    }
    return [list $l $t $r $b]
}
##+##########################################################################
#
# ::Route::GetXYZ -- turns all known lat/lon/alt of a route or road into a list
# format: name ele lat lon <waypoint|routepoint> <nid|rid> utm ele2 usgs
#
proc ::Route::GetXYZ {{rid {}} {nid {}}} {
    global route nodes roads NR

    if {$rid eq {} && $nid eq {}} {		;# Get XYZ for current route
	if {$route(start) == -1} {return {}}
	set _roads [concat {{}} $route(roads)]
	set _nodes $route(nodes)
    } elseif {$nid ne {}} {			;# Get for given node
	set _roads {}
	set _nodes $nid
    } else {					;# Get for given road
	foreach {start _nodes} $roads($rid) break
	set _roads [list {} $rid]
	set _nodes [lrange $roads($rid) 0 1]
    }

    set xyzt {}
    foreach rid $_roads to $_nodes {
	if {$rid ne ""} {
	    set xy [lindex $roads($rid) 8]
	    set z [lindex $roads($rid) 9]
	    if {[::Data::IsNorthNode $to $from]} {
		set xy [::Data::XYReverse $xy]
		set z [::Data::Reverse $z]
	    }
	    foreach {a b c d e f} $xy ele $z {
		if {$ele eq {}} {set ele "?"}
		lappend xyzt [list "" $ele [lat2int $a $b $c] \
				  [lat2int $d $e $f] routepoint $rid "" $ele]
	    }
	}
	set ele [lindex $nodes($to) 1]
	set pt [lreplace $nodes($to) 4 4 waypoint $to "" $ele]
	lappend xyzt $pt
	set from $to
    }
    set xyzt [::Route::FixZ $xyzt]
    return $xyzt
}
##+##########################################################################
#
# ::Route::FixZ -- interpolates elevation for all points
#
proc ::Route::FixZ {xyz} {
    set noZ {}					;# List of pts needing Z
    set lastZ ""				;# Last valid Z seen
    set lastDistance 0				;# Distance at lastZ
    set tdist 0					;# Total distance so far

    for {set cnt 0} {$cnt < [llength $xyz]} {incr cnt} {
	foreach {. z1 lat1 lon1} [lindex $xyz $cnt] break
	if {$cnt > 0} {
	    set dist [::Data::Distance $lat0 $lon0 $lat1 $lon1]
	    set tdist [expr {$tdist + $dist}]
	}
	set D($cnt) $tdist

	if {[::BadMath::IsBad $z1]} {		;# No Z here
	    lappend noZ $cnt
	} else {				;# Yea, good Z
	    if {$lastZ eq ""} {set lastZ $z1}
	    set dz [expr {$z1 - $lastZ}]
	    set dd [expr {$tdist - $lastDistance}]
	    foreach i $noZ {
		set perc [expr {($D($i) - $lastDistance) / $dd}]
		set newZ [expr {round($lastZ + $dz * $perc)}]
		lset xyz $i 7 $newZ
	    }
	    set lastZ $z1
	    set lastDistance $tdist
	    set noZ {}
	}
	set lat0 $lat1
	set lon0 $lon1
    }
    if {$lastZ eq ""} {set lastZ 100}
    foreach i $noZ {
	lset xyz $i 7 $lastZ
    }

    return $xyz
}

proc ::Route::GetAtlasText {{default ""}} {
    global route nodes

    set dsm outside
    set segments {}
    foreach nid $route(nodes) {
	foreach {x y} [lindex $nodes($nid) 4] break
	set n [::ClipBox::IsPointInside $x $y]

	if {$dsm eq "outside"} {
	    if {! $n} continue
	    set segment $nid
	    set dsm inside
	} else {
	    if {$n} {
		lappend segment $nid
	    } else {
		lappend segments $segment
		set dsm outside
	    }
	}
    }
    if {$dsm eq "inside"} {
	lappend segments $segment
    }
    if {$segments eq {}} { return $default }

    set first [lindex $segments 0 0]
    set last [lindex $segments 0 end]
    set txt [::Display::PrettyNodeText $first]
    if {$first ne $last} {
	append txt " to [::Display::PrettyNodeText $last]"
    }
    return $txt
}
##+##########################################################################
#
# ::Route::ExtendRoute -- Appends shortest route from end of current
# route to specified node
#
proc ::Route::ExtendRoute {nid} {
    global route

    if {$nid eq "popup"} {
	set nid $::state(popup,who)
    }

    set from [lindex $route(nodes) end]
    if {$from eq ""} { return 1}
    set nid [::Edit::FindNode $nid]
    if {$nid eq "" || $nid eq $from} { return 0}
    set rpath [::Within::GetShortestPath $from $nid]
    if {$rpath eq {}} {
	WARN "You cannot get to node [::Edit::PrettyNode $nid]"
	return 0
    }
    eval ::Route::InsertRoute + $rpath
    return 1
}
##+##########################################################################
#
# ::Route::InsertRoute -- Appends or creates a new route
# start: "+" to append, $nid to create
#
proc ::Route::InsertRoute {start args} {
    if {[llength $args] == 1} { set args [lindex $args 0] }
    if {$start ne "+"} {
	::Route::ClearRoute
	::Route::CheckRoute node $start
    }

    foreach arg $args {
	if {[regexp {^X?n} $arg]} {
	    set nid [::Edit::FindNode $arg]
	    set n [::Route::CheckRoute node $nid]
	    if {! $n} {
		set n [::Route::ExtendRoute $nid]
	    }
	} else {
	    set n [::Route::CheckRoute road $arg]
	}
	if {! $n} { puts "\nBad route insertion: '$arg'"; break }
    }
}
##+##########################################################################
#
# ::Route::GuessTurns -- Computes turns for all unspecified turns
# on the route, using arrow angle data.
#
proc ::Route::GuessTurns {} {
    global route

    set n $route(nodes)
    set r $route(roads)
    set t $route(turns)
    set rid1 ""
    set newTurns {}

    foreach nid $n rid2 $r turn $t {
	while {1} {
	    if {$rid1 eq "" || $rid2 eq ""} break
	    if {$turn ne "N"} break

	    set tag "arrow/$rid1/$nid/$rid2"
	    set arr [array names ::Arrow::ARROWS *,$tag]
	    if {$arr eq {}} break
	    set arrow $::Arrow::ARROWS([lindex $arr 0])
	    foreach {type . angle} $arrow break
	    if {$type eq "uturn"} {
		set turn "U"
	    } elseif {abs($angle) < 35} {
		set turn "S"
	    } elseif {$angle > 0} {
		set turn "R"
	    } else {
		set turn "L"
	    }
	    break
	}
	lappend newTurns $turn
	set rid1 $rid2
    }
    return $newTurns
}
##+##########################################################################
#
# ::Route::Stop&Go -- True if start and end nodes are the same
#
proc ::Route::Stop&Go {} {
    return [expr {[llength $::route(nodes)] > 1 &&
	      [lindex $::route(nodes) 0] eq [lindex $::route(nodes) end]}]
}
##+##########################################################################
#
# ::Route::Email -- Invokes outlook to send email with current
# route as an attachment.
#
# NB. mailto:?subject=Hi&attachment=c:\foo  should work but has
# been disabled in Outlook 2007 for security reasons.
#
proc ::Route::Email {} {
    global state

    if {! [::Data::CanDo email]} {
	if {! $state(windows)} {
	    set emsg "You must be on Windows to email routes."
	} else {
	    set emsg "Email requires the registry package."
	}
	WARN $emsg
	return
    }

    if {$state(email,cmd) eq ""} {
	set n [catch {
	    set cmd [registry get HKEY_CLASSES_ROOT\\mailto\\shell\\open\\command {}]
	}]
	if {$n} {
	    set state(can,email) 0
	    WARN "Cannot locate mailto's registry shell open entry."
	    return
	}
	set n [regexp {^"(.*?)"} $cmd => cmd]
	if {! $n} {
	    regsub {\s[-/].*$} $cmd {} cmd
	}
	set state(email,cmd) $cmd
    }

    # Create temp file for attachment
    set fname [::Data::GetTempFile .klm]
    ::Route::Save2 $fname

    set n [catch {
	exec $state(email,cmd) /a $fname &
	#exec $state(email,cmd) /a $fname /c IPM.Note /m mailto:?subject=Hi%20There  &
    } emsg]
    if {$n} {
	set state(can,email) 0
	WARN "Error trying to send email:\n$emsg"
    }
}
## EON ROUTE
## BON DESCRIPTION
##+##########################################################################
#
# ::Description::Dialog -- puts up our route description dialog
#
proc ::Description::Dialog {} {
    set formats [list "Normal" "Running Totals" "Table" \
		     "Minimal" "Google Earth" "GPS Exchange"]

    # Figure out how many lines and max
    foreach {title header result} [::Description::GetText] break
    set h 1
    incr h [llength [split $header \n]]
    incr h [llength [split $result \n]]
    if {$title ne ""} {
	set h [expr {$h + 1 + [font metric descTitleFont -linespace] /
		     double([font metric descFont -linespace])}]
    }
    if {$h < 10} {set h 10}
    if {$h > 30} {set h 30}
    set w 110

    destroy .d
    toplevel .d
    ::Display::TileBGFix .d
    wm title .d "$::state(progname) Route Description"
    wm withdraw .d
    wm transient .d .
    wm protocol .d WM_DELETE_WINDOW ::Description::Cleanup

    # Menus
    set M .d.menu
    menu $M -tearoff 0
    .d configure -menu $M
    $M add cascade -menu $M.file   -label "File"  -underline 0
    $M add cascade -menu $M.xhelp  -label "Help"  -underline 0

    menu $M.file -tearoff 0
    $M.file add cascade -label "Format" -under 0 -menu $M.file.formats
    $M.file add command -label "Configure" -under 0 \
	-command [list ::Config::Dialog 3]
    $M.file add separator
    $M.file add command -label "Save" -under 0 -command ::Description::Save
    $M.file add command -label "Print" -under 0 -command ::Description::Print
    $M.file add separator
    $M.file add command -label "Dismiss" -under 0 -command ::Description::Cleanup
    if {! [::Data::CanDo printText]} { $M.file entryconfig "Print" -state disabled }

    menu $M.file.formats -tearoff 0
    foreach value $formats {
	$M.file.formats add radiobutton -label $value -underline 0 \
	    -value $value -variable ::Description::dformat
    }

    menu $M.xhelp -tearoff 0
    $M.xhelp add command -label "Help" -under 0 -command [list ::Help::Help "Route Description"]

    # Text region
    ::ttk::scrollbar .d.sb_y -command {.d.t yview} -orient vertical
    text .d.t -height $h -width $w -yscroll {.d.sb_y set} -wrap word \
	-font $::state(desc,font) -undo 1
    #::Display::TileBGFix .d.t

    .d.t tag configure header -background gray75 -font descHeaderFont \
	-borderwidth 2 -relief raised
    .d.t tag configure title -font descTitleFont ;# -justify center
    .d.t tag configure body ;# -borderwidth 2 -relief ridge
    .d.t tag config even -background {}
    .d.t tag config odd -background \#aaffff
    .d.t tag config boldBody -font descBoldFont

    ::my::frame .d.bottom
    eval ::Display::MyComboBox .d.opt ::Description::dformat $formats
    ::Data::UniqueTrace ::Description::dformat ::Description::Describe

    if {[winfo exists .d.opt.menu]} {	;# Old tk_optionMenu
	.d.opt config -width 13
    }
    ::ttk::button .d.save -text "Save Description" -command ::Description::Save
    ::ttk::button .d.print -text "Print Description" -command ::Description::Print
    ::ttk::button .d.d -text Dismiss -command ::Description::Cleanup
    if {! [::Data::CanDo printText]} { .d.print config -state disabled }

    pack .d.bottom -side bottom -fill x
    pack .d.d .d.opt -side right -expand 1 -pady 10 -in .d.bottom
    pack .d.t -side left -expand 1 -fill both
    pack .d.sb_y -side right -expand 0 -fill y

    # Display on right window edge
    ::Display::RightWindow .d
    wm deiconify .d

    ::Description::Describe			;# Fill in the content
}
##+##########################################################################
#
# ::Description::GetData
#
# Returns a list of data points for each entry in the description.
# Each data point is a list comprised of:
#
# turn, roadname, rid, from_name, nid, to, notes, altitude,
# dist to next,	 dist so far,
# climb to next, climb so far,
# desc to next,	 desc so far
#
proc ::Description::GetData {} {
    global route roads nodes state trails NR

    set tdist  0				;# Total distance
    set tclimb 0				;# Total climbing
    set tdesc  0				;# Total descending

    set from $route(start)
    set to -1

    if {$from == -1} { return {} }

    set result {}
    set note "Start!"

    foreach rid $route(roads) turn [::Route::GuessTurns] {
	if {$rid eq ""} break

	foreach {id1 id2} $roads($rid) break ;# Get nodes for this road
	set roadname [lindex $roads($rid) 6]
	regsub -all {\s\(.*?\)} $roadname {} roadname
	if {$to == -1 && ($turn eq "N" || $turn eq "O")} {set turn B}

	if {$from == $id1} { set to $id2 } else { set to $id1 }
	foreach {. dist climb desc type} $NR($rid,$from,$to) break
	set dist [::BadMath::Round1 $dist]

	foreach {name alt} $nodes($from) break
	#if {$name eq {}} {set name "node $from"}

	if {$note eq "" && [info exists trails(dtype,$type)]} {
	    set note $trails(dtype,$type)
	}

	set datum [list $turn $roadname $rid $name $from $to $note \
		       $alt \
		       $dist  $tdist \
		       $climb $tclimb \
		       $desc  $tdesc]
	lappend result $datum

	# Now update totals
	set tdist  [::BadMath::Add $tdist  $dist]
	set tclimb [::BadMath::Add $tclimb $climb]
	set tdesc  [::BadMath::Add $tdesc  $desc]

	set from $to
	set note ""
    }

    foreach {name alt} $nodes($from) break
    if {$turn eq "O"} {set turn N}		 ;# Can't omit ending node

    set datum [list $turn {} {} $name $from {} "Done!" \
		   $alt   \
		   "" $tdist  \
		   "" $tclimb \
		   "" $tdesc]
    lappend result $datum

    return [::Description::Omit $result]
}
##+##########################################################################
#
# ::Description::Omit
#
# Walks through the GetData data structure and compresses out any
# omitted entries.
#
proc ::Description::Omit {data} {

    set result {}
    set current {}

    foreach datum $data {
	foreach {turn roadname rid nname fromname to note alt  \
		     m1 m2 c1 c2 d1 d2} $datum break

	if {$turn ne "O"} {			 ;# Not omitted...
	    lappend result $current		 ;# ...emit current node
	    set current $datum			 ;# ...and make new current node
	    continue
	}

	# We need to update the fields: to m1 c1 d1
	foreach {c_turn c_roadname c_rid c_nname c_fromname c_to c_note c_alt \
		     c_m1 c_m2 c_c1 c_c2 c_d1 c_d2} $current break

	set c_to $to

	set c_m1 [::BadMath::Add $c_m1 $m1]
	set c_c1 [::BadMath::Add $c_c1 $c1]
	set c_d1 [::BadMath::Add $c_d1 $d1]
	set current [list $c_turn $c_roadname $c_rid $c_nname \
			 $c_fromname $c_to $c_note $c_alt \
			 $c_m1 $c_m2 $c_c1 $c_c2 $c_d1 $c_d2]

    }
    lappend result $current
    return [lrange $result 1 end]
}
##+##########################################################################
#
# ::Description::GetNormal
#
# Produces a text string describing the route.
#
proc ::Description::GetNormal { } {
    variable dformat

    set result ""
    set header ""
    set tail ""					 ;# So we can say "ending at"

    foreach var {m2 m3 m4 c2 c3 c4 d2 d3 d4} {	;# For empty route case
	set $var 0
    }
    set data [::Description::GetData]

    set lastRoadname "xxzzyy"
    foreach datum $data {
	foreach {turn roadname rid fromname from to note alt  \
		     m1 m2 c1 c2 d1 d2 } $datum break

	if {$turn ne "B" && $dformat eq "Running Totals"} {
	    append tail " \[[::Data::Units $m2 dist 1],"
	    append tail " [::Data::Units $c2 climb 2],"
	    append tail " [::Data::Units $d2 climb 2]\]"
	}
	if {$to eq {}} break			 ;# Done with all the roads

	if {$turn eq "B"} {			 ;# Beginning is special
	    if {$fromname eq {}} {set fromname "node $from"}
	    set line "Start at $fromname\n"
	    if {$roadname ne ""} {
		append line "  proceed on $roadname\n"
	    }
	} elseif {$turn eq "N"} {		 ;# No turn is special
	    if {$roadname eq ""} {
		set line "Go through $fromname\n"
	    } else {
		if {$roadname == $lastRoadname} {
		    set line "Continue on $roadname\n"
		} else {
		    set line "Go onto $roadname\n"
		}
	    }
	} elseif {$roadname ne ""} {		 ;# Roadname is known
	    if {$turn eq "S"} {
		set line "$::Route::tlabel3($turn) on $roadname\n"
	    } else {
		set line "$::Route::tlabel3($turn) onto $roadname\n"
	    }
	} else {
	    set line "$::Route::tlabel3($turn) at $fromname\n"
	}
	set lastRoadname $roadname

	set c1x [::BadMath::Real $c1]
	set d1x [::BadMath::Real $d1]
	append line "  and go [::Data::Units $m1 dist 0 1], "
	if {$c1x != 0 && $d1x == 0} {
	    append line "climbing [::Data::Units $c1 climb 2]\n"
	} elseif {$c1x == 0 && $d1x > 0} {
	    append line "descending [::Data::Units $d1 climb 2]\n"
	} elseif {$c1x == 0 && $d1x == 0} {
	    append line "with no climbing\n"
	} else {
	    append line "climbing [::Data::Units $c1 climb 2] "
	    append line "and descending [::Data::Units $d1 climb 2]\n"
	}

	append result $tail "\n" $line

	# Last line gets appended along w/ next node
	foreach {name alt} $::nodes($to) break
	if {$name eq {}} {set name "node $to"}
	set tail "  to $name ([::Data::Units $alt climb 2])."
    }
    regsub {to} $tail {ending at} tail
    append result $tail

    append result "\nFor a total of [::Data::Units $m2 dist 1], "
    append result "[::Data::Units $c2 climb 1] climbing "
    append result "and [::Data::Units $d2 climb 1] descending."

    set result [string range $result 1 end]	 ;# Remove leading newline

    return [list $header $result]
}
##+##########################################################################
#
# ::Description::GetTable
#
# Produces a description in a table w/ tabs for easy import into Excel
#
proc ::Description::GetTable {} {
    variable arrows

    set line0 ""
    set line1 ""
    set cols [::Description::GetColumns 0 1]
    foreach item $cols {
	foreach {a b} [split $item "\n"] break
	if {$b eq {}} {set b $a; set a ""}
	append line0 \t $a
	append line1 \t $b
    }
    set header "$line0\n$line1\n"

    set result ""
    set data [::Description::GetData]
    set cols [::Description::GetColumns 0]	;# Selected columns

    set first 1
    set rid ""
    foreach datum $data {
	set rid0 $rid
	foreach {turn rname rid fromname from to note alt m1 m2 c1 c2 d1 d2} \
	    $datum break
	if {$first || $rname eq ""} {
	    if {$fromname eq {}} {set fromname "node $from"}
	    set rname $fromname
	}
	set d(Turn) $::Route::tlabel2($turn)
	set d(Arrow) $arrows($turn)
	set d(Node\ ID) [::Edit::PrettyNode $from]
	set d(At) [::Data::GetLabelText $from $rid0 $rid]
	set d(Distance\ To\ Next) [::Data::Convert $m1 dist]
	set d(Distance\ So\ Far) [::Data::Convert $m2 dist]
	set d(Climb\ To\ Next) [comma [::Data::Convert $c1 climb]]
	set d(Climb\ So\ Far) [comma [::Data::Convert $c2 climb]]
	set d(Descent\ To\ Next) [comma [::Data::Convert $d1 climb]]
	set d(Descent\ So\ Far) [comma [::Data::Convert $d2 climb]]
	set d(Altitude) [comma [::Data::Convert $alt climb]]

	set line ""
	foreach col $cols {
	    if {[string match {*[mk]ph} $col]} {
		foreach {mph unit} $col break
		set soFar [::BadMath::Real $d(Distance\ So\ Far)]
		set seconds [expr {round(60*60*$soFar / $mph)}]
		set ttime [clock format $seconds -gmt 1 -format %H:%M]
		append line "\t" $ttime
	    } else {
		append line "\t" $d($col)
	    }
	}
	append result $line
	append result "\n"
	set first 0
    }
    return [list $header $result]
}
##+##########################################################################
#
# ::Description::GetMinimal -- produces a narrow, minimal description
#
proc ::Description::GetMinimal {} {
    array set suffix {0 " " 1 "*"}
    set turns {}
    set wheres {}
    set dists {}
    set climbs {}
    set alts {}
    set rids {}

    set data [::Description::GetData]
    set max 0
    set row2 "" ; if {$::state(su)} { set row2 "____ " }
    set badM [set badC 0]

    # Build up each unformatted line for each column
    foreach datum $data {
	foreach {turn rname rid fromname from to note alt m1 m2 c1 c2 d1 d2} \
	    $datum break
	if {$::state(su)} {
	    regexp {^n?([A-Zn][0-9]+)} [string map {Xn X} $from] => from
	    set fromname "$from $fromname"
	}
	foreach {line1 line2} [::Description::TwoLines $fromname 15] break
	set max [Max $max [string length $line1] [string length $line2]]

	set m2  [::Data::Convert $m2 dist]
	set c2  [comma [::Data::Convert $c2 climb]]
	set alt [comma [::Data::Convert $alt climb]]

	lappend turns $turn "" ""
	lappend wheres $line1 $line2 ""
	lappend dists "$m2$suffix($badM)" $row2 ""
	lappend climbs "$c2$suffix($badC)" $row2 ""
	lappend alts $alt $row2 ""
	lappend rids $rid "" ""

	set badM [::BadMath::IsBad $m1]
	set badC [::BadMath::IsBad $c1]
    }
    set rids [concat [lrange $rids end-2 end] [lrange $rids 0 end-3]]

    set fmt "%-2s%-${max}s %7s %6s %6s\n"
    if {$::state(su)} {regsub {\n} $fmt " %5s\n" fmt}
    set header [format $fmt T Where Distance Climb Alt Rid]
    regsub {  Distance} $header {Distance} header

    set result ""
    foreach turn $turns where $wheres dist $dists climb $climbs \
	alt $alts rid $rids {
	append result [format $fmt $turn $where $dist $climb $alt $rid]
    }
    regsub -all { +\n} $result \n result
    return [list $header $result]
}

proc ::Description::GetGPX {} {
    set gpx [::GPX::GetRoute]
    return [list "" $gpx]
}
proc ::Description::GetGoogleEarth {} {
    set title $::route(title)
    if {$title eq ""} {
	set title [clock format [clock seconds] -format "%b %d, %Y"]
    }
    set xml [::Google::MakeXML $title]
    return [list "" $xml]
}
##+##########################################################################
#
# ::Description::TwoLines -- breaks a node name into two lines
#
proc ::Description::TwoLines {txt wlen} {
    regsub -all {\(.*?\)} $txt " " txt		;# Remove parentheses
    regsub -all {\s+} [string trim $txt] " " txt ;# Compress spaces

    set len [string length $txt]
    if {$len < $wlen} { return [list $txt ""] }
    set best $len
    foreach index [regexp -all -inline -indices {\s} $txt] {
	set index [lindex $index 0]
	set err [expr {$len / 2 - $index}]
	if {abs($err) < $best} {set best $err}
    }
    if {$best == $len} { return [list $txt ""] }
    set idx [expr {$len / 2 - $best}]
    return [list [string range $txt 0 [expr {$idx-1}]] \
		[string range $txt [expr {$idx+1}] end]]
}
##+##########################################################################
#
# ::Description::GetColumns -- returns all or all active columns
# to be displayed in the route description. Must convert MPH to
# KPH if metric. If pretty, we insert newlines at the right spots.
#
proc ::Description::GetColumns {all {pretty 0}} {
    global state

    set who [expr {$all ? "all" : "selected"}]
    set result {}
    foreach col $state(route,$who) {
	if {[string match "*kph" $col] && $state(units,external) ne "metric"} {
	    scan $col %d speed
	    set speed [::Data::ToEnglish $speed kph]
	    set speed [expr {5 * round($speed/5)}]
	    set col "$speed mph"
	} elseif {[string match "*mph" $col] && $state(units,external) eq "metric"} {
	    scan $col %d speed
	    set speed [::Data::ToMetric $speed mph]
	    set speed [expr {5 * round($speed/5)}]
	    set col "$speed kph"
	} elseif {$pretty} {
	    regsub { ([TS]o )} $col "\n\\1" col	;# Two lines for some headings
	}
	lappend result $col
    }
    return $result
}
##+##########################################################################
#
# ::Description::GetMPHS -- returns all selected speeds
# used by trace
#
proc ::Description::GetMPHS {} {
    set mphs {}
    foreach col [::Description::GetColumns 0] {
	if {[regexp {^(\d+) ([km]ph)} $col => mph unit]} {
	    lappend mphs $mph $unit
	}
    }
    return $mphs
}


proc ::Description::GetText {} {
    variable dformat

    set title [string trim $::route(title)]

    if {$dformat eq "Table"} {
	foreach {header result} [::Description::GetTable] break
    } elseif {$dformat eq "Minimal"} {
	foreach {header result} [::Description::GetMinimal] break
    } elseif {$dformat eq "GPS Exchange"} {
	foreach {header result} [::Description::GetGPX] break
	set title ""
    } elseif {$dformat eq "Google Earth"} {
	foreach {header result} [::Description::GetGoogleEarth] break
	set title ""
    } else {
	foreach {header result} [::Description::GetNormal] break
    }
    set result [string trimright $result]
    return [list $title $header $result]
}
##+##########################################################################
#
# ::Description::Describe
#
# Displays a dialog box with the description of the current route.
# NB. this is also the target of a trace, hence the args parameter.
#
proc ::Description::Describe {args} {
    variable dformat

    if {! [winfo exists .d]} return
    .d.t config -wrap word -font $::state(desc,font)
    foreach {title header result} [::Description::GetText] break

    ::Description::SetTabStops .d.t
    if {$dformat eq "Table"} {
	.d.t config -wrap none
    } elseif {$dformat eq "Minimal"} {
	.d.t config -font descFixedFont
    }

    raise .d
    .d.t delete 1.0 end
    if {$title ne ""} {
	.d.t insert end "\t$title" title \n\n
    }
    foreach line [split [string trimright $header \n] \n] {
	if {$dformat eq "Table"} {
	    .d.t insert end $line\t header \n
	} else {
	    .d.t insert end $line\n
	}
    }

    set lnum 0
    foreach line [split $result \n] {
	incr lnum
	if {$dformat eq "Table"} {
	    set tag [expr {$lnum & 1 ? "odd" : "even"}]
	    #.d.t insert end $line\t [list $tag body] \n
	    ::Description::InsertWithMarkups $line $tag
	} else {
	    .d.t insert end $line\n
	}
    }
    update
    wm geom .d [wm geom .d]
    .d.t config -width 0			;# Avoid resize on font change
}
##+##########################################################################
#
# ::Description::InsertWithMarkups -- emboldens text w/i \x02 markers
#
proc ::Description::InsertWithMarkups {line evenOddTag} {
    set bold 1
    foreach chunk [split $line \x02] {
	set bold [expr {! $bold}]
	set tags [list $evenOddTag body]
	if {$bold} {lappend tags boldBody}
	.d.t insert end $chunk $tags
    }
    .d.t insert end \t [list $evenOddTag body] \n ;# Right align
}
##+##########################################################################
#
# ::Description::Cleanup -- cleans up when Description dialog goes away
# Doesn't catch "destroy .d"
#
proc ::Description::Cleanup {} {
    ::Data::UniqueTrace ::Description::dformat
    destroy .d
}
##+##########################################################################
#
# ::Description::SetTabStops -- figures out tabs stops for the text widget
# for the various columns in table format.
#
proc ::Description::SetTabStops {W} {
    variable ctabs

    set headers {}
    set font [$W cget -font]
    foreach col [::Description::GetColumns 0 1] {
	if {$col == "At"} { set col "zzzTunitas Creek Rd & Lobitos Creek Rd" }
	foreach {line1 line2} [split $col "\n"] break
	if {[font measure $font $line2] > [font measure $font $line1]} {
	    set line1 $line2
	}
	lappend headers $line1
    }

    set ptabs {}				;# Pixel based tab stops
    set ctabs {}				;# Character based tab stops
    set ppos 0					;# Pixel width so far
    set cpos 0					;# Character width so far
    foreach item $headers {
	set len [font measure $font " $item "]
	lappend ptabs [expr {$ppos + $len / 2}] center
	incr ppos $len

	set len [string length $item]
	incr len				;# Space between
	lappend ctabs [expr {$cpos + ($len+1) / 2}]
	incr cpos $len
    }
    lappend ptabs [incr ppos 10]

    $W config -tabs $ptabs
    $W tag configure title -tabs [list [expr {$ppos/2}] center]
}
##+##########################################################################
#
# ::Description::Save
#
# Saves the route description
#
proc ::Description::Save {{fname ""}} {
    variable saveName
    variable dformat
    global state route

    if {[::Description::IsEmpty]} { return 0 }	;# Nothing to save
    set fname [::Description::GetSaveFilename $fname]
    if {$fname eq ""} {return 0}
    set saveName $fname

    set n [catch {set fout [open $fname w]} err]
    if {$n} {
	WARN "Error saving Route Description: $err"
	return 0
    }

    # Table format may/may not keep tabs
    set ext [string tolower [file extension $fname]]
    if {$dformat eq "Table"} {
	if {$ext eq ".txt" || $ext eq ".pdf"} {	;# Remove tabs
	    set txt [::Description::ExtractText "spaces"]
	} else {
	    set txt [::Description::ExtractText]
	}
    } else {
	set txt [::Description::ExtractText]
    }

    if {$ext eq ".pdf"} {
	set txt [::Description::GetPDF $txt]
	fconfigure $fout -translation binary
    } elseif {$ext eq ".htm" || $ext eq ".html"} {
	set txt [::Description::GetHTML $txt]
    }
    puts -nonewline $fout $txt
    close $fout
    INFO "saved Route Description in $fname"
    return 1
}
##+##########################################################################
#
# ::Description::GetSaveFilename -- gets file to save description to
#
proc ::Description::GetSaveFilename {fname} {
    variable saveName
    variable dformat

    if {$fname ne ""} {return $fname}

    if {$dformat eq "GPS Exchange"} {
	set types {{"GPS Exchange" .gpx}}
    } elseif {$dformat eq "Google Earth"} {
	set types {{"Google Earth" .kml}}
    } else {
	set types {}
	if {$dformat eq "Table"} {
	    lappend types {"Excel Spreadsheet" .xls}
	}
	lappend types {"Text Files" .txt}
	if {$dformat ne "Minimal"} {
	    lappend types {"Web Page" ".html .htm"}
	}
	if {[::Data::CanDo pdfText]} {
	    lappend types {"PDF Files" .pdf}
	}
	lappend types {"All Files" *}
    }
    set ext [lindex $types 0 1]
    set fname [tk_getSaveFile -defaultextension $ext -filetypes $types \
		   -title "$::state(progname) Save Description" \
		   -initialdir [file dirname $saveName] \
		   -initialfile [file tail [file rootname $saveName]]]
    return $fname
}
##+##########################################################################
#
# ::Description::GetPDF -- converts description text into pdf
#
proc ::Description::GetPDF {txt} {
    variable dformat

    puts "format: '$dformat'"
    puts "::Text2PDF::Configure -landscape [expr {$dformat eq {Table}}]"
    ::Text2PDF::Configure -landscape [expr {$dformat eq "Table"}]
    set pdf [::Text2PDF::Text2PDF $txt]
    return $pdf
}
##+##########################################################################
#
# ::Description::Print -- prints text description to default printer
#
proc ::Description::Print {} {
    set fname [file join $::state(wdir) "Klimb Route Description.txt"]
    if {[::Description::Save $fname]} {
	set n [catch {PrintText $fname} err]
	if {$n} {
	    WARN "Error printing ride description: $err"
	}
    }
}
##+##########################################################################
#
# ::Description::IsEmpty -- returns true if description is empty
#
proc ::Description::IsEmpty {} {
    set data [.d.t get 0.0 end]
    set data [string trimright $data]
    if {$data eq ""} { return 1 }
    return 0
}
##+##########################################################################
#
# ::Description::ExtractText
#
# Grabs the text out of the description window. For table format we maybe
# convert tabs to spaces, handling center tabs correctly.
#
proc ::Description::ExtractText {{convertToSpaces ""}} {
    variable dformat
    variable ctabs

    set start [lindex [concat 1.0 [.d.t tag range title]] end]
    set data [.d.t get $start end]		;# What to save
    set data [string trimright $data]
    if {$data eq {}} {return ""}		;# Nothing to save

    if {$dformat ne "Table"} { return $data }

    regsub -all -line {^\t} $data {} data	;# Kill initial tab on each line
    regsub -all -line {\t$} $data {} data	;# Kill trailing tab

    if {$convertToSpaces eq ""} {return $data}

    # Here to convert tab-delimited into space-delimited
    set output ""
    foreach line [split $data \n] {
	set items [split $line \t]
	set result ""

	foreach item $items tab $ctabs {
	    set pos [string length $result]
	    set len [string length $item]
	    set start [expr {$tab - $len/2}]    ;# Where text should start
	    set pad [expr {$start - $pos}]	;# How much padding is needed
	    if {$pad <= 0} { set pad 1}
	    append result [string repeat " " $pad] $item
	}
	append output [string range $result 1 end] \n
    }

    return $output
}

proc ::Description::GetHTML {txt} {
    variable dformat

    if {$dformat eq "Table"} {
	set lines [split $txt \n]
	set header1 [split [lindex $lines 0] \t]
	set header2 [split [lindex $lines 1] \t]
	set header [::Description::GetHTMLHeader $header1 $header2]
	set body [::Description::GetHTMLBody [lrange $lines 2 end]]
    } else {
	set header ""
	set body [::Data::HTMLSafe $txt]
	regsub -all -line {$} $body {<br>} body
	while {[regsub -all -line {^( *) } $body {\1\&nbsp;} body]} {
	}
    }

    set html "<html>\n<head>\n<title>KLIMB Route Description</title>\n</head>\n"
    append html "<div align='center'>\n"
    append html "<font size=36><strong>KLIMB Route Description</strong></font>"
    set title [string trim $::route(title)]
    if {$title eq ""} {
	set title [clock format [clock seconds] -format "%b %d, %Y"]
    }
    append html "  <br><font size=28 color='red'><strong>"
    append html "[::Data::HTMLSafe $title]</strong></font>"

    append html "\n<br><br><br>\n"

    append html "<table>\n<tr><td>\n"
    append html "<table border=1 cellspacing=0>\n"
    append html $header
    append html $body
    append html "</table>\n"
    append html "</td></tr>\n<tr><td align='right'>\n"
    append html "  <font color='#6f6f6f' size=-1>&copy;2008 "
    append html "<a href='http://www.klimb.org/'>www.klimb.org</a></font>\n"
    append html "</td></tr>\n</table>\n"
    append html "</div>\n</body>\n</html>"
    return $html
}
proc ::Description::GetHTMLHeader {header1 header2} {
    set html "<tr bgcolor='silver'>\n"
    foreach cell1 $header1 cell2 $header2 {
	set cell1 [Data::HTMLSafe [string trim $cell1]]
	set cell2 [Data::HTMLSafe [string trim $cell2]]

	append html "  <th align='center'>"
	if {$cell1 eq ""} {
	    append html $cell2
	} else {
	    append html $cell1 "<br>" $cell2
	}
	append html "</th>\n"
    }
    return $html
}


proc ::Description::GetHTMLBody {lines} {
    set html {}
    set lnum 0
    foreach line $lines {
	regsub {\t$} $line {} line
	incr lnum
	if {$lnum & 1} {
	    append html "<tr bgcolor='cyan'>\n"
	} else {
	    append html "<tr>\n"
	}
	foreach cell [split $line \t] {
	    append html "  <td align='center'>"
	    set cell [Data::HTMLSafe [string trim $cell]]
	    if {$cell eq ""} {
		append html "&nbsp;"
	    } else {
		append html $cell
	    }
	    append html "</td>\n"
	}
	append html "</tr>\n"
    }
    return $html
}
## EON DESCRIPTION
## BON PROFILE
##+##########################################################################
#
# ::Profile::Profile
#
# Creates a climbing profile of the current route
#
proc ::Profile::Profile {{gps {}} {w 760} {h 380}} {
    global pro
    variable show

    unset -nocomplain pro
    set pro(gps) [expr {$gps ne ""}]
    if {! $pro(gps)} {
	set data [::Profile::GetData]
    } else {
	set data [::GPS::GetProfileData $gps]
    }
    if {[llength $data] == 0} return

    destroy .pro
    toplevel .pro
    wm title .pro "$::state(progname) Route Profile"
    wm protocol .pro WM_DELETE_WINDOW { .pro.b invoke ; destroy .pro }
    bind .pro <Control-w> { .pro.b invoke ; destroy .pro }

    wm transient .pro .
    wm withdraw .pro
    wm minsize .pro 250 350

    foreach {pro(xmin,data) pro(xmax,data) pro(ymin,data) pro(ymax,data) \
		 pro(zmax,data) pro(qmax,data)} $data break
    set pro(data) [lindex $data 6]		;# Grab the node info
    set pro(zmin,data) 0			;# For climbing graph

    # Now create the display
    pack [::my::frame .pro.bottom] -side bottom -fill x
    ::ttk::button .pro.ps -text "Save Profile" -command ::Profile::Save
    ::ttk::button .pro.print -text "Print Profile" \
	-command {::Print::Dialog profile}
    if {! [::Print::CanPrint 1]} {.pro.print config -state disabled}
    ::ttk::button .pro.b -text Dismiss -command {
	::Display::HighlightNode2 -1 ; destroy .pro }

    ::my::frame .pro.f -borderwidth 2 -relief ridge
    canvas .pro.c -bd 0 -highlightthickness 0
    ::Display::TileBGFix .pro.c
    ::my::label .pro.msg -textvariable ::Profile::show(msg) -justify left \
	;# -padx 10
    ::my::label .pro.grad -anchor w -textvariable ::Profile::show(grad) \
	-justify left -width 25
    set bhlp "Click and drag on profile\nto compute gradient"
    ::Balloon::Create .pro.grad static gradient $bhlp $bhlp

    ::ttk::frame .pro.opts
    ::ttk::checkbutton .pro.z -text "Accumulated Climbing" \
	-command ::Profile::Redraw -variable ::Profile::show(z)
    ::ttk::checkbutton .pro.lbl -text "Show Labels" \
	-command ::Profile::Redraw -variable ::Profile::show(labels)
    ::ttk::checkbutton .pro.3d -text "3D Graph" \
	-command ::Profile::Redraw -variable ::Profile::show(ribbon)
    ::ttk::checkbutton .pro.config -text "Configure" \
	-command ::Profile::Configure -variable ::Profile::show(configure)
    set ::Profile::show(configure) 0
    if {$pro(gps)} {
	.pro.lbl config -state disabled
	#.pro.3d config -state disabled
	#set ::Profile::show(ribbon) 0
    }

    grid .pro.ps .pro.print .pro.b -in .pro.bottom -sticky ns -pady 10
    grid columnconfigure .pro.bottom {0 1 2} -weight 1
    pack .pro.f -side top -fill both -expand 1

    grid .pro.c - - -in .pro.f -row 0 -sticky news
    grid .pro.msg .pro.grad .pro.opts -in .pro.f -sticky n
    grid .pro.z -in .pro.opts -sticky w
    grid .pro.lbl -in .pro.opts -sticky w
    #grid .pro.3d -in .pro.opts -sticky w
    grid .pro.config -in .pro.opts -sticky w
    grid columnconfigure .pro.f 1 -weight 1
    grid columnconfigure .pro.f 2 -pad 10
    grid rowconfigure .pro.f 0 -weight 1

    ::Profile::Draw 0 $w $h
    ::Display::CenterWindow .pro
    wm deiconify .pro
    update
    bind .pro.c <Configure> ::Profile::Redraw
}
##+##########################################################################
#
# ::Profile::GetSizes -- Compute tick sizes, margins, scaling etc.
#
proc ::Profile::GetSizes {} {
    variable show
    global pro

    if {! [info exists pro(xmax)]} {
	set ticks [::Profile::GetTickSizes \
		       $pro(xmin,data) $pro(xmax,data) \
		       $pro(ymin,data) $pro(ymax,data) \
		       $pro(zmin,data) $pro(zmax,data)]
	foreach {pro(xt) pro(yt) pro(zt)} $ticks break
	set pro(xt2) [expr {$pro(xt) <= 10 ? 1 : 10}]
	set pro(xmin) $pro(xmin,data)
	set pro(xmax) [expr {int(ceil($pro(xmax,data)/1.0/$pro(xt))) * $pro(xt)}]
	set pro(ymin) [expr {int($pro(ymin,data) / $pro(yt)) * $pro(yt)}]
	set pro(ymax) [expr {int(ceil($pro(ymax,data)/1.0/$pro(yt))) * $pro(yt)}]
	set pro(zmin) $pro(zmin,data)
	set pro(zmax) [expr {int(ceil($pro(zmax,data)/1.0/$pro(zt))) * $pro(zt)}]
	if {$pro(zmax) <= $pro(zmin)} { set pro(zmax) [expr {$pro(zmin) + 10}]}

	foreach a {xmin xmax xt ymin ymax yt zmin zmax zt} {
	    set pro($a,nice) $pro($a)
	}
    }

    # Some display parameters
    set pro(tm) [font metrics bigBold -linespace] ;# Top margin
    set pro(lm) 50				;# Left margin
    set pro(rm) 60				;# Right margin
    set pro(needLabels) [expr {$show(labels) && ! $pro(gps)}]
    set pro(bm) [expr {$pro(needLabels) ? 160 : 30}] ;# Bottom margin

    set pro(gw) [expr {$pro(w) - $pro(lm) - $pro(rm)}]
    set pro(gh) [expr {$pro(h) - $pro(tm) - $pro(bm)}]
    if {$pro(needLabels) && $pro(gh) > 200} {
	set excess [expr {$pro(gh) - 200}]
	set pro(bm) [expr {$pro(bm) + $excess/3}]
	set pro(gh) [expr {$pro(gh) - $excess/3}]
    }

    set pro(Ox) $pro(lm)			;# Graph origin
    set pro(Oy) [expr {$pro(tm) + $pro(gh)}]
    set pro(Oz) $pro(Oy)			;# Altitude graph

    # Compute x,y scaling factors
    set pro(sx) [expr {1.0 * $pro(gw) / ($pro(xmax) - $pro(xmin))}]
    set pro(sy) [expr {1.0 * $pro(gh) / ($pro(ymax) - $pro(ymin))}]
    set pro(sz) [expr {1.0 * $pro(gh) / ($pro(zmax) - $pro(zmin))}]
}
##+##########################################################################
#
# ::Profile::GetTickSizes -- Gets nice values for our tick interval
#
proc ::Profile::GetTickSizes {xmin xmax ymin ymax zmin zmax} {
    global pro

    set dx [expr {$xmax - $xmin}]
    set xt [expr {$dx < 8 ? 1 : $dx < 10 ? 2 : 5}]
    while {$dx/$xt > 15} {	;# Not more than 15 ticks total
	set xt [expr {$xt*2}]
    }

    set dy [expr {$ymax - $ymin}]
    set yt [expr {$dy < 50 ? 10 : $dy < 100 ? 25 :
		  $dy < 1000 ? 100 : $dy < 2000 ? 500 : 1000}]
    set dz [expr {$zmax - $zmin}]
    set zt [expr {$dz < 50 ? 10 : $dz < 100 ? 25 :
		  $dz < 1000 ? 100 : $dz < 2000 ? 250 : $dz < 5000 ? 500 :
		  $dz < 10000 ? 1000 : 5000}]

    return [list $xt $yt $zt]
}
##+##########################################################################
#
# ::Profile::Draw
#
# Draws the actual profile display
#
proc ::Profile::Redraw {} { ::Profile::Draw 1 0 0 }
proc ::Profile::Draw {resize w h} {
    variable show
    variable colors
    variable sizes
    variable labels
    variable gpsPts {}
    global pro route

    set C .pro.c
    if {! [winfo exists $C]} return
    if {$resize} {
	$C delete all			 ;# Remove existing graph
	set pro(w) [winfo width	 $C]
	set pro(h) [winfo height $C]
    } else {
	set pro(w) $w
	set pro(h) $h
	$C config -width $pro(w) -height $pro(h)
    }

    ::Profile::GetSizes
    ::Profile::DrawBackground $C

    set show(msg) "Distance: $::msg(dist)\n"
    append show(msg) "Climb:\t $::msg(climb)\n"
    append show(msg) "Descent:\t $::msg(desc)"
    set show(grad) "Rise:\t ?\nRun:\t ?\nGradient: ?"
    set title $route(title)
    if {$title eq ""} {set title "KLIMB Route Profile Graph"}
    $C create text [expr {$pro(w)/2}] 1 -text $title -tag title \
	-anchor n -font bigBold

    # Actual profile
    set pxy {}					;# Graph coordinates
    set zxy {}					;# Coords for altitude graph
    set rxy {}					;# Coords for one road
    set gxy {}					;# GPS line
    set labels {}				;# All profile labels
    set X [lindex $pro(data) 0 1]		;# Last position
    set Y [lindex $pro(data) 0 2]
    set TCLIMB [lindex $pro(data) 0 4]
    set CXY [::Profile::Pos2Canvas $C $X $Y]
    set RID ""

    foreach pt $pro(data) {
	foreach {nodeid x y quality tclimb rid turn} $pt break
	if {$quality & 1} {
	    ::Profile::UnknownData $C $X $Y $x $y $pro(ymin)
	}
	if {$rid != $RID} {			;# Road change, add balloon help
	    ::Profile::BalloonRoad $C $RID $pro(ymin) $rxy
	    set rxy [lrange $rxy end-1 end]
	}

	set cxy [::Profile::Pos2Canvas $C $x $y]
	if {$X < $pro(xmin) && $x > $pro(xmin)} { ;# Need fake starting point
	    foreach {cx0 cy0} $CXY {cx1 cy1} $cxy break
	    foreach {cx .} [::Profile::Pos2Canvas $C $pro(xmin) $pro(ymin)] break
	    set k [expr {($cx-$cx0) / double($cx1-$cx0)}]
	    set cy [expr {$cy0 + $k * ($cy1-$cy0)}]
	    lappend pxy $cx $cy

	    set z [expr {$TCLIMB + $k * ($tclimb - $TCLIMB)}]
	    set zxy [concat $zxy [::Profile::Pos2CanvasZ $C $pro(xmin) $z]]
	}
	if {$x > $pro(xmax)} {			;# Need fake ending point
	    foreach {cx0 cy0} $CXY {cx1 cy1} $cxy break
	    foreach {cx .} [::Profile::Pos2Canvas $C $pro(xmax) $pro(ymin)] break
	    set k [expr {($cx-$cx0) / double($cx1-$cx0)}]
	    set cy [expr {$cy0 + $k * ($cy1-$cy0)}]
	    lappend pxy $cx $cy
	    set x [expr {$X + $k * ($x-$X)}]

	    set z [expr {$TCLIMB + $k * ($tclimb - $TCLIMB)}]
	    set zxy [concat $zxy [::Profile::Pos2CanvasZ $C $x $z]]

	    break
	}
	if {$x >= $pro(xmin) && $x <= $pro(xmax)} {
	    lappend rxy $x $y
	    if {$tclimb ne {}} {
		set zxy [concat $zxy [::Profile::Pos2CanvasZ $C $x $tclimb]]
	    }

	    if {$nodeid != -1} { ;# Not a half-way data point
		set xy [::Display::MakeBox $cxy $sizes(nsize)]
		set tag "node_$nodeid"
		$C create oval $xy -fill $colors(ncolor) \
				     -tag [list node $tag]
		$C bind $tag <Double-Button-1> \
				     [list ::Display::LocateNode $nodeid]

		::Balloon::Create [list $C $tag] node $nodeid

		if {$turn ne "O"} { ;# Label non-skipped nodes
		    lappend labels $cxy $nodeid $rid
		}
	    } elseif {$quality & 2} {		;# Exact altitude
		#set xy [::Display::MakeBox $cxy $sizes(esize)]
		#$C create oval $xy -fill $colors(ecolor) -tag cross
	    } elseif {$quality & 4} {		;# GPS altitude
		eval lappend gpsPts $cxy
		#if {$sizes(gsize) == 0} {
		#    eval lappend gxy $cxy
		#} else {
		#    set xy [::Display::MakeBox $cxy $sizes(gsize)]
		#    $C create oval $xy -fill $colors(gcolor) \
		#	-tag {cross gps} -outline $colors(gcolor)
		#}
	    }

	    set pxy [concat $pxy $cxy]
	}
	set X $x ; set Y $y; set RID $rid; set CXY $cxy; set TCLIMB $tclimb
    }
    if {$gxy ne {}} {
	$C create line $gxy -tag {cross gps} -fill $colors(gcolor)
    }

    ::Profile::BalloonRoad $C $RID $pro(ymin) $rxy   ;# Don't forget last road

    # NB. pro(...) are NOT in canvas coordinates
    set pxy [concat $pxy [::Profile::Pos2Canvas $C $x $pro(ymin)]]
    #set pxy [concat [lindex $pxy 0] [lindex $pxy end] $pxy]
    set pro(pxy) $pxy
    if {$show(z)} {
	$C create line $zxy -fill $colors(zcolor) -width 2 -tag zgraph
    }
    if {$pro(needLabels)} ::Profile::DoLabels
    ::Profile::Ribbon $C
    if {$show(ribbon)} { $C delete cross}

    bind $C <Button-1> [list ::Profile::Mousing $C down %x %y]
    bind $C <B1-Motion> [list ::Profile::Mousing $C move %x %y]
    #bind $C <ButtonRelease-1> [list ::Profile::Mousing $C up %x %y]
    ::Profile::Raise $C
}
##+##########################################################################
#
# ::Profile::Raise -- Makes sure everything is layered correctly
#
proc ::Profile::Raise {C} {
    $C raise axis
    $C raise cross
    $C raise lbl
    $C raise bad
    $C raise road
    $C raise node
    $C raise zgraph
    $C raise zlabel
    $C raise zcaption
    $C raise title
}
##+##########################################################################
#
# ::Profile::Ribbon -- Creates 3d affect for our profile graph
# Uses painter's algorithm for clipping
#
proc ::Profile::Ribbon {C} {
    variable Ribbon
    global pro state

    if {$state(pro,pp) > 90} {
	for {set i [expr {([llength $pro(pxy)]/2) - 2}]} {$i >= 0} {incr i -1} {
	    ::Profile::RibbonSegment $C $i
	}
    } else {
	for {set i 0} {$i < ([llength $pro(pxy)] / 2)-1} {incr i} {
	    ::Profile::RibbonSegment $C $i
	}
    }
}
##+##########################################################################
#
# ::Profile::RibbonSegment -- Draws ribbon graph for one segment
#
proc ::Profile::RibbonSegment {C idx {clr ""}} {
    variable Ribbon
    variable show
    global pro pxy state

    set pxy $pro(pxy)
    set xLeft [lindex $pxy 0]
    set yBottom [lindex $pxy end]

    set offsetLen [expr {$state(pro,len) / ( $::Profile::show(labels) ? 2 : 1)}]
    set offsetLen $state(pro,len)
    set rad [expr {$state(pro,pp) * acos(-1) / 180}]
    set dx [expr {$offsetLen * cos($rad)}]
    set dy [expr {-$offsetLen * sin($rad)}]
    set offsetXY [list $dx $dy]

    foreach {x0 y0 x1 y1} [lrange $pxy [expr {$idx*2}] [expr {$idx*2+3}]] break
    if {! $show(ribbon)} {
	$C create line $x0 $y0 $x1 $y1 -fill black
    } else {
	set p0 [list $x0 $y0]
	set p1 [list $x1 $y1]
	set q0 [::Data::VAdd $p0 $offsetXY]
	set q1 [::Data::VAdd $p1 $offsetXY]

	#set ribbonXY [concat $p0 $q0 $q1 $p1]
	set ribbonXY [::Profile::RibbonXY $p0 $p1 $q0 $q1]
	set beta [::Data::GetAngle $p0 $p1] ;# Segment slope
	if {$clr eq ""} {
	    set clr gray[expr {99-round(abs($beta - 360))}]
	}
	$C create poly $ribbonXY -tag ribbon -fill $clr -outline black
    }

    ::Profile::RibbonPaint $C $x0 $y0 $x1 $y1 $yBottom
}
##+##########################################################################
#
# ::Profile::RibbonXY -- Clips ribbon segment to the y axis
#
proc ::Profile::RibbonXY {p0 p1 q0 q1} {
    global pro

    set xy [concat $p0 $q0 $q1 $p1]
    set clipLine [lindex $pro(origin) 0]
    if {$clipLine <= [lindex $q0 0]} { 		;# No overlap
	return $xy
    }
    set bottom [::Data::Intersect $p0 $q0 $pro(origin) $pro(yAxis)]
    if {$clipLine < [lindex $q1 0]} {		;# Clips left side of rhombus
	set left [::Data::Intersect $q0 $q1 $pro(origin) $pro(yAxis)]
	set xy [concat $p0 $bottom $left $q1 $p1]
    } else {					;# Clips top side of rhombus
	set top [::Data::Intersect $p1 $q1 $pro(origin) $pro(yAxis)]
	set xy [concat $p0 $bottom $top $p1]
    }
    return $xy
}
##+##########################################################################
#
# ::Profile::RibbonPaint -- Paints in the front part of a profile segment
# with our bands
#
proc ::Profile::RibbonPaint {C x0 y0 x1 y1 yBottom} {
    variable bands
    variable colors

    set yTop [expr {min($y0, $y1)}]
    set yMid [expr {max($y0, $y1)}]

    set band 1
    foreach yBand $bands {
	set band [expr {1 - $band}]
	set clr $::Profile::colors(band,$band)

	if {$yBand <= $yTop} {			;# Entirely w/i band
	    set xy [list $x0 $y0 $x1 $y1 $x1 $yBottom $x0 $yBottom]
	    $C create poly $xy -tag {ribbon paint} -fill $clr
	    break
	}
	if {$yBand >= $yMid} {			;# Need the full band
	    set xy [list $x0 $yBand $x1 $yBand $x1 $yBottom $x0 $yBottom]
	    $C create poly $xy -tag {ribbon paint} -fill $clr
	} else {				;# Top segment crosses band
	    set dy [expr {$y1 - $y0}]
	    set dx [expr {$x1 - $x0}]
	    set k [expr {($yBand - $y0) / double($dy)}]
	    set x [expr {$x0 + $k * $dx}]  ;# Where top line crosses yBand

	    if {$y0 > $y1} {		  ;# Sloping up
		set xy [list $x0 $y0 $x $yBand $x1 $yBand \
			    $x1 $yBottom $x0 $yBottom]
		#set xy2 [list $x $yBand $x1 $y1 $x1 $yBand]
		set x0 $x
		set y0 $yBand
	    } else {			;# Sloping down
		set xy [list $x0 $yBand $x $yBand \
			    $x1 $y1 $x1 $yBottom $x0 $yBottom]
		#set xy2 [list $x0 $yBand $x0 $y0 $x $yBand]
		set x1 $x
		set y1 $yBand
	    }
	    $C create poly $xy -tag {ribbon paint} -fill $clr
	    #set band [expr {1 - $band}]
	    #$C create poly $xy2 -tag {ribbon paint} \
		-fill $::Profile::colors(band,$band)
	    #break
	}
	set yBottom $yBand
    }
}

##+##########################################################################
#
# ::Profile::DoLabels -- displays node labels on our graph
#  labels => $cxy $nid $rid
#
proc ::Profile::DoLabels {} {
    variable labels

    if {! $::pro(needLabels)} return
    if {! [winfo exists .pro]} return

    .pro.c delete lbl

    set ymin [lindex [::Profile::Pos2Canvas .pro.c 0 $::pro(ymin)] 1]
    incr ymin 20
    set ymin2 [expr {$ymin-5}]
    set lastTxt ""
    for {set idx 0} {$idx < [llength $labels]} {incr idx 3} {
	foreach {xy nid rid0 . . rid1} [lrange $labels $idx end] break

	set txt [::Data::GetLabelText $nid $rid0 $rid1]
	if {$txt eq ""} continue
	set img ::img::profile::$nid,$rid0,$rid1
	::Display::RotateTextImage2 $img $txt 130

	foreach {x y} $xy break
	set tag lbl_$idx
	.pro.c create line $x $ymin2 $x $y -tag [list lbl $tag]
	incr x 3
	.pro.c create image $x $ymin -tag [list lbl $tag] -anchor n -image $img
	.pro.c bind $tag <Button-3> [list ::Profile::LabelClick $tag %X %Y]
    }
}
##+##########################################################################
#
# ::Profile::LabelClick -- Pops up menu allowing you to delete
# a label
#
proc ::Profile::LabelClick {tag x y} {
    .delpopup entryconfig 0 -label "Delete label" \
	-command [list .pro.c delete $tag]
    tk_popup .delpopup $x $y
}
##+##########################################################################
#
# ::Profile::DeleteLabelImages -- When a road/node gets text update
# we need to update profile labels also
#
proc ::Profile::DeleteLabelImages {id} {
    foreach img [info commands ::img::profile::*$id*] {
	image delete $img
    }
    if {! [winfo exists .pro]} return
    ::Profile::DoLabels
    ::Profile::Raise .pro.c
}
##+##########################################################################
#
# ::Profile::UnknownData
#
# Handles marking a portion of the profile map as uncertain.
#
proc ::Profile::UnknownData {C dist1 alt1 dist2 alt2 alt0} {
    set xy [::Profile::Pos2Canvas $C $dist1 $alt1 $dist1 $alt0 $dist2 $alt0 \
		$dist2 $alt2]
    $C create poly $xy -tag bad -stipple gray50 \
	-fill red ;# -outline red -width 2 -dash 1
}
##+##########################################################################
#
# ::Profile::BalloonRoad -- creates polygon w/ balloon help bindings
#
proc ::Profile::BalloonRoad {C rid ymin rxy} {
    if {$rxy eq {}} return
    set dist0 [lindex $rxy 0]
    set dist1 [lindex $rxy end-1]
    set xy [eval ::Profile::Pos2Canvas $C $rxy $dist1 $ymin $dist0 $ymin]
    $C create poly $xy -fill {} -tag [list road road_$rid]
    ::Balloon::Create [list $C road_$rid] road $rid
}
##+##########################################################################
#
# ::Profile::GetData
#
# Loops through the route and builds an auxiliary data structure holding
# info to build the profile from. The data consists of:
# 0 distance <min altitude> <max altitude> climb desc <node item>...
# <node item> ::= <dest node> <total dist> altitude quality <total climb> <rid> <turn>
#    <dest node> is -1 for midpoint
#    quality: bit 1 is bad, bit 2 is exact (0 => interpolated)
#
proc ::Profile::GetData {} {
    global route roads nodes NR
    variable lastAlt 0

    if {[llength $route(roads)] == 0} return

    # Find first valid altitude
    set alt 0
    foreach nid $route(nodes) {
	if {! [::BadMath::IsBad [lindex $nodes($nid) 1]]} {
	    set alt [::Data::Convert [lindex $nodes($nid) 1] climb]
	    break
	}
    }
    set lastAlt $alt

    set max [set min $alt]
    set tdist 0
    set tclimb 0
    set tdesc [::Data::Convert \
		   [expr {abs([::BadMath::Real $route(desc)])}] climb]
    set rid [lindex $route(roads) 0]
    set turn [lindex $route(turns) 0]
    set result [list [list $route(start) $tdist $alt 2 0 $rid $turn]] ;# First node

    foreach from $route(nodes) rid $route(roads) turn [lrange $route(turns) 1 end] {
	if {$rid eq {}} break
	set data [::Profile::ProfileRoad $from $rid]
	set data [lrange $data 1 end]		;# Skip starting node part
	# Go through and accumulate total distance and climbing
	for {set idx 0} {$idx < [llength $data]} {incr idx} {
	    foreach {. dist alt . climb} [lindex $data $idx] break
	    lset data $idx 1 [expr {$dist + $tdist}]
	    lset data $idx 4 [expr {$climb + $tclimb}]

	    set max [Max $max $alt]
	    set min [Min $min $alt]
	}
	set tdist  [lindex $data end 1]
	set tclimb [lindex $data end 4]
	lset data end 6 $turn			;# Record our turn
	set result [concat $result $data]
    }
    set result [::Profile::FixTotalClimbing $result]

    return [list 0 $tdist $min $max $tclimb $tdesc $result]
}
##+##########################################################################
#
# ::Profile::FixTotalClimbing -- applies the Avocet hysteresis
# algorithm to the accumulated climbing data.
#
proc ::Profile::FixTotalClimbing {result} {
    set z {}
    foreach datum $result {
	lappend z [lindex $datum 2]
    }
    set avocet [AvocetHysteresis $z]
    for {set i 0} {$i < [llength $result]} {incr i} {
	set correct [lindex $avocet $i]
	lset result $i 4 $correct
    }
    return $result
}
##+##########################################################################
#
# ::Profile::ProfileRoad -- returns profile info for a single road, handling
# waypoints and midpoint intermediate climbs.
#
proc ::Profile::ProfileRoad {from rid} {
    global roads nodes NR zone
    variable lastAlt

    foreach {id1 id2 . . . . . . xy z q} $roads($rid) break
    set qual [expr {$q > $zone(goodData) ? 1 : 0}]
    set qual2 [expr {$qual | 2}]
    set to $id2
    if {$from == $id2} {
	set to $id1
	set xy [::Data::XYReverse $xy]
	set z [::Data::Reverse $z]
    }
    foreach who {rdist rclimb rdesc} val [lrange $NR($rid,$from,$to) 1 3] \
	type {dist climb climb} {
	    set $who [::Data::Convert [::BadMath::Real $val] $type]
    }

    # Build our data list for endpoints and all Z points, we'll add
    # midpoints on the next pass

    # Startpoint of the road
    set tdist [set tclimb [set tdesc 0]]
    foreach {. alt1 lat1 lon1} $nodes($from) break
    if {[::BadMath::IsBad $alt1]} {
	set alt1 $lastAlt
	set data [list [list $from $tdist $alt1 1 0 $rid turn]]
    } else {
	set alt1 [::Data::Convert $alt1 climb]
	set data [list [list $from $tdist $alt1 2 0 $rid turn]]
    }

    # Midpoints of the road
    if {$z ne {}} {
	foreach {a b c d e f } $xy alt2 $z {
	    set lat2 [lat2int $a $b $c]
	    set lon2 [lat2int $d $e $f]
	    set dist [::Data::Distance $lat1 $lon1 $lat2 $lon2]
	    set dist [::Data::Convert $dist dist]
	    set tdist [expr {$tdist + $dist}]
	    set lat1 $lat2; set lon1 $lon2

	    if {[::BadMath::IsBad $alt2]} continue
	    set alt2 [::Data::Convert $alt2 climb]

	    if {$alt2 > $alt1} {
		set tclimb [expr {$tclimb + ($alt2 - $alt1)}]
	    } else {
		set tdesc [expr {$tdesc + ($alt1 - $alt2)}]
	    }
	    # Rounding error: skip if tdist > rdist
	    if {$tdist <= $rdist} {
		lappend data [list -1 $tdist $alt2 $qual2 $tclimb $rid turn]
	    }
	    set alt1 $alt2
	}
    }

    # Endpoint of the road
    set alt2 [lindex $nodes($to) 1]
    if {[::BadMath::IsBad $alt2]} {
	set alt2 $alt1
	lappend data [list $to $rdist $alt2 $qual $tclimb $rid turn]
    } else {
	set alt2 [::Data::Convert $alt2 climb]
	if {$alt2 > $alt1} {
	    set tclimb [expr {$tclimb + ($alt2 - $alt1)}]
	} else {
	    set tdesc [expr {$tdesc + ($alt1 - $alt2)}]
	}
	lappend data [list $to $rdist $alt2 $qual2 $tclimb $rid turn]
    }
    set lastAlt $alt2

    # This is the unaccounted for climbing & descending--ideally they
    # should be equal to each other but our data is not perfect
    set segcnt [expr {[llength $data] - 1}]
    set climb [Max 0 [expr {$rclimb - $tclimb}]]
    set desc  [Max 0 [expr {$rdesc  - $tdesc}]]
    set midClimb [expr {$climb / $segcnt}]

    if {$midClimb == 0} {
	return $data
    }

    # This pass adds in intermediate climbs points
    set data2 {}
    set tclimb 0
    foreach datum $data {
	foreach {. dist2 alt2 qual .} $datum break
	if {[llength $data2] > 0} {
	    set dist [expr {($dist1 + $dist2) / 2.0}]
	    set alt [expr {$midClimb + [Max $alt1 $alt2]}]

	    set climb [expr {$alt - $alt1}]
	    set desc [expr {$alt - $alt2}]
	    set tclimb [expr {$tclimb + $climb}]

	    if {$desc > [expr {$climb * .1}] &&
		$climb > [expr {$desc * .1}]} {
		set qual [expr {$qual & 1}]
		lappend data2 [list -1 $dist $alt $qual $tclimb $rid turn]
	    }
	    lset datum 4 $tclimb
	}
	lappend data2 $datum
	foreach {dist1 alt1} [list $dist2 $alt2] break
    }
    return $data2
}
##+##########################################################################
#
# ::Profile::Pos2Canvas
#
# Converts an array of profile space coordinates into canvas space coordinates
#
proc ::Profile::Pos2Canvas {C args} {
    global pro

    set result {}

    foreach {gx gy} $args {
	set cx [expr {$pro(Ox) + round(($gx - $pro(xmin)) * $pro(sx))}]
	set cy [expr {$pro(Oy) - round(($gy - $pro(ymin)) * $pro(sy))}]

	lappend result $cx $cy
    }

    return $result
}
##+##########################################################################
#
# ::Profile::Pos2CanvasZ -- converts climbing profile data into canvas coords
#
proc ::Profile::Pos2CanvasZ {C args} {
    global pro

    set result {}

    foreach {gx gz} $args {
	set cx [expr {$pro(Ox) + round(($gx - $pro(xmin)) * $pro(sx))}]
	set cz [expr {$pro(Oz) - round(($gz - $pro(zmin)) * $pro(sz))}]

	lappend result $cx $cz
    }

    return $result
}
##+##########################################################################
#
# ::Profile::Canvas2Dist -- Converts click on profile to distance
#
proc ::Profile::Canvas2Dist {x y} {
    global pro
    set x [.pro.c canvasx $x]

    set dist [expr {$pro(xmin) + ($x - $pro(Ox)) / $pro(sx)}]
    return $dist
}
##+##########################################################################
#
# ::Profile::DrawBackground
#
# Creates the axis for the profile with a stripped background, tick
# marks and labels.
#
proc ::Profile::DrawBackground {C} {
    variable show
    variable colors
    variable sizes
    variable bands {}
    global pro

    set pro(origin) [::Profile::Pos2Canvas $C $pro(xmin) $pro(ymin)]
    set pro(xAxis) [::Profile::Pos2Canvas $C $pro(xmax) $pro(ymin)]
    set pro(yAxis) [::Profile::Pos2Canvas $C $pro(xmin) $pro(ymax)]
    set coords [concat $pro(xAxis) $pro(origin) $pro(yAxis)]
    $C create line $coords -tag axis

    set dlbl [lindex [::Data::Label 0 dist 1] 1]
    set clbl [lindex [::Data::Label 0 climb 1] 1]

    set xmin [expr {$pro(xt2) * int(ceil($pro(xmin)/double($pro(xt2))))}]
    for {set tx $xmin} {$tx <= $pro(xmax)} {set tx [expr {$tx + $pro(xt2)}]} {
	foreach {x y} [::Profile::Pos2Canvas $C $tx $pro(ymin)] break
	set y2 [expr {$y + $sizes(smallTick)}]
	$C create line $x $y $x $y2 -tag axis
    }

    set xmin [expr {$pro(xt) * int(ceil($pro(xmin)/double($pro(xt))))}]
    # Horizontal axis labels
    for {set tx $xmin} {$tx<=$pro(xmax)} {set tx [expr {$tx+$pro(xt)}]} {
	foreach {x y} [::Profile::Pos2Canvas $C $tx $pro(ymin)] break
	set y2 [expr {$y + $sizes(bigTick)}]
	$C create line $x $y $x $y2 -tag axis

	set txt [Round1 $tx]
	if {$tx < $pro(xmax)} {set txt "$txt $dlbl"}
	$C create text $x $y2 -text $txt -anchor n -tag xlabel

	if {$tx >= $pro(xmax)} break
    }

    # Vertical axis label and stripped background
    set lasty -1
    set band 0
    for {set ty $pro(ymin)} {$ty <= $pro(ymax)} {set ty [expr {$ty+$pro(yt)}]} {
	foreach {x y} [::Profile::Pos2Canvas $C $pro(xmin) $ty] break
	set x2 [expr {$x - 5}]
	$C create line $x $y $x2 $y -tag axis

	# Y labels
	set txt "[Round0 $ty] $clbl"
	incr x2 -2
	$C create text $x2 $y -text $txt -anchor e -tag ylabel

	# Background stipple
	if {$lasty != -1} {
	    lappend bands [lindex [::Profile::Pos2Canvas $C $pro(xmin) $ty] 1]
	    ;# set color $colors(band,$band)
	    ;# set coords [::Profile::Pos2Canvas $C $pro(xmin) $lasty $pro(xmax) $ty]
	    ;# $C create rect $coords -fill $color -outline {} -tag bg
	    ;# set band [expr {1 - $band}]
	}
	set lasty $ty

	if {$ty >= $pro(ymax)} break
    }

    if {! $show(z)} return

    # Zgraph axis
    set coords [::Profile::Pos2Canvas $C $pro(xmax) $pro(ymin) \
		    $pro(xmax) $pro(ymax)]
    $C create line $coords -tag {axis Zaxis} -fill $colors(zcolor)
    for {set tz $pro(zmin)} {$tz <= $pro(zmax)} {incr tz $pro(zt)} {
	foreach {x z} [::Profile::Pos2CanvasZ $C $pro(xmax) $tz] break
	set x2 [expr {$x + 5}]
	$C create line $x $z $x2 $z -tag axis -fill $colors(zcolor)

	# Z labels
	set txt "$tz $clbl"
	incr x2 2
	$C create text $x2 $z -text $txt -anchor w -tag zlabel \
	    -fill $colors(zcolor)
    }

    foreach {. y x .} [$C bbox zlabel] break

    set units [lindex [::Data::Label 0 climb 3] 1]
    set img ::img::a$units
    ::Display::MakeImage $img $units.gif

    $C create image [expr {$x+4}] $y -tag zcaption -anchor nw -image $img
}
##+##########################################################################
#
# ::Profile::Save
#
# Saves the route profile
#
proc ::Profile::Save {} {
    variable saveName
    global state route

    set types {}
    set ext "ps"
    if {[::Data::CanDo snapshot]} {
	lappend types {"GIF Files" ".gif"}
	if {$::state(can,jpeg)} {lappend types {"JPEG Files" ".jpg"}}
	if {$::state(can,png)} {lappend types {"PNG Files" ".png"}}
	set ext [expr {$::state(can,jpeg) ? "jpg" : "png"}]
	set ext "gif"
    }
    if {[::Data::CanDo pdfCanvas]} {
	lappend types {"PDF Files" ".pdf"}
    }
    lappend types {"Postscript Files" ".ps"}
    set fname [tk_getSaveFile -defaultextension $ext \
		   -title "$state(progname) Save Profile" \
		   -filetypes $types \
		   -initialdir [file dirname $saveName] \
		   -initialfile [file tail [file rootname $saveName]]]
    if {$fname eq ""} return
    set saveName $fname
    set fext [file extension $saveName]

    if {$fext eq ".ps"} {

	# Weird, doesn't throw an error if bad--only sets error message
	set err ""
	set n [catch {.pro.c postscript -file $saveName} err]

	if {$n || $err ne ""} {
	    WARN "Error saving postscript: $err"
	} else {
	    DoInfo "Route Profile saved as a postscript file\nin $saveName" \
		"Save Route Profile"
	}
    } elseif {$fext eq ".pdf"} {
	::Profile::SavePDF $saveName
	DoInfo "Route Profile saved as a pdf file\nin $saveName" \
						    "Save Route Profile"
    } else {					;# Image save
	raise .pro ; update
	image create photo ::img::profile -data .pro.c
	set img [::Display::AddCopyright ::img::profile]
	set fmt [expr {$fext eq ".gif" ? "gif" : $fext eq ".png" ? "png" : "jpeg"}]
	$img write $saveName -format $fmt
	image delete ::img::profile
	image delete $img
	DoInfo "Route Profile saved as a $fmt file\nin $saveName" \
						    "Save Route Profile"
    }
}
##+##########################################################################
#
# ::Profile::MakeImage -- Returns a snapshot of our profile graph
#
proc ::Profile::MakeImage {} {
    if {! [::Data::CanDo grabWindow]} { return "" }
    if {! [winfo exists .pro]} { return "" }
    raise .pro ; update
    set iname [image create photo -data .pro.c]
    return $iname
}
##+##########################################################################
#
# ::Profile::SavePDF -- Saves our profile as pdf file
#
proc ::Profile::SavePDF {fname} {
    if {! [::Data::CanDo pdfCanvas]} return
    ::Display::MakeImage ::img::copyright copyright.gif

    set font [.pro.c itemcget xlabel -font]
    .pro.c itemconfig xlabel -font {Helvetica 8}
    .pro.c itemconfig ylabel -font {Helvetica 8}
    .pro.c itemconfig zlabel -font {Helvetica 8}

    set fill [.pro.c itemcget graph -fill]
    .pro.c itemconfig graph -fill white
    .pro.c create image [winfo width .pro.c] [winfo height .pro.c] \
	-tag copyright -anchor se -image ::img::copyright

    ::pdf::generate .pro.c $fname

    .pro.c itemconfig xlabel -font $font
    .pro.c itemconfig ylabel -font $font
    .pro.c itemconfig zlabel -font $font
    .pro.c itemconfig graph -fill $fill
    .pro.c delete copyright
}
##+##########################################################################
#
# ::Profile::GPSSection -- Highlights section of GPS profile graph
#
proc ::Profile::GPSSection {onoff start end color} {
    variable gpsPts
    global pro

    if {! [winfo exists .pro.c]} return
    if {$onoff != 2} {
	.pro.c delete gpsHighlight
    }
    if {! $onoff} return

    if {$start > $end} {foreach start $end end $start break}
    set xy [lrange $gpsPts [expr {$start * 2}] [expr {$end * 2 + 1}]]
    set x0 [lindex $xy 0]
    set x1 [lindex $xy end-1]
    set y [lindex [::Profile::Pos2Canvas .pro.c 0 $pro(ymin)] 1]
    .pro.c create poly [concat $xy $x1 $y $x0 $y] -tag gpsHighlight \
	-stipple gray75 -fill $color
}
#+##########################################################################
#
# ::Profile::Trace
#
# Does tracing on the profile window.
#
proc ::Profile::Trace {dist delete} {
    global pro

    if {! [winfo exist .pro] } return
    if {! [info exists pro(data)]} return

    if {$dist < $pro(xmin) || $dist > $pro(xmax)} {
	::Trace::DrawBiker .pro.c 0
	return
    }

    if {$delete} {
	::Trace::DrawBiker .pro.c 0
	return
    }

    foreach {x y angle} [::Profile::Dist2XYA $dist] break
    incr y 3
    set angle 0
    ::Trace::Biker .pro.c $x $y $angle
}
##+##########################################################################
#
# ::Profile::Dist2XYA -- returns x,y on graph for a given distance
# dist MUST BE IN MILES
#
proc ::Profile::Dist2XYA {dist {isExternal 0}} {
    global pro cnt

    # NB. dist is miles, pro(data) is external
    if {! $isExternal} {
	set dist [::Data::Convert $dist dist]
    }

    set end [lindex $pro(data) end 1]		;# Catch rounding errors
    if {$dist > $end} {set dist $end}

    set idx -1
    foreach pos $pro(data) {
	incr idx
	foreach {. dist1 alt1} $pos break
	if {$dist1 >= $dist} break

	set dist0 $dist1
	set alt0 $alt1
    }

    if {$dist > 0} {
	set perc [expr {($dist - $dist0) / double($dist1 - $dist0)}]
	set alt [expr {$alt0 + $perc * ($alt1 - $alt0)}]
    } else {
	set alt $alt1
	foreach {. dist0 alt0} [lindex $pro(data) 0] break
	foreach {. dist1 alt1} [lindex $pro(data) 1] break
    }

    foreach {x0 y0} [::Profile::Pos2Canvas .pro.c $dist0 $alt0] break
    foreach {x1 y1} [::Profile::Pos2Canvas .pro.c $dist1 $alt1] break
    set angle [::Trace::GetAngle $x0 $y0 $x1 $y1]
    if {$dist == $dist1} {set angle 0}

    set xy [::Profile::Pos2Canvas .pro.c $dist $alt]
    return [concat $xy $angle $idx $alt]
}
##+##########################################################################
#
# ::Profile::GetEdge -- returns xy of edge between two route points
#
proc ::Profile::GetEdge {idx1 idx2} {
    global pro

    # Check for in range of customized graph
    set xmin [lindex $pro(data) $idx1 1]
    set xmax [lindex $pro(data) $idx2 1]
    if {$xmin < $pro(xmin) || $xmax > $pro(xmax)} { return "" }

    set a [expr {2*$idx1}]
    set b [expr {2*$idx2 + 1}]
    set ymin [lindex $pro(pxy) end-6]

    set xy [lrange $pro(pxy) $a $b]
    lappend xy [lindex $xy end-1] $ymin
    lappend xy [lindex $xy 0] $ymin

    return $xy
}
##+##########################################################################
#
# ::Profile::GetEdge2 -- returns xy of edge between two distances
#  dist1, dist2 are in external units
#
proc ::Profile::GetEdge2 {dist1 dist2} {
    global pro

    if {$dist1 > $dist2} {foreach {dist1 dist2} [list $dist2 $dist1] break }

    foreach {x1 y1 . idx1} [::Profile::Dist2XYA $dist1 1] break
    foreach {x2 y2 . idx2} [::Profile::Dist2XYA $dist2 1] break

    set xy [concat [::Profile::Pos2Canvas .pro.c $dist1 $pro(ymin)] $x1 $y1]
    for {set idx $idx1} {$idx < $idx2} {incr idx} {
	set pos [lindex $pro(data) $idx]
	foreach {. dist alt} $pos break
	foreach {x y} [::Profile::Pos2Canvas .pro.c $dist $alt] break
	lappend xy $x $y
    }
    lappend xy $x2 $y2
    set xy [concat $xy [::Profile::Pos2Canvas .pro.c $dist2 $pro(ymin)]]

    return $xy
}
##+##########################################################################
#
# ::Profile::Mousing -- Computes gradients on profile graph
#
proc ::Profile::Mousing {C what x y} {
    global pro state
    variable show

    set dist [::Profile::Canvas2Dist $x $y]	;# External units
    set dist [Median $pro(xmin) $dist $pro(xmax,data)]
    foreach {tx ty . . alt} [::Profile::Dist2XYA $dist 1] break
    foreach {bx by .} [::Profile::Pos2Canvas $C $dist $pro(ymin)] break

    # Create if not already existing
    if {[$C find withtag grad] eq ""} {
	$C create poly -tag grad -width 2 -stipple gray50 \
	    -fill $state(grad,clr) -outline $state(grad,clr)
	$C create line 0 0 0 0 -tag grad2 -width 5 -fill red -arrow last
    }

    if {$what eq "down"} {
	set pro(mouse,start) $dist
	set pro(mouse,alt) $alt
	set pro(mouse,top) [list $tx $ty]
	set ::Profile::C(xmin) [Round1 $dist]

	# NB. if we draw grad it may interfere w/ double-button detection
	$C coords grad -100 -100
	$C coords grad2 -100 -100 -100 -100
	return
    } else {
	set ::Profile::C(xmin) [Round1 [Min $pro(mouse,start) $dist]]
	set ::Profile::C(xmax) [Round1 [Max $pro(mouse,start) $dist]]

	set rise [expr {$alt - $pro(mouse,alt)}]
	set run [expr {abs($pro(mouse,start) - $dist)}]
	set grad "--"
	if {$run > .01} {
	    if {$::state(units,external) eq "metric"} {
		set grad [expr {$rise / 10.00 / $run}]
	    } else {
		set grad [expr {$rise / 52.80 / $run}]
	    }
	    set grad [format "%.1f%%" $grad]
	}
	set rise2 [::Data::Label [Round0 $rise] climb 2] ;# NB. already external
	set run2 [Round2 $run]
	if {$run2 == 0} { set run2 [Round2 $run]}
	set run2 [::Data::Label $run2 dist 2]
	set show(grad) "Rise:\t $rise2\nRun:\t $run2\nGradient: $grad"
    }
    set xy [::Profile::GetEdge2 $pro(mouse,start) $dist]
    $C coords grad $xy
    $C coords grad2 [concat $pro(mouse,top) $tx $ty]
}
##+##########################################################################
#
# ::Profile::Configure -- Puts up Profile Graph configure dialog
#
proc ::Profile::Configure {} {
    if {! [winfo exists .pro]} return

    destroy .pro.conf
    if {! $::Profile::show(configure)} return

    set W .pro.conf
    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Profile Configure"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::profile profile.gif]
    wm protocol $W WM_DELETE_WINDOW [list ::Profile::_ConfigDelete $W]

    ::ttk::button $WBTN.cancel -text Dismiss \
	-command [list ::Profile::_ConfigDelete $W]
    ::Display::GridChildren $WBTN 0

    ::Profile::_Configure $WB
    ::Display::RightWindow $W .pro
    wm deiconify $W
}
##+##########################################################################
#
# ::Profile::_ConfigDelete -- Handles closing profile graph config dialog
#
proc ::Profile::_ConfigDelete {W} {
    set ::Profile::show(configure) 0
    destroy $W
}
##+##########################################################################
#
# ::Profile::_Configure -- Draws content for profile graph config dialog
#
proc ::Profile::_Configure {w} {
    global pro
    variable C
    unset -nocomplain ::Profile::C

    set ::Profile::C(title) $::route(title)
    foreach a {xmax xmin xt ymax ymin yt} {
	set ::Profile::C($a) $pro($a)
    }
    foreach a {z ribbon labels} {
	set ::Profile::C($a) $::Profile::show($a)
    }

    eval destroy [winfo children $w]
    set distUnits [lindex [::Data::Label 0 dist 0] end]
    set climbUnits [lindex [::Data::Label 0 climb 0] end]

    ::my::labelframe $w.ltitle -text "Route Title" -pad 5
    ::my::entry $w.title -textvariable ::Profile::C(title) -justify center
    frame $w.buttons
    ::ttk::button $w.apply -text "Plot It" -command ::Profile::Conf_Apply
    pack $w.apply -side left -expand 1 -in $w.buttons

    ::my::labelframe $w.x -text "X Axis"
    ::my::label $w.x.start -text "Start"
    ::my::entry $w.x.estart -textvariable ::Profile::C(xmin) -width 6 -justify c
    ::my::label $w.x.ustart -text $distUnits
    ::my::label $w.x.end -text "End"
    ::my::entry $w.x.eend -textvariable ::Profile::C(xmax) -width 6 -justify c
    ::my::label $w.x.uend -text $distUnits
    ::my::label $w.x.tick -text "Tick"
    ::my::entry $w.x.etick -textvariable ::Profile::C(xt) -width 6 -justify c
    ::my::label $w.x.utick -text $distUnits
    ::ttk::button $w.x.reset -text "Reset" -command {::Profile::Conf_Reset x}
    grid $w.x.start $w.x.estart $w.x.ustart
    grid $w.x.end $w.x.eend $w.x.uend
    grid $w.x.tick $w.x.etick $w.x.utick
    grid $w.x.reset - - -pady 5

    ::my::labelframe $w.y -text "Y Axis"
    ::my::label $w.y.high -text "High"
    ::my::entry $w.y.ehigh -textvariable ::Profile::C(ymax) -width 6 -justify c
    ::my::label $w.y.uhigh -text $climbUnits
    ::my::label $w.y.low -text "Low"
    ::my::entry $w.y.elow -textvariable ::Profile::C(ymin) -width 6 -justify c
    ::my::label $w.y.ulow -text $climbUnits
    ::my::label $w.y.tick -text "Tick"
    ::my::entry $w.y.etick -textvariable ::Profile::C(yt) -width 6 -justify c
    ::my::label $w.y.utick -text $climbUnits
    ::ttk::button $w.y.reset -text "Reset" -command {::Profile::Conf_Reset y}
    grid $w.y.high $w.y.ehigh $w.y.uhigh
    grid $w.y.low $w.y.elow $w.y.ulow
    grid $w.y.tick $w.y.etick $w.y.utick
    grid $w.y.reset - - -pady 5

    #::my::labelframe $w.3d -text "3D Graph" -pad {10 0 10 10}
    ::ttk::labelframe $w.3d -text "" -pad {10 0 10 10}
    set C(ribbon) $::Profile::show(ribbon)
    set C(offset,dir) $::state(pro,pp)
    set C(offset,len) $::state(pro,len)

    ::ttk::checkbutton $w.3d.show -text "3D Graph" \
	-variable ::Profile::C(ribbon)
    set drawCmd [::Display::RibbonWidget $w.3d ::Profile::C(offset,dir) \
		     ::Profile::C(offset,len)]
    ::ttk::button $w.3d.reset -text "Reset" \
	-command [list ::Profile::Conf_Reset off $drawCmd]
    grid $w.3d.reset - -pady {10 0}
    place $w.3d.show -bordermode outside -x 10 -y 0

    grid $w.ltitle - -sticky ew -pady {0 10}
    pack $w.title -in $w.ltitle -side top -fill both -expand 1
    grid $w.x $w.y -sticky news
    grid $w.3d - -sticky ew -pady 10
    grid config $w.y -padx {10 0}
    grid $w.buttons - -sticky ew
}
##+##########################################################################
#
# ::Profile::Conf_Reset -- Handles resetting dialog values
#
proc ::Profile::Conf_Reset {which args} {
    if {$which eq "off"} {
	set ::Profile::C(offset,dir) $::Config::factory(pro,pp)
	set ::Profile::C(offset,len) $::Config::factory(pro,len)
	set drawCmd [lindex $args 0]
	eval $drawCmd
    } else {
	foreach a [array names ::Profile::C $which*] {
	    set ::Profile::C($a) $::pro($a,nice)
	}
    }
}
##+##########################################################################
#
# ::Profile::Conf_Apply -- Applies user values to profile graph
#
proc ::Profile::Conf_Apply {} {
    global pro state
    variable C

    set ::Profile::show(ribbon) $C(ribbon)
    if {$C(offset,len) == 0} { set ::Profile::show(ribbon) 0 }
    set state(pro,pp) $C(offset,dir)
    set state(pro,len) $C(offset,len)

    # Validate X parameters
    if {! [string is double -strict $C(xmin)]} { set C(xmin) $pro(xmin,nice) }
    if {! [string is double -strict $C(xmax)]} { set C(xmax) $pro(xmax,nice) }
    if {! [string is double -strict $C(xt)]} { set C(xt) $pro(xt,nice) }
    set C(xmin) [Median 0 $C(xmin) $pro(xmax,data)]
    set C(xmax) [Median 0 $C(xmax) [expr {$pro(xmax,nice) + 10}]]
    if {$C(xmin) > $C(xmax)} {
	foreach {C(xmin) C(xmax)} [list $C(xmax) $C(xmin)] break
    }
    if {$C(xmin) == $C(xmax)} {
	if {$C(xmin) > $pro(xmin,nice)} {
	    set C(xmin) $pro(xmin,nice)
	} else {
	    set C(xmax) $pro(xmax,nice)
	}
    }

    # Validate Y parameters
    foreach {ymin ymax} [::Profile::GetIntervalY $C(xmin) $C(xmax)] break
    if {! [string is double -strict $C(ymin)]} { set C(ymin) $ymin }
    if {! [string is double -strict $C(ymax)]} { set C(ymax) $ymax }
    if {! [string is double -strict $C(yt)]} { set C(xt) $pro(yt,nice) }
    set C(ymin) [Min $C(ymin) $ymin]
    set C(ymax) [Max $C(ymax) $ymax]
    if {$C(ymin) > $C(ymax)} {
	foreach {C(ymin) C(ymax)} [list $C(ymax) $C(ymin)] break
    }
    if {$C(ymin) == $C(ymax)} {
	set C(ymin) $pro(ymin,nice)
	set C(ymax) $pro(ymax,nice)
    }

    # Validate tick intervals
    set ticks [::Profile::GetTickSizes \
		   $C(xmin) $C(xmax) \
		   $C(ymin) $C(ymax) \
		   $pro(zmin,data) $pro(zmax,data)]

    foreach {xt yt zt} $ticks break

    if {$C(xt) <= 0 || $C(xt) >= $C(xmax) - $C(xmin)} { set C(xt) $xt }
    if {$C(yt) <= 0 || $C(yt) >= $C(ymax) - $C(ymin)} { set C(yt) $yt }

    set C(ymin) [expr {int($C(ymin) / $C(yt)) * $C(yt)}]
    set C(ymax) [expr {int(ceil($C(ymax)/1.0/$C(yt))) * $C(yt)}]

    foreach a {xmax xmin xt ymax ymin yt} {
	set pro($a) $C($a)
    }
    set pro(zt) $zt

    set ::route(title) $::Profile::C(title)
    ::Profile::Redraw
}
##+##########################################################################
#
# ::Profile::GetIntervalY -- Returns lowest and highest elevation on an interval
#
proc ::Profile::GetIntervalY {xmin xmax} {
    global pro

    set x [lindex $pro(data) 0 1]		;# Last position
    set y [lindex $pro(data) 0 2]

    foreach pt $pro(data) {
	set X $x ; set Y $y
	foreach {. x y} $pt break

	if {$x < $xmin} continue
	if {$x == $xmin} {set ymin [set ymax $y]}

	if {$X < $xmin && $x > $xmin} {         ;# Interpolate starting height
	    set k [expr {($xmin - $X) / double($x - $X)}]
	    set y0 [expr {$Y + $k * ($y - $Y)}]
	    set ymin [set ymax $y0]
	    if {$y0 > $ymax} {
		set ymax $y0
	    } elseif {$y0 < $ymin} {
		set ymin $y0
	    }
	}
	if {$x > $xmax} {                 ;# Interpolate ending height
	    set k [expr {($xmax - $X) / double($x - $X)}]
	    set y0 [expr {$Y + $k * ($y - $Y)}]
	    if {$y0 > $ymax} {
		set ymax $y0
	    } elseif {$y0 < $ymin} {
		set ymin $y0
	    }
	    break
	}
	if {$y > $ymax} {
	    set ymax $y
	} elseif {$y < $ymin} {
	    set ymin $y
	}
    }
    return [list $ymin $ymax]
}
## EON PROFILE
## BON 3D
##+##########################################################################
#
# ::3D::_Init -- sets up for running gnuplot
#
proc ::3D::_Init {{quiet 0}} {
    variable gpexe
    variable 3dDir

    if {[info exists ::state(can,3d)]} { return $::state(can,3d) }
    set ::state(can,3d) 0

    set 3dDir [file join $::state(wdir) "3dProfile"]
    if {! [file isdirectory $3dDir]} {
	file mkdir $3dDir
	if {! [file isdirectory $3dDir]} {
	    if {! $quiet} {WARN "ERROR: Cannot create directory for 3D Profiles"}
	    ::Route::DoButtons
	    return $::state(can,3d)
	}
    }
    set gpexe0 [expr {$::state(windows) ? "pgnuplot.exe" : "gnuplot"}]
    set gpexe [file join $3dDir $gpexe0]
    if {![file exists $gpexe]} {
	set gpexe [auto_execok $gpexe0]
	if {$gpexe eq ""} {
	    set txt "The 3D Profile feature requires the program 'gnuplot'.\n\n"
	    append txt "This program can be downloaded from\n"
	    append txt "http://www.gnuplot.info/"
	    if {! $quiet} {WARN $txt}
	    ::Route::DoButtons
	    return $::state(can,3d)
	}
    }
    set ::state(can,3d) 1
    return $::state(can,3d)
}
##+##########################################################################
#
# ::3D::CanDo -- returns bool if we can run gnuplot (unknown = ok)
#
proc ::3D::CanDo {{mustKnow 0}} {
    if {$mustKnow} {
	::3D::_Init 1
    }

    if {[info exists ::state(can,3d)]} {
	return $::state(can,3d)
    }

    return 1
}
##+##########################################################################
#
# ::3D::RunGnuplot -- Gets x,y,z data and runs gnuplot
#
proc ::3D::RunGnuplot {{who route} args} {
    variable gpexe
    variable xyz
    variable gp

    if {! [::3D::_Init]} return
    ::3D::GetXYZ $who
    if {$xyz eq ""} return
    ::3D::WriteData

    catch {close $gp}
    set g [string map {" " "\\ "} $gpexe]
    set gp [open "|$g" r+]
    fconfigure $gp -buffering line
    ::3D::WriteParams $gp $who
    flush $gp
}
##+##########################################################################
#
# ::3D::ExecGnuplot -- execs gnuplot. Little weirdness in that
# I can't get -persist to work unless I:
#     - include "set terminal" in the control file
#     - or exec cmd /c start $gpexe -persist $cntrlFile
#         NB. 4nt doesn't work at all
#
proc ::3D::ExecGnuplot {{who route} args} {
    variable gpexe
    variable xyz
    variable 3dDir

    if {! [::3D::_Init]} return
    ::3D::GetXYZ $who
    if {$xyz eq ""} return
    ::3D::WriteData
    set ctrlFile [file join $3dDir $::3D::ctrlFile0]

    set fout [open $ctrlFile "w"]
    ::3D::WriteParams $fout $who
    puts $fout "set terminal"			;# Magic command
    close $fout
    exec $gpexe -persist $ctrlFile &
}
##+##########################################################################
#
# ::3D::WriteParams -- writes out parameters to configure the
# gnuplot display. Can't seem to get font to work.
#
proc ::3D::WriteParams {fout who} {
    variable dataFile
    variable xrot
    variable zrot
    variable xyz

    puts $fout "set key off"
    set style [expr {$who eq "route" ? "linespoints" : "lines"}]
    puts $fout "set style data $style"
    puts $fout "set view $xrot,$zrot"
    puts $fout "set title \"$::state(progname) 3D Profile\""
    puts $fout "set xlabel 'Longitude'"
    puts $fout "set ylabel 'Latitude'"
    puts $fout "set zlabel 'Elevation'"

    foreach {x0 y0 z0} $xyz break
    foreach {x1 y1 z1} [lrange $xyz end-2 end] break
    set dist [::Data::Distance $y0 $x0 $y1 $x1 1]
    if {$dist < 100} {				;# Start & end close enough
	puts $fout "set label 1 \"Start/End\" at $x0,$y0,$z0 front"
    } else {
	puts $fout "set label 1 \"Start\" at $x0,$y0,$z0 front"
	puts $fout "set label 2 \"End\" at $x1,$y1,$z1 front"
    }

    # Put up distance, etc. labels
    if {$who eq "route"} {
	set name ""
	foreach a {dist climb desc} { set $a $::msg($a)}
    } else {
	foreach {name dist climb desc} [::Tracks::GetInfo] break
    }
    if {$name ne ""} {
	puts $fout "set label 3 '$name' at screen .8,.93 back"
    }
    puts $fout "set label 4 'Distance: $dist' at screen .8,.9 back"
    puts $fout "set label 5 'Climbing: $climb' at screen .8,.87 back"
    puts $fout "set label 6 'Descent:  $desc' at screen .8,.84 back"

    # "with" controls physical appearance of the data lines
    set with "with $style lw 2"
    if {$who eq "route"} { append with " pt 2"}
    puts $fout "splot '$dataFile' $with"
}
# Animate via tk
proc ::3D::TkGnuplot {} {
    variable gpexe
    variable gp
    variable xrot
    variable xyz
    variable 3dDir
    variable dataFile

    if {! [::3D::_Init]} return
    ::3D::GetXYZ route
    if {$xyz eq ""} return
    ::3D::WriteData
    set tkFile [file join $3dDir "gnuOutput.tk"]
    if {[file exists $tkFile]} {file delete $tkFile}

    catch {close $gp}				;# Kill any existing gnuplot
    set gp [open "|$gpexe" r+]
    puts $gp "set key off"
    puts $gp "set style data linespoints"
    puts $gp "set title \"$::state(progname) 3D Profile\""
    foreach {x y z} $xyz break
    if {$::route(start) eq [lindex $::route(nodes) end]} {
	puts $gp "set label 1 \"Start/End\" at $x,$y,$z front"
    } else {
	puts $gp "set label 1 \"Start\" at $x,$y,$z front"
	foreach {x y z} [lrange $xyz end-2 end] break
	puts $gp "set label 2 \"End\" at $x,$y,$z front"
    }
    puts $gp "set terminal tkcanvas"
    puts $gp "set output '$tkFile'"

    set step 1
    for {set zzrot 0} {$zzrot < 360} {incr zzrot $step} {
	puts $gp "set view $xrot,$zzrot"
	puts "set view $xrot,$zzrot"
	if {$zzrot == 0} {
	    puts $gp "splot '$dataFile'"
	} else {
	    puts $gp "replot"
	}
	flush $gp
    }
    close $gp
    ::3D::MungeTK $tkFile
}
##+##########################################################################
#
# ::3D::WriteData -- writes XYZ data to a file which gnuplot will read
#
proc ::3D::WriteData {} {
    variable xyz
    variable 3dDir
    variable dataFile
    variable dataFile0

    set dataFile [file join $3dDir $dataFile0]
    set fout [open $dataFile "w"]
    foreach {x y z} $xyz {
	puts $fout "$x $y $z"
    }
    close $fout
}
##+##########################################################################
#
# ::3D::GetXYZ -- converts route into xyz data for gnuplot
#
#proc ::3D::GetXYZ {who} {
#    variable xyz
#
#    set xyz {}
#    if {$who eq "route"} {
#	set data [::Route::GetXYZ]
#    } else {
#	set data [::GPS::GetXYZ 0]
#    }
#
#    foreach pt $data {
#	foreach {. . lat lon . . . alt} $pt break
#	set x [expr {-$lon}]
#	set y $lat
#	set z $alt
#	lappend xyz $x $y $z
#    }
#}
##+##########################################################################
#
# ::3D::GetXYZ -- converts route into xyz data for gnuplot
#
# We have an N^2 algorithm here that uses ::Profile::Dist2Alt to better
# interpolate unknown elevations.
#
proc ::3D::GetXYZ {who} {
    variable xyz
    global pdata

    set xyz {}
    if {$who eq "route"} {
	set data [::Route::GetXYZ]
	set pdata [lindex [::Profile::GetData] 6] ;# Grab the node info
    } else {
	set data [::GPS::GetXYZ 0]
    }

    set tdist 0
    set lat0 0
    foreach pt $data {
	foreach {. ele lat1 lon1 . . . alt} $pt break
	if {$lat0 > 0} {
	    set dist [::Data::Distance $lat0 $lon0 $lat1 $lon1]
	    set tdist [expr {$tdist + $dist}]
	}
	set x [expr {-$lon1}]
	set y $lat1
	set z $alt
	set z $ele
	if {$z eq "?"} {
	    set z [::3D::Dist2Alt $tdist]
	}
	lappend xyz $x $y $z

	foreach {lat0 lon0} [list $lat1 $lon1] break
    }
}
proc ::3D::Dist2Alt {dist} {
    global pdata

    lappend ::DIST $dist
    # NB. dist is miles, pdata is external
    set dist [::Data::Convert $dist dist]

    set end [lindex $pdata end 1]		;# Catch rounding errors
    if {$dist > $end} {set dist $end}

    foreach pos $pdata {
	foreach {id dist1 alt1} $pos break
	if {$dist1 >= $dist} break

	set dist0 $dist1
	set alt0 $alt1
    }

    set alt $alt1
    if {$dist > 0} {
	set perc [expr {($dist - $dist0) / double($dist1 - $dist0)}]
	set alt [expr {$alt0 + $perc * ($alt1 - $alt0)}]
    }
    #puts "::3D::Dista2Alt $dist => $alt"
    return $alt
}
## EON 3D
## BON ABOUT
##+##########################################################################
#
# About -- Brings up the about dialog box
#
proc ::About::About {} {
    if {[lsearch [image names] ::img::about] == -1} {
	image create photo ::img::about		;# Empty place holder
	image create photo ::img::labout	;# Large about image
    }
    ::About::_InitImage
    ::About::AboutDlgEx .about ::img::about ::About::_About
}
##+##########################################################################
#
# _About -- Callback proc for filling in the bottom of the About dialog
#
proc ::About::_About {w} {
    global state

    wm overrideredirect $w 0
    wm transient $w .
    wm title $w "About $state(progname)"
    catch {wm attributes $w -toolwindow 1}	;# Only on windows
    ::Display::TileBGFix $w

    ::ttk::button $w.l -text License -command [list ::About::License license]
    ::ttk::button $w.c -text "Copyright" -command [list ::About::License copyright]
    ::ttk::button $w.b -text Dismiss -command [list destroy $w]
    pack $w.l $w.c $w.b -side left -expand 1 -pady 10

    $w.txt config -height 19

    $w.txt insert end "\n\nI hope you enjoy the program. " msg
    $w.txt insert end "Send me email if you like it or have suggestions.\n" msg
    $w.txt insert end "Addtional regions and routes may be found at " msg
    $w.txt insert end "the KLIMB web site.\n" msg
    $w.txt insert end "$state(homepage)\n" link
    $w.txt insert end "\nThis program is freeware: you can use it " msg
    $w.txt insert end "and distribute it freely. " msg
    $w.txt insert end "If you want to make a small\ndonation to help cover " msg
    $w.txt insert end "the operating expenses and to support further " msg
    $w.txt insert end "development,\nyou can do so through PayPal " msg
    $w.txt insert end "or you can send payment via the mail.\n" msg
    $w.txt insert end "Keith Vetter / 457 N Granger St / " addr
    $w.txt insert end "Granville, OH 43023\n" addr

    $w.txt tag configure img			;# For binding on the image

    bind $w.l1.splash <Double-Button-1> [list ::About::_Abouter next]
    bind $w.l1.splash <<MenuMousePress>> \
	{tk_popup .apopup [winfo pointerx .c] [winfo pointery .c] 0}
    bind $w.l1.splash <n> [list ::About::_Abouter next]
    bind $w.l1.splash <N> {::About::_Abouter next ; ::About::Large}
    bind $w.l1.splash <p> [list ::About::_Abouter prev]
    bind $w.l1.splash <P> {::About::_Abouter prev ; ::About::Large}
    bind $w.l1.splash <l> [list ::About::Large]
    focus $w.l1.splash

    ::About::_Abouter random			;# Pick random image
    if {[::Data::CanDo webPage]} {
	$w.txt config -height 17 -cursor arrow
	$w.txt tag config link -elide 1
	::ttk::button $w.home -text "$state(progname)'s Website" \
	    -cursor arrow -command [list WebPage $state(homepage)]
	::Display::MakeImage ::img::paypal paypal.gif
	::ttk::button $w.paypal -image ::img::paypal \
	    -cursor arrow -command [list WebPage $state(paypal)]
	pack $w.home $w.paypal -in $w.buttons -side left -expand 1 -pady {10 20}
	::Balloon::Create $w.home about web $state(homepage) $state(homepage)
	set txt "Make a donation with PayPal"
	::Balloon::Create $w.paypal about paypal $txt $txt
    }
}
##+##########################################################################
#
# ::About::_Abouter -- puts up another picture for the about dialog
#
proc ::About::_Abouter {how} {
    variable bmsg
    variable who

    if {![winfo exists .about]} return
    if {$how eq "random"} {
	set who [expr {rand() * 0x7fffFFFF}]
    } elseif {$how eq "prev"} {
	incr who -2
    }
    set who [expr {(int($who) + 1) % [llength [array names bmsg *,iname]]}]

    ::Balloon::Cancel

    set iname [file join $::state(idir) about $bmsg($who,iname)]
    ::Display::MakeShadowPhoto ::img::about $iname white
    ::Balloon::Create .about.l1 about img $bmsg($who,long) $bmsg($who,short)
    INFO $bmsg($who,short)
}
##+##########################################################################
#
# ::About::Large -- displays the large version of the about picture
#
proc ::About::Large {{id ""}} {
    variable bmsg
    variable who

    set parent .gallery
    if {$id eq ""} { set id $who ; set parent .about }
    if {! [winfo exists $parent]} { set parent "."}
    set iname [file join $::state(idir) about org $bmsg($id,iname)]
    if {! [file exists $iname]} {
	set iname [file join $::state(idir) about $bmsg($id,iname)]
    }

    if {[lsearch [image names] ::img::labout] == -1} {
	image create photo ::img::labout
    }
    set needPlacing 0
    if {! [winfo exists .labout]} {
	toplevel .labout
	wm withdraw .labout

	::tk::label .labout.limg -borderwidth 0
	::tk::label .labout.ltxt -font boldFont -background white -anchor c \
	    -justify c
	::tk::frame .labout.buttons -borderwidth 2 -relief ridge
	::ttk::button .labout.buttons.quit -text "Dismiss" \
	    -command {destroy .labout}
	pack .labout.limg -side top -fill both -expand 1
	pack .labout.ltxt -side top -fill x
	pack .labout.buttons -side top -fill x
	pack .labout.buttons.quit -side top -expand 1 -pady 10
	bind .labout <Control-w> {destroy .labout}

	wm transient .labout $parent
	set needPlacing 1
    }

    wm title .labout "$::state(progname) : $bmsg($id,short)"
    if {[file exists $iname]} {
	::Display::MakeShadowPhoto ::img::labout $iname [.labout.limg cget -bg]
	.labout.limg config -image ::img::labout
    } else {
	.labout.limg config -image {} -text "Missing Image" -fg red \
		  -font {Helvetica 18 bold}
    }
    .labout.ltxt config -text $bmsg($id,long)
    if {$needPlacing} {
	::Display::RightWindow .labout $parent
    }

    wm deiconify .labout
    raise .labout
    catch {focus .about.l1.f.c}
}
##+##########################################################################
#
# ::About::Large2 -- given About image name, displays it large
#
proc ::About::Large2 {iname} {
    variable bmsg

    ::About::_InitImage
    set len [llength [array names bmsg *,iname]]
    for {set i 0} {$i < $len} {incr i} {
	if {$iname eq $bmsg($i,iname)} {
	    ::About::Large $i
	}
    }
}
##+##########################################################################
#
# ::About::_InitImage -- gets metadata for all the about images
#  http://www.velonews.com/news/fea/12301.0.html
#
proc ::About::_InitImage {{force 0}} {
    variable bmsg

    # http://www.cyclingtipsblog.com/2010/02/10-coolest-roads-to-ride/

    # http://sports.espn.go.com/oly/cycling/slipstreamcali?lpos=spotlight&lid=tab7pos1
    #    http://assets.espn.go.com/photo/2008/0318/sstreamII_0310.jpg
    # See also http://www.penandthink.biz/cycling/index.html

    if {$force} { unset -nocomplain bmsg }
    if {[info exists bmsg(0,iname)]} return
    set idx -1

    # Stelvio
    # http://www.audioworld.net/BSA/pass/stilfser.jpg
    # see http://youtube.com/watch?v=uonsBvmXkq0
    incr idx
    set bmsg($idx,iname) stelvio.gif
    set bmsg($idx,short) "Passo Stelvio, Italy"
    set bmsg($idx,long) "Passo Stelvio, Italy  9,100 ft\n"
    append bmsg($idx,long) "47 switchbacks up to the pass near where\n"
    append bmsg($idx,long) "Italy, Austria and Switzerland meet"

    # Gavia: Jobst Brandt: http://www-math.science.unitn.it/Bike/Countries/Europe/Tour_Reports/Tour_of_the_Alps/Gallery/Gavia.4.Best.jpg
    incr idx
    set bmsg($idx,iname) gavia.gif
    set bmsg($idx,short) "Passo di Gavia, Italy"
    set bmsg($idx,long) "Passo di Gavia, Italy  8,632 ft\n"
    append bmsg($idx,long) "Jobst Brandt riding Passo di Gavia, 1978\n"
    append bmsg($idx,long) "photograph by Jobst Brandt"

    # Alpe d'Huez:
    #  http://www.cyclingnews.com/tour.php?id=photos/2003/features/alpe_dhuez/aerial01
    #  http://www.cyclingnews.com/road/2003/tour03/?id=features/alpe_dhuez
    incr idx
    set bmsg($idx,iname) alpedhuez.gif
    set bmsg($idx,short) "Alpe d'Huez, France"
    set bmsg($idx,long) "Alpe d'Huez, France, 6,105 ft\n"
    append bmsg($idx,long) "Seven of the 21 hairpins leading to the summit"

    # Hampsten: http://store.velogear.com/anhagapapo.html
    incr idx
    set bmsg($idx,iname) hampsten.gif
    set bmsg($idx,short) "Andy Hampsten, Passo di Gavia, Italy 1988"
    set bmsg($idx,long) "Andy Hampsten climbing Gavia Pass, 8,632 ft,\n"
    append bmsg($idx,long) "on his way to winning the 1988 Giro d'Italia"

    # chinaroad: http://www.bikechina.com/photogz1.html
    incr idx
    set bmsg($idx,iname) chinaroad.gif
    set bmsg($idx,short) "Biking through China"
    set bmsg($idx,long) "Biking through China"

    # # Galibier: http://www.velolasource.com/
    # incr idx
    # set bmsg($idx,iname) galibier.gif
    # set bmsg($idx,short) "Descending from Galibier Pass"
    # set bmsg($idx,long) "Descending from Galibier Pass"

    # # Col du Coq: http://www.cycling-ahead.com/CA-Gallery-2.htm
    # incr idx
    # set bmsg($idx,iname) colducoq.gif
    # set bmsg($idx,short) "The Col du Coq and the Dent de Crolles"
    # set bmsg($idx,long) "The Col du Coq and the Dent de Crolles"

    # High Alps: http://www.cycling-ahead.com/TheRegion.htm
    # incr idx
    # set bmsg($idx,iname) highalps.gif
    # set bmsg($idx,short) "High Alps"
    # set bmsg($idx,long) "High Alps"

    # Le Berarde: http://www.cycling-ahead.com/CA-Gallery-6.htm
    incr idx
    set bmsg($idx,iname) berarde.gif
    set bmsg($idx,short) "The road to La Berarde in the Ecrins Massif"
    set bmsg($idx,long) "The road to La Berarde in the Ecrins Massif"

    # The Col du Galibier: http://www.cycling-ahead.com/CA-Gallery-7.htm
    incr idx
    set bmsg($idx,iname) galibier2.gif
    set bmsg($idx,short) "Col du Galibier"
    set bmsg($idx,long) "Col du Galibier"

    # Grand Goulets: http://www.cycling-ahead.com/CA-Gallery-4.htm
    incr idx
    set bmsg($idx,iname) goulets.gif
    set bmsg($idx,short) "Cycling into the Grand Goulets"
    set bmsg($idx,long) "Cycling into the Grand Goulets"

    # Vercors: http://www.cycling-ahead.com/TheRegion.htm
    #incr idx
    #set bmsg($idx,iname) vercors.gif
    #set bmsg($idx,short) "Vercors"
    #set bmsg($idx,long) "Vercors"

    # Col de Sarenne: http://www.cycling-ahead.com/CA-Gallery8.htm
    incr idx
    set bmsg($idx,iname) sarenne.gif
    set bmsg($idx,short) "Col de Sarenne"
    set bmsg($idx,long) "The back way to Alpe d'Huez on the Col de Sarenne"

    # http://homepage.ntlworld.com/veloarchive/races/tour/1924.htm
    # Ottavio Bottechia rides the Col d'Izoard
    incr idx
    set bmsg($idx,iname) bottecchia.gif
    set bmsg($idx,short) "Ottavio Bottecchia rides the Col d'Izoard"
    set bmsg($idx,long) "Ottavio Bottecchia rides the Col d'Izoard"

    # # TdF http://homepage.ntlworld.com/veloarchive/races/tour/1925.htm
    # # The early tour in the mountains
    # incr idx
    # set bmsg($idx,iname) mountains.gif
    # set bmsg($idx,short) "The early tour in the mountains"
    # set bmsg($idx,long) "The early tour in the mountains"

    if {$::state(can,jpeg)} {
	# http://www.chainreaction.com/tdf03oldmanyoungboy.htm
	# Old man and young boy on Champs
	incr idx
	set bmsg($idx,iname) chainReaction.jpg
	set bmsg($idx,short) "Passing the Torch, TdF '03"
	set bmsg($idx,long) "Passing the torch, TdF '03\n"
	append bmsg($idx,long) "photograph by Mike Jacoubowsky\n"
	append bmsg($idx,long) "http://www.chainreaction.com/tdf03oldmanyoungboy.htm"

	# http://www.cyclingnews.com/photos/2001/apr01/parisroubaix/FShincapie.shtml
	# Hincapie
	incr idx
	set bmsg($idx,iname) hincapie.jpg
	set bmsg($idx,short) "The pav\xE9 of Paris Roubaix, 2001"
	set bmsg($idx,long) "The pav\xE9 of Paris Roubaix, 2001\n"
	append bmsg($idx,long) "George Hincapie, Johan Museeuw and Servais Knaven"

	# http://www.gazzetta.it/gazzetta/common/area_gazzetta/gallerie/galleria.html?ciclismo/2005/gennaio/coppi45&1
	# Coppi and Giro 1955
	incr idx
	set bmsg($idx,iname) coppi.jpg
	set bmsg($idx,short) "Fausto Coppi, 1955 Giro d'Italia"
	set bmsg($idx,long) "Fausto Coppi, 1955 Giro d'Italia"


	# http://grahamwatson.com/dublin/misc/image59.html
	# Tour on the Col d'Aubisque, 1994
	incr idx
	set bmsg($idx,iname) coldaubisque.jpg
	set bmsg($idx,short) "Tour on the Col d'Aubisque, 1994"
	set bmsg($idx,long) "Tour on the Col d'Aubisque, 1994"


	# http://grahamwatson.com/wallpapers/assortedwall/wallpapers/2005/giro800x600.html
	# Giro on Stelvio, 2005
	incr idx
	set bmsg($idx,iname) stelvio2.jpg
	set bmsg($idx,short) "2005 Giro on Passo Stelvio"
	set bmsg($idx,long) $bmsg($idx,short)


	# http://www.cyclingnews.com/photos/2006/tour06/?id=presentation/JD1
	# The start of stage 8 in Morzine at the 2003 Tour de France.
	incr idx
	set bmsg($idx,iname) morzine.jpg
	set bmsg($idx,short) "Stage 8 in Morzine at the 2003 Tour de France."
	set bmsg($idx,short) "2003 Tour in Morzine"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://ecycletours.com/images/Images02/French%20Alps%20Digitals/
	incr idx
	set bmsg($idx,iname) albiezview.jpg
	set bmsg($idx,short) "The alpine town of Albiez le Jeune"
	set bmsg($idx,long) "The alpine town of Albiez le Jeune"

	incr idx
	set bmsg($idx,iname) romeyertunnel.jpg
	set bmsg($idx,short) "Tunnel on the Col de Romeyer"
	set bmsg($idx,long) "Tunnel on the Col de Romeyer"

	incr idx
	set bmsg($idx,iname) descendingverdon.jpg
	set bmsg($idx,short) "Descending in the Gorges du Verdon"
	set bmsg($idx,long) "Descending in the Gorges du Verdon"

	incr idx
	set bmsg($idx,iname) montventoux.jpg
	set bmsg($idx,short) "The summit of Mont Ventoux"
	set bmsg($idx,long) "Approaching the summit of Mont Ventoux"

	# http://www.torelli.com/raceinfo/tdf/tdfhistory1910.html
	incr idx
	set bmsg($idx,iname) lapize.jpg
	set bmsg($idx,short) "Octave Lapize on the Tourmalet, 1910 TdF"
	set bmsg($idx,long) "Octave Lapize on the Tourmalet, 1910 TdF\n"
	append bmsg($idx,long) "\x22You are assassins, yes, assassins!\x22\n"
	append bmsg($idx,long) "\[Vous \xEAtes des assassins!\]\n"

	# http://arnica.csustan.edu/jacklin/East_Peak_Mt_Tam_2/Images/dscn9684.jpg
	incr idx
	set bmsg($idx,iname) mttam.jpg
	set bmsg($idx,short) "East Peak, Mt. Tamalpais"
	set bmsg($idx,long) "East Peak, Mt. Tamalpais"

	# http://asbillccsit.org/ptfImg_0150.jpg
	incr idx
	set bmsg($idx,iname) mtdiablo.jpg
	set bmsg($idx,short) "Looking north from Mount Diablo"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.cs.utexas.edu/~shmat/photo/flying/96petaluma2/slides/05diablo.html
	incr idx
	set bmsg($idx,iname) mtdiablo2.jpg
	set bmsg($idx,short) "Mount Diablo"
	set bmsg($idx,long) $bmsg($idx,short)


	# http://velonews.com/news/fea/8083.0.html
	# http://velonews.com/galleries/contest3a/Cycling%20above%20San%20Francisco%20by%20Jeff%20Dale.html
	incr idx
	set bmsg($idx,iname) goldengate.jpg
	set bmsg($idx,short) "Golden Gate Bridge"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://velonews.com/galleries/contest3a/Col%20de%20la%20Madelene%20-%20by%20H%20Latondresse.html
	incr idx
	set bmsg($idx,iname) madelene.jpg
	set bmsg($idx,short) "Col de la Madelene"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://velonews.com/galleries/contest3b/Cathedral%20Rock%20Sedona%20AZ%20by%20Omar%20Cedillos.html
	incr idx
	set bmsg($idx,iname) cathedral.jpg
	set bmsg($idx,short) "Cathedral Rock, Sedona AZ"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://velonews.com/galleries/contest3c/Death%20Valley%20cycling%20below%20sea%20level%20-%20by%20Rob%20Heather.html
	incr idx
	set bmsg($idx,iname) deathvalley.jpg
	set bmsg($idx,short) "Death Valley"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://velonews.com/galleries/contest2/Friends%20riding%20The%20Dolomites%20by%20Glenn%20Ackerson.html
	incr idx
	set bmsg($idx,iname) dolomites.jpg
	set bmsg($idx,short) "The Dolomites"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://velonews.com/galleries/contest30a/Top%20of%20Old%20LaHonda%20-%20Roy%20Grant.html
	incr idx
	set bmsg($idx,iname) olh.jpg
	set bmsg($idx,short) "The Top of Old La Honda"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.cyclingnews.com/photos/2006/feb06/california06/california062/Tour_CA_stage2-pano.jpg
	incr idx
	set bmsg($idx,iname) redwoodrd.jpg
	set bmsg($idx,short) "Upper San Leandro Reservoir, Moraga"
	set bmsg($idx,long) "The Tour of California on Redwood Rd, Moraga\n"
	append bmsg($idx,long) "passing by San Leandro Reservoir, 2006"

	# http://www.cyclingnews.com/photos/2006/feb06/california06/?id=california062/JDtcastg207
	incr idx
	set bmsg($idx,iname) sierragrade.jpg
	set bmsg($idx,short) "The Tour of California climbing Sierra Grade"
	set bmsg($idx,long) $bmsg($idx,short)

	incr idx
	set bmsg($idx,iname) vanest.jpg
	set bmsg($idx,short) "Wim Van Est crashing on Col d'Aubisque"
	set bmsg($idx,long) "Wim Van Est being pulled up by a rope made of\n"
	append bmsg($idx,long) "inner tubes after crashing while descending\n"
	append bmsg($idx,long) "the Col d'Aubisque in the 1951 TdF."

	# http://www.steephill.tv/grassyknoll/index.php
	incr idx
	set bmsg($idx,iname) steephill1.jpg
	set bmsg($idx,short) "Contemplating the moment"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://bike.terrymorse.com/costanoa0208/pages/P8250027.html
	incr idx
	set bmsg($idx,iname) olh2.jpg
	set bmsg($idx,short) "Old La Honda Descent"
	set bmsg($idx,long) "Old La Honda Descent\nby Terry Morse"

	# http://www.goba.com/photos/scrapbook04/Covers-P1-Pages/Image5.html
	incr idx
	set bmsg($idx,iname) goba.jpg
	set bmsg($idx,short) "Morning Before a Long Tour Day"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.cyclingnews.com/photos/2006/jun06/dauphinelibere06/index.php?id=/photos/2006/jun06/dauphinelibere06/dauphinelibere066/30
	incr idx
	set bmsg($idx,iname) galibier3.jpg
	set bmsg($idx,short) "col du Galibier"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.villagecycle.com/links.asp
	incr idx
	set bmsg($idx,iname) alpedhuez2.jpg
	set bmsg($idx,short) "L'Alpe D'Huez"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.92ee.com/photo/DetailView.htm?Detail=images/sports/04/bicycle-07.jpg
	incr idx
	set bmsg($idx,iname) mtntop.jpg
	set bmsg($idx,short) "Top of the World"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.roberts-1.com/t/b06/ch/k/b/index.htm
	incr idx
	set bmsg($idx,iname) grimselpass.jpg
	set bmsg($idx,short) "Grimselpass"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.trekearth.com/gallery/Asia/India/photo160501.htm
	incr idx
	set bmsg($idx,iname) bicyclesunset.jpg
	set bmsg($idx,short) "Bicycle Sunset"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.cyclingnews.com/photos/2006/oct06/moab24hr06/noneother.jpg
	incr idx
	set bmsg($idx,iname) moab.jpg
	set bmsg($idx,short) "24 Hours of Moab"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.cyclesgladiator.com/cycles_cabernet_centralcoast_2004.jpg
	incr idx
	set bmsg($idx,iname) wine.jpg
	set bmsg($idx,short) "Wine Label"
	set bmsg($idx,long) $bmsg($idx,short)
	append bmsg($idx,long) "\nOriginal painting by G. Massias (1895)"

	# http://www.blogger.com/profile/08273797531067256254
	# http://www.scottberkun.com/images/22-1.jpg
	incr idx
	set bmsg($idx,iname) traffic.jpg
	set bmsg($idx,short) "Watch were you're going!"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://velonews.com/galleries/2006Gallery/Riding%20to%20Convict%20Lake%20near%20Mammoth%20Lakes%20-%20by%20Steve%20Schmunk.jpg
	incr idx
	set bmsg($idx,iname) mammoth.jpg
	set bmsg($idx,short) "Riding to Convict Lake near Mammoth Lakes"
	set bmsg($idx,long) $bmsg($idx,short)
	append bmsg($idx,long) "\nby Steve Schmunk"

	# http://velonews.com/galleries/2006Gallery/Tour%20of%20California%20at%20Bixby%20Bridge%20-%20by%20Darrell%20Parks.jpg
	incr idx
	set bmsg($idx,iname) bixby.jpg
	set bmsg($idx,short) "Tour of California at Bixby Bridge"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://sonic.net/~ckelly/Seekay/repack_results2.htm
	# http://sonic.net/~ckelly/Seekay/repack.htm
	incr idx
	set bmsg($idx,iname) repack.jpg
	set bmsg($idx,short) "The Repack Course, Marin County"
	set bmsg($idx,long) $bmsg($idx,short)

	# Paul.Frank@CH2M.com
	incr idx
	set bmsg($idx,iname) montegelbison.jpg
	set bmsg($idx,short) "Silvano Esposito climbing Monte Gelbison\nsouthern Italy"
	set bmsg($idx,long) $bmsg($idx,short)

	# Utah trip
	incr idx
	set bmsg($idx,iname) kolob.jpg
	set bmsg($idx,short) "Author climbing to Kolob Reservoir, Zion NP"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.panoramio.com/photo/4899022
	incr idx
	set bmsg($idx,iname) nimitz.jpg
	set bmsg($idx,short) "Nimitz Way"
	set bmsg($idx,long) "Where I proposed to my wife Kristina (she said yes!)"

	# http://cyclingnews.com/photos/2009/features/TOC_climbs_feb09/img_0051.jpg
	incr idx
	set bmsg($idx,iname) tunitas.jpg
	set bmsg($idx,short) "The redwoods on Tunitas Creek Road"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://cache.boston.com/multimedia/sports/bigshots/toc/bs13.jpg
	incr idx
	set bmsg($idx,iname) tunitasTOC.jpg
	set bmsg($idx,short) "Tour of California climbing Tunitas Creek"
	set bmsg($idx,long) $bmsg($idx,short)

	# http://www.dailymail.co.uk/news/article-1193610/Dont-look-Cyclists-faced-huge-hole-ground-towpath--luckily-just-pavement-art.html
	incr idx
	set bmsg($idx,iname) sidewalk.jpg
	set bmsg($idx,short) "Sidewalk art"
	set bmsg($idx,long) "Sidewalk art in Islington, North London"

	# http://www.sacbee.com/static/weblogs/photos/2009/07/tour-de-france-enters-the-seco.html
	incr idx
	set bmsg($idx,iname) envalira.jpg
	set bmsg($idx,short) "Envalira Pass"
	set bmsg($idx,long) "2009 Tour de France ascendng Envalira Pass"

	# http://lh6.ggpht.com/_x5aOqwilXUo/R8HHRGNkpHI/AAAAAAAAQRE/wSt_Pd7VQu4/BalernoSlateford20.jpg
	incr idx
	set bmsg($idx,iname) BalernoSlateford20.jpg
	set bmsg($idx,short) "Country road new Edinburgh"
	set bmsg($idx,long) "Country road new Edinburgh"

	# http://www.reddit.com/r/pics/comments/ashap/no_this_is_an_amazing_circuit/
	incr idx
	set bmsg($idx,iname) Nordschleife.jpg
	set bmsg($idx,short) "Nordschleife race track in Germany"
	set bmsg($idx,long) "Nordschleife race track in Germany"

	# http://www.cyclingtipsblog.com/2010/07/galerie-de-defago/
	incr idx
	set bmsg($idx,iname) defago.jpg
	set bmsg($idx,short) "Galrie de Dfago"
	set bmsg($idx,long) "Galrie de Dfago, Champery Switzerland"

	# http://www.cyclingtipsblog.com/2010/06/passportes-du-soleil/
	incr idx
	set bmsg($idx,iname) duSoleil.jpg
	set bmsg($idx,short) "Pass'Portes du Soleil"
	set bmsg($idx,long) "Pass'Portes du Soleil, Champery Switzerland"

	# http://www.cyclingtipsblog.com/2010/06/coming-out-of-the-closet/

	# http://www.flickr.com/photos/maciej_balajewicz/5161788627/sizes/l/in/photostream/
	incr idx
	set bmsg($idx,iname) countryRoad.jpg
	set bmsg($idx,short) "Riding on a country road"
	set bmsg($idx,long) "Riding on a country road"

        # https://upload.wikimedia.org/wikipedia/commons/7/79/Aldo_Moser%2C_Giro_d%27Italia_1965.jpg
	incr idx
	set bmsg($idx,iname) stelvio1965.jpg
	set bmsg($idx,short) "Stelvio 1965 Giro d'Italia"
	set bmsg($idx,long) "Aldo Moser on the Passo dello Stelvio during the 1965 Giro d'Italia"

    }
    ::About::RemoveMissingImages
    ::About::ShuffleImages
}
##+##########################################################################
#
# ::About::ShuffleImages -- re-orders the about images
#
proc ::About::ShuffleImages {} {
    variable bmsg
    variable noShuffle

    if {$noShuffle} return			;# Debugging

    set len [llength [array names bmsg *,iname]]
    set len2 $len
    for {set i 0} {$i < $len-1} {incr i} {
	set n [expr {int($i + $len2 * rand())}]
	incr len2 -1

	# Swap elements at i & n
	unset -nocomplain tmp
	array set tmp [array get bmsg $i,*]
	array unset bmsg $i,*
	foreach arr [array names bmsg $n,*] {
	    regsub "^$n," $arr "$i," arr2
	    set bmsg($arr2) $bmsg($arr)
	}
	array unset bmsg $n,*
	foreach arr [array names tmp] {
	    regsub "^$i," $arr "$n," arr2
	    set bmsg($arr2) $tmp($arr)
	}
    }
}
##+##########################################################################
#
# ::About::RemoveMissingImages -- Removes any missing about images
#
proc ::About::RemoveMissingImages {} {
    variable bmsg

    set valid {}
    set len [llength [array names bmsg *,iname]]
    for {set i 0} {$i < $len} {incr i} {
	set iname [file join $::state(idir) about $bmsg($i,iname)]
	if {[file exists $iname]} {
	    lappend valid $i
	}
    }
    unset -nocomplain tmp
    array set tmp [array get bmsg]
    array unset bmsg
    set slot 0
    foreach i $valid {
	set bmsg($slot,iname) $tmp($i,iname)
	set bmsg($slot,long) $tmp($i,long)
	set bmsg($slot,short) $tmp($i,short)
	incr slot
    }
}
##+##########################################################################
#
# ::About::License
#
# Shows the license for this software
#
set license \
	{First off, this program is freeware: you can use it and distribute it
freely. If you like it and want to contribute to its further development,
send $10 to:

	Keith Vetter
	457 N Granger St
	Granville, OH 43023

I hope you enjoy the program. Send me email if you like it or have
suggestions.

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

Here's the actual license terms, cribbed heavily from the tcl/tk license.

This software is copyrighted by Keith P. Vetter. The following terms apply to
all files associated with the software unless explicitly disclaimed in the
individual files.

The authors hereby grant permission to use, copy, modify, distribute, and
license this software and its documentation for any purpose, provided that
existing copyright notices are retained in all copies and that this notice is
included verbatim in any distributions. No written agreement, license, or
royalty fee is required for any of the authorized uses. Modifications to this
software may be copyrighted by their authors and need not follow the
licensing terms described here, provided that the new terms are clearly
indicated on the first page of each file where they apply.

IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO
ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS
SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, AND NON-INFRINGEMENT. THIS SOFTWARE IS PROVIDED ON
AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.

GOVERNMENT USE: If you are acquiring this software on behalf of the U.S.
government, the Government shall have only "Restricted Rights" in the
software and related documentation as defined in the Federal Acquisition
Regulations (FARs) in Clause 52.227.19 (c) (2). If you are acquiring the
software on behalf of the Department of Defense, the software shall be
classified as "Commercial Computer Software" and the Government shall have
only "Restricted Rights" as defined in Clause 252.227-7013 (c) (1) of DFARs.
Notwithstanding the foregoing, the authors grant the U.S. Government and
others acting in its behalf permission to use and distribute the software in
accordance with the terms specified in this license.}

set copyright \
    {<b>KLIMB

Copyright 2001-<year> Keith P. Vetter

<b>Bay Area Cycling Atlas data

Copyright 1992,1998 William D. B. Bushnell

<b>Photo Credits

 Jobst Brandt: http://www.trentobike.org/Countries/Europe/Tour_Reports/Tour_of_the_Alps/
 Mike Jacoubowsky: http://www.chainreaction.com/
 Steve Hill: http://www.steephill.tv

<b>gnuplot

Copyright 1986 - 1993, 1998, 2004   Thomas Williams, Colin Kelley

Permission to use, copy, and distribute this software and its
documentation for any purpose with or without fee is hereby granted,
provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear
in supporting documentation.

Permission to modify the software is granted, but not the right to
distribute the complete modified source code.  Modifications are to
be distributed as patches to the released version.  Permission to
distribute binaries produced by compiling modified sources is granted,
provided you
  1. distribute the corresponding source modifications from the
released version in the form of a patch file along with the binaries,
  2. add special version identification to distinguish your version in
addition to the base release version number,
  3. provide your name and address as the primary contact for the support
of your modified version, and
  4. retain our contact information in regard to use of the base software.

Permission to distribute the released version of the source code along
with corresponding source modifications in the form of a patch file is
granted with same provisions 2 through 4 for binary distributions.

This software is provided "as is" without express or implied warranty
to the extent permitted by applicable law.
}
regsub -all {<year>} $copyright [clock format [clock seconds] -format %Y] copyright
##+##########################################################################
#
# ::About::License -- displays our license
#
proc ::About::License {who} {
    set ok [list "license" "copyright" "BETA" "NEW"]
    if {[lsearch $ok $who] == -1} return
    global $who WHATSNEW

    if {$who eq "NEW" || $who eq "BETA"} {
	set txt "<h1>$::state(progname) Change Log\n\n\n"
	set txt2 [::About::_GetWhatsNew]
	append txt $txt2
	set who [expr {$who eq "NEW" ? "What's New" : "BETA Information"}]
	set title "$::state(progname) $who"
	set wantANI 1
    } else {
	regsub -all {\n} [set $who] {_} txt
	regsub -all {__} $txt "\n\n" txt
	regsub -all {_ } $txt "\n " txt
	regsub -all {_} $txt " " txt
	set wantANI 0
	set title "$::state(progname) [string totitle $who]"
    }

    set W .license
    ::Display::MakeDialogBox $W $title $title [list ::img::icon klimb.gif]
    wm resizable $W 1 1

    if {$wantANI && [::Data::CanDo anigif]} {
	# Anigif doesn't seem to work w/ ::ttk::labels, use a ::tk::label
	set ginfo [grid info $W.icon]
	destroy $W.icon
	::tk::label $W.icon -width 0 -height 0
	eval grid $W.icon $ginfo
	::anigif::anigif [file join $::state(idir) roadie.gif] $W.icon
    }

    set WB $W.body
    ::ttk::scrollbar $WB.sb_y -command [list $WB.t yview] -orient vertical
    text $WB.t -yscrollcommand [list $WB.sb_y set] -bd 3 -wrap word \
	-tabs {.2i .3i} -font {Helvetica 8}
    #::Display::TileBGFix $WB.t
    $WB.t tag configure bold -font boldFont
    $WB.t tag configure bolder -font bolderFont
    $WB.t tag configure header -font bigBold -justify center
    foreach line [split $txt "\n"] {
	if {[string match "<b>*" $line]} {
	    $WB.t insert end "[string range $line 3 end]\n" bold
	} elseif {[string match "<h1>*" $line]} {
	    $WB.t insert end "[string range $line 4 end]\n" header
	} elseif {[string match "<h2>*" $line]} {
	    $WB.t insert end "[string range $line 4 end]\n" bolder
	} elseif {$line eq "<hr>"} {
	    $WB.t insert end [string repeat "_" 64]\n\n
	} else {
	    $WB.t insert end "$line\n" normal
	}
    }
    $WB.t config -state disabled
    pack $WB.sb_y -side right -fill y
    pack $WB.t -side right -fill both -expand 1

    ::ttk::button $W.buttons.dismiss -text "Dismiss" -command [list destroy $W]
    pack $W.buttons.dismiss -side left -expand 1 -pady 10

    ::Display::CenterWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::About::_GetWhatsNew -- Gets pretty text version of our change log
# in a wiki'ish format
#
proc ::About::_GetWhatsNew {} {
    global WHATSNEW

    set versions [array names WHATSNEW]
    set versions [lsort -dictionary -decreasing -unique $versions]

    set txt ""
    set bullet \u2022
    foreach version $versions {
	array set items [_GrindWhatsNew $WHATSNEW($version)]

	if {$txt ne ""} { append txt "<hr>\n" }

	append txt "<h2>KLIMB V$version\n"
	foreach pre {* = -} who {"Major Features" "Minor Features" "Bug Fixes"} {
	    if {$items($pre) eq ""} continue

	    append txt "<b>$who\n"
	    set ldate ""
	    foreach {date item} $items($pre) {
		if {$date ne $ldate} {
		    append txt "\t$date\n"
		    set ldate $date
		}
		append txt "\t\t$bullet $item\n"
	    }
	    append txt \n
	}
    }
    return $txt
}
##+##########################################################################
#
# ::About::_GrindWhatsNew -- text processes what's new info
#
proc ::About::_GrindWhatsNew {txt} {
    foreach pre {- * =} {
	set items($pre) {}
    }
    foreach line [split [string trim $txt] "\n"] {
	set n [regexp {^[\# \t]*?KPV\s+(.*?)\s+-\s+?(.*?)$} $line => date i]
	if {! $n} continue
	foreach item [split $i ";"] {
	    set item [string trim $item]
	    set pre [string index $item 0]
	    if {$pre eq "-" || $pre eq "*"} {
		set item [string range $item 1 end]
	    } else {
		set pre "="
	    }
	    lappend items($pre) $date $item
	}
    }
    return [array get items]
}
###+##########################################################################
##
## ::About::_GrindWhatsNew -- text processes what's new info
##
#proc ::About::_GrindWhatsNew {txt} {
#
#    set major ""
#    set minor ""
#    set ldate1 ""
#    set ldate2 ""
#    foreach line [split [string trim $txt] "\n"] {
#	set n [regexp {^[\# \t]*?KPV\s+(.*?)\s+-\s+?(.*?)$} $line => date i]
#	if {! $n} continue
#	foreach item [split $i ";"] {
#	    set item [string trim $item]
#	    if {[string index $item 0] eq "-"} continue
#	    if {[string index $item 0] eq "*"} {
#		if {$date ne $ldate1} {
#		    append major "\t$date\n"
#		    set ldate1 $date
#		}
#		append major "\t\t- [string range $item 1 end]\n"
#	    } else {
#		if {$date ne $ldate2} {
#		    append minor "\t$date\n"
#		    set ldate2 $date
#		}
#		append minor "\t\t- $item\n"
#	    }
#	}
#    }
#    return [list $major $minor]
#}
##+##########################################################################
#
# ::About::Quotes -- displays our quotes
#
proc ::About::Quotes {} {
    variable q

    set W .quotes
    set title "$::state(progname) Bicycling Quotes"
    ::Display::MakeDialogBox $W $title $title [list ::img::icon klimb.gif]
    wm resizable $W 1 1

    set txt ""
    set arr [::Data::Shuffle [array names q]]
    foreach a $arr {
	set t $q($a)
	regsub -all {\s*\n\s*} $t { } t
	regsub -all -- {\s+--} $t "\n--" t
	append txt $t "\n\n"
    }

    set WB $W.body
    ::ttk::scrollbar $WB.sb_y -command [list $WB.t yview] -orient vertical
    text $WB.t -yscrollcommand [list $WB.sb_y set] -bd 3 -wrap word -width 60 \
	-font {Helvetica 12}
    #::Display::TileBGFix $WB.t
    $WB.t tag config center -just center -lmargin1 20 -lmargin2 20 -rmargin 20
    $WB.t insert end $txt center
    $WB.t config -state disabled
    pack $WB.sb_y -side right -fill y
    pack $WB.t -side right -fill both -expand 1

    ::ttk::button $W.buttons.dismiss -text "Dismiss" -command [list destroy $W]
    pack $W.buttons.dismiss -side left -expand 1 -pady 10

    ::Display::CenterWindow $W
    wm deiconify $W
    focus $WB.t
}
##+##########################################################################
#
# ::About::Splash -- shows splash screen for amusement during initial loading.
#
proc ::About::Splash {} {
    wm withdraw .				;# Remove main window

    ::Display::MakeImage ::img::splash klimb.gif
    ::About::AboutDlgEx .splash ::img::splash ::About::_Splash
    .splash config -cursor watch		;# Doing a long operation
}
##+##########################################################################
#
# ::About::_Splash
#
# Callback proc for filling in the bottom of the splash screen.
#
proc ::About::_Splash {w} {
    variable q

    if {! [info exists q(0)]} {
	append q(0) "Rightly or wrongly, riders are judged by how\nthey "
	append q(0) "do in the Tour de France. -- Greg Lemond "

	append q(1) "I relax by taking my bicycle apart and putting it "
	append q(1) "back together again. \n-- Michelle Pfieffer "

	append q(2) "When I'm godawful close to the edge--a cliff, a tree-I "
	append q(2) "try to get \nthrough it by believing in myself and "
	append q(2) "saying, \"I can pull this off,\" \nrather than hitting "
	append q(2) "the brake. -- Missy Giove "

	append q(3) "Mountain biking helps people become "
	append q(3) "environmentalists. A mountain \nbike is a vehicle to "
	append q(3) "appreciate the backcountry. -- Ned Overend "

	append q(4) "Bicycle road racing was the only sport in the world. "
	append q(4) "\n-- Ernest Hemingway "

	append q(5) "I have to ask you to stop your riders using \nmobile "
	append q(5) "phones during the race. -- Jean-Marie LeBlanc "

	append q(6) "\"Ride lots.\" \n-- Eddy Merckx on how to train "

	append q(7) "To prepare for a race there is nothing better than a "
	append q(7) "good \npheasant, some champagne and a woman. -- "
	append q(7) "Jacques Anquetil "

	append q(8) "Indurain's a bit like a lizard...he thrives \nonly "
	append q(8) "in the hotter climates. -- Phil Ligget "

	append q(9) "You can't despair for the human race when you \nsee "
	append q(9) "someone riding a bicycle. -- Stewart Parker "

	append q(10) "The nearest experience to cycling is surfing. There "
	append q(10) "is always the perfect ride that comes \nup. You're "
	append q(10) "eating right. Feel just right. It all clicks. And it "
	append q(10) "is like that in surfing. There's \nthe draw of the "
	append q(10) "perfect ride enough to keep you up day after day. -- "
	append q(10) "Georgena Terry "

	append q(11) "It's more important who you train with \nthan whose "
	append q(11) "bike you're riding. -- Gary Fisher "

	append q(12) "Nine or ten days of continuous cycling leave a lot of "
	append q(12) "time for \nintrospection. I think it's the learning "
	append q(12) "about myself that brings \nme back to cross-country "
	append q(12) "races. -- Lon Haldeman "

	append q(13) "Toleration is the greatest gift of the mind; it "
	append q(13) "requires the same \neffort of the brain that it takes "
	append q(13) "to balance oneself on a bicycle. \n-- Helen Keller "

	append q(14) "I'm proud of what I've done in the tour, but you "
	append q(14) "have to keep your \nperspective. It's just a bicycle "
	append q(14) "race after all. -- Miguel Indurain "

	append q(15) "When you get to top level racing, the difference in "
	append q(15) "equipment can \nmake a difference between winning and "
	append q(15) "losing, but when you're \nstarting out it doesn't "
	append q(15) "matter. -- Greg Lemond "

	append q(16) "There is no room in the tour for the sick or the "
	append q(16) "weak. \n-- Laurent Jalabert "

	append q(17) "You can't mountain bike and think about dinner or "
	append q(17) "divorce or the bills. You need to be \none big "
	append q(17) "sensory receptor if you're going to stay within the "
	append q(17) "margins of control. You need \nto be like an animal. "
	append q(17) "They don't think about the bills. -- Jacquie Phelen "

	append q(18) "When I get in a race, I'm nobody's friend. \n-- "
	append q(18) "Davis Phinney "

	append q(19) "The ungainly geometry and primitive mechanicals of "
	append q(19) "the bicycle are an offense to the eye. \nThe grimy "
	append q(19) "and perspiring riders of the bicycle are an offense "
	append q(19) "to the nose. And the very \nexistence of the bicycle "
	append q(19) "is an offense to reason and wisdom. -- P. J. O'Rourke "

	append q(20) "My bike is an iron mistress. \n-- John Howard "

	append q(21) "Refrain from throwing your bicycle in public. It "
	append q(21) "shows poor upbringing. \n-- Jacquie Phelan "

	append q(22) "Dairy Queen. God, I dream about Dairy Queens. \n-- "
	append q(22) "Greg Lemond "

	append q(23) "I ride for passion. Cycling is too hard to do just "
	append q(23) "for the money. \n-- Paola Pezzo "

	append q(24) "Not only did I break my seatpost, I also broke a "
	append q(24) "nail. \n-- Kathy Sessler "

	append q(25) "I guess I just have bigger ovaries. \n-- Missy "
	append q(25) "Giove "

	append q(26) "The Europeans look down on raising your hands. They "
	append q(26) "don't like the end-zone \ndance. I think that's "
	append q(26) "unfortunate. That feeling--the finish line, the last "
	append q(26) "couple of \nmeters--is what motivates me. -- Lance "
	append q(26) "Armstrong "

	append q(27) "I am told that men who compete in certain kinds of "
	append q(27) "athletics--such as \nbicycle racing--shave their legs "
	append q(27) "to prevent wind drag, and also to \navoid getting their "
	append q(27) "hair caught in the chain. -- Abigail Van Buren "

	append q(28) "The bicycle riders drank much wine, and were burned "
	append q(28) "and browned by the sun. \nThey did not take the race "
	append q(28) "seriously except among themselves. \n-- Ernest "
	append q(28) "Hemingway "

	append q(29) "Get a bicycle. You will not regret it if you live. "
	append q(29) "\n-- Mark Twain "

	append q(30) "Be at one with the universe.\nIf you can't do that, "
	append q(30) "at least be at one with your bike. \n-- Leonard Zinn "

	append q(31) "Biking is my art form--my self expression. \n-- "
	append q(31) "Missy Giove "

	append q(32) "The way you learn, is you go around a corner and "
	append q(32) "crash. Then you \nknow that's too fast so the next "
	append q(32) "time you go a little slower. \n-- Ron Kiefel "

	append q(33) "Cyril: Hey! Are you really gonna shave your legs?\n"
	append q(33) "Dave: Certo! All the Italians do it.\n"
	append q(33) "Cyril: Ah. Some country. The women don't shave theirs.\n"
	append q(33) "--Breaking Away"

	append q(34) "This is not Disneyland, or Hollywood. I'll give you an "
	append q(34) "example: I've read that I flew up \nthe hills and "
	append q(34) "mountains of France. But you don't fly up a hill. "
	append q(34) "You struggle slowly \nand painfully up a hill, and maybe, "
	append q(34) "if you work very hard, you get to the \ntop ahead of "
	append q(34) "everybody else. -- Lance Armstrong"

	append q(35) "I think it \[the bicycle\] has done more to "
	append q(35) "emancipate women than anything else\nin the world. I "
	append q(35) "stand and rejoice every time I see a woman ride on "
	append q(35) "a wheel.\nIt gives a woman a feeling of freedom and "
	append q(35) "self reliance.\n-- Susan B. Anthony"

	append q(36) "When the spirits are low, when the day appears dark, "
	append q(36) "when work becomes monotonous, \nwhen hope hardly "
	append q(36) "seems worth having, just mount a bicycle and go "
	append q(36) "out for a spin down \nthe road, without "
	append q(36) "thought on anything but the ride you are taking. "
	append q(36) "\n-- Sir Arthur Conan Doyle, January 18, 1896, "
	append q(36) "Scientific American Magazine"

	append q(37) "She who succeeds in gaining the mastery of the bicycle "
	append q(37) "will gain the mastery of life.\n --Frances E. Willard, "
	append q(37) "_How I Learned to Ride the Bicycle_"

	append q(38) "It doesn't get easier; you just get faster.\n"
	append q(38) " --Greg Lemond, three time winner of Tour de France"

	append q(39) "When I go biking...I am mentally far far away from "
	append q(39) "civilization. The world is\nbreaking someone else's "
	append q(39) "heart. -- Diane Ackerman"

	append q(40) "Getting up at six and racing up a col from the "
	append q(40) "gun is a bitch. \n-- Jacky Durand"

	append q(41) "Think of bicycles as rideable art that can just about "
	append q(41) "save the world. \n-- Grant Peterson"

	append q(42) "Nothing compares to the simple pleasure of a bike "
	append q(42) "ride. \n-- John F. Kennedy"

	append q(43) "Enough with this sunday stroll...let's hurt a "
	append q(43) "little bit. \n-- American Flyers"

	append q(44) "When I see an adult on a bicycle, I do not despair\n"
	append q(44) "for the future of the human race. -- H. G. Wells"

	append q(45) "To finish the race requires a heart that won't "
	append q(45) "quit \nwhen the body begs it to. -- Greg Lemond"

	append q(46) "2nd place, 3rd place, what's the difference?\n"
	append q(46) "The only place that matters is first -- Sean Kelly"

	append q(47) "You never have the wind with you--either it is against\n"
	append q(47) "you or you're having a good day. -- Daniel Behrman"

	append q(48) "It is by riding a bicycle that you learn the contours\n"
	append q(48) "of a country best. -- Ernest Hemingway"

	append q(49) "\[C]ome on, man, at the end of the day, it's just bicycle\n"
	append q(49) "racing. We're not solving the world's problems here, are we?"
	append q(49) "\n-- Floyd Landis"

	append q(50) "A bicycle is one of the world's beautiful machines, "
	append q(50) "beautiful\nmachines are art, and art is civilisation, "
	append q(50) "good living, and\nbalm to the soul. --Elisa Francesca Roselli"

	append q(51) "Losing weight is the single most important thing you can do."
	append q(51) "\nYou have to train. You have to be strong, of course.\n"
	append q(51) "But if you're too heavy, it's all over. -- Lance Armstrong"

	append q(52) "You can have all the heart in the world, but it doesn't\n"
	append q(52) "anything unless you've got the legs. -- Lance Armstrong"

	append q(53) "Bicycling is a healthy and manly pursuit with much\n"
	append q(53) "to recommend it, and, unlike other foolish crazes,\n"
	append q(53) "it has not died out. -- The Daily Telegraph (1877)"

	append q(54) "Learn to swear in several different languages.\n"
	append q(54) "Other riders will appreciate your efforts to communicate.\n"
	append q(54) "-- Robert Millar"

	append q(55) "These cyclists are playing chess with each other.\n"
	append q(55) "They are shuffling the cards even as we speak!\n"
	append q(55) "--sportcaster covering the World Cycling Championships"

        append q(56) "On a bike, being just slightly above pedestrian and car eye level,\n"
        append q(56) "one gets a perfect view of the goings-on in one's own town.\n"
        append q(56) "-- David Byrne"

        # http://www.bikeradar.com/us/gear/article/22-inspirational-cycling-quotes-34881/
        append q(57) "Don't buy upgrades, ride up grades. -- Eddy Mercx"
    }

    wm overrideredirect $w 1
    foreach ww [winfo children $w] {
	$ww config -cursor watch
    }

    $w.txt config -height 14
    $w.txt insert end \n\n

    foreach i [array names q] {
	$w.txt tag configure msg_$i -justify center -elide 1
	$w.txt insert end "$q($i)" msg_$i
    }
    ::About::Splasher $w.txt [llength [array names q]]

    ::tk::label $w.l					;# For sizing info
    set h [winfo reqheight $w.l]
    destroy $w.l

    canvas $w.msg -bd 1 -relief sunken -height $h -highlightthickness 0
    $w.msg xview moveto 0 ; $w.msg yview moveto 0
    pack $w.msg -side bottom -fill x
    set x [expr {[winfo reqwidth $w] / 2}]
    set y [expr {$h / 2}]
    $w.msg create text $x $y -tag txt -anchor c
}
##+##########################################################################
#
# ::About::Splasher -- Provides rotating text in the splash window
#
proc ::About::Splasher {W cnt {last -1}} {
    after cancel $::About::aid
    if {![winfo exists $W]} return

    for {set i 0} {$i < $cnt} {incr i} {	;# First hide all the quotes
	$W tag configure msg_$i -elide 1
    }
    while {1} {					;# Pick a new quote
	set n [expr {int ($cnt * rand())}]
	if {$n != $last} break
    }

    $W tag configure msg_$n -elide 0		;# Make the quote visible
    update idletasks

    # Delay based on message length
    set txt [eval $W get [$W tag ranges msg_$n]];# The actual message
    set delay [expr {int (1000 * [string length $txt] / 10.0)}]
    if {$delay < 4000} {set delay 4000}
    set ::About::aid [after $delay [list ::About::Splasher $W $cnt $n]]
}
##+##########################################################################
#
# ::About::AboutDlgEx
#
# Does the actual creation of both the About dialog and the Splash window.
# Invokes a callback routine do handle any differences.
#
proc ::About::AboutDlgEx {w img callback} {
    global state

    destroy $w
    toplevel $w -bd 3 -relief raised
    wm withdraw $w
    wm resizable $w 0 0
    # Create the main text widget
    ::tk::frame $w.top -bg white -bd 2 -relief sunken
    text $w.txt -padx 2m -bd 0 -wrap word -height 22 -background white \
	-highlightthickness 0
    ::tk::frame $w.buttons -bg white
    pack $w.buttons -in $w.top -side bottom -fill both
    pack $w.txt -in $w.top -side bottom -fill y

    # Create the image and headline
    ::tk::frame $w.l1 -bg white
    ::tk::label $w.l1.splash -image $img -bd 0 -bg white
    pack $w.l1.splash -padx 10

    if {[lsearch [image names] ::img::banner] == -1} {
	set fname "banner.gif"
	if {! [info exists state(venue)]} {
	    set state(venue) "unknown"
	    if {[file isdirectory SFBay.zone]} {
		set state(venue) "sfbay"
	    } elseif {[file isdirectory MtTam.zone]} {
		set state(venue) "mttam"
	    } elseif {[file isdirectory Ohio.zone]} {
		set state(venue) "ohio"
	    }
	}
	if {$state(venue) eq "ohio"} {set fname bannerOhio2.gif}
	::Display::MakeImage ::img::banner $fname
    }

    ::tk::label $w.l2 -image ::img::banner -bd 0
    pack $w.top -side top -fill x
    pack $w.l1 -in $w.top -side left -pady 2
    pack $w.l2 -in $w.top -side top -expand 1 -padx {0 5}

    # We need a center tab and a right justify tab. We need to convert
    # from characters to pixels.
    $w.txt config -font {Helvetica 8}
    set rm [font measure [$w.txt cget -font] "0"]
    set rm [expr {[$w.txt cget -width] * $rm}]
    set center [expr {$rm / 2}]
    set third [expr {$rm / 3}]
    set third2 [expr {$rm * 2 / 3}]
    $w.txt config -tabs [list $center center $rm right]

    # Define various text tags
    $w.txt tag configure head -font {Times 18 bold} -foreground red \
	-justify center -wrap word
    $w.txt tag configure link -font {Times 12} -foreground blue \
	-justify center -spacing1 5
    $w.txt tag configure msg -justify center -font {{Tiems Roman} 8}
    $w.txt config -tabs [list $center center $rm right]
    $w.txt tag configure addr -justify center -font {{Times Roman} 8 bold} \
	-spacing1 5

    $w.txt insert end "\n"
    $w.txt insert end "Keith's deLuxe Interactive Map Builder\n" head
    $w.txt insert end "\n"
    $w.txt insert end "by Keith P. Vetter"
    $w.txt insert end "\t\tSF Bay data by William D. B. Bushnell\n"
    $w.txt insert end "klimb@klimb.org"
    $w.txt insert end "\t\tbill.bushnell@pobox.com\n"
    $w.txt insert end "copyright 2001-[clock format [clock seconds] -format %Y]"
    $w.txt insert end "\t\tcopyright 1992, 1998\n"
    set version $state(version)
    regsub {([bk]|$)} $version "$state(build)\\1" version
    $w.txt insert end "version $version"
    $w.txt insert end "\t\tused with permission of author"

    # BUG BUG BUG: os x : something about the following lines disables the menus
    if {$::tcl_platform(os) eq "Darwin"} { wm deiconify $w ; return }

    $callback $w
    $w.txt config -state disabled
    bindtags $w.txt {$w.txt}
    ::Display::CenterWindow $w
    wm deiconify $w
    raise $w
    update idletasks
}
## EON ABOUT
## BON OPTIONS
##+##########################################################################
#
# ::Options::Dialog -- Puts up an option dialog.
#
proc ::Options::Dialog {} {
    global state tcl_platform

    destroy .opt
    toplevel .opt
    ::Display::TileBGFix .opt
    wm transient .opt .
    wm resizable .opt 0 0
    wm withdraw .opt
    wm title .opt "$state(progname) Options"

    set top .opt.top
    ::my::frame $top -borderwidth 2 -relief raised
    pack $top -side top -padx 10 -pady 10 -fill both -expand 1
    ::ttk::button .opt.d -text Dismiss -command [list destroy .opt]
    pack .opt.d -side bottom -pady {0 10}

    foreach {icon fname} {
	::img::icon klimb.gif ::img::su su.gif ::img::zoom zoom.gif
	::img::data data.gif
    } {
	::Display::MakeImage $icon $fname
    }

    ################################################################
    # Section 1 : Windows association
    #
    set w $top.s1
    set txt "Tell Windows to associate the .klm files with this program, "
    append txt "so that double-clicking these files or viewing them in a "
    append txt "web browser causes this program to be run."
    ::Options::Section $w "Windows Association" $txt ::img::icon

    set s [expr {$tcl_platform(platform) eq "windows" ? "normal" : "disabled"}]
    ::ttk::button $w.reg   -text "Associate" -command {::Options::DoReg 1} -state $s
    ::ttk::button $w.unreg -text "Unassociate" -command {::Options::DoReg 0} -state $s
    grid x $w.reg $w.unreg -in $w.buttons -sticky ew -padx {10 0}
    grid columnconfigure $w.buttons 0 -weight 1

    ################################################################
    # Section 2 : Superuser Priviledges
    #
    set w $top.s2
    set txt "Superuser priviledges allows one to edit and create "
    append txt "the built in roads and nodes. This is only relevant "
    append txt "for people creating their own zones and regions."
    ::Options::Section $w "Superuser Priviledges" $txt ::img::su

    ::ttk::checkbutton $w.king -text "Superuser" -variable state(su) \
	-command ::Options::SetSuperuser
    pack $w.king -in $w.buttons -side right

    ################################################################
    # Section 3 : Data Quality
    #
    set w $top.s3
    set wb $w.buttons
    set txt "Data Quality specifies what qualifies as \"bad\" data and should "
    append txt "be displayed in a distinct manner. A check indicates that "
    append txt "this type of data is considered good. See help for details."
    ::Options::Section $w "Data Quality" $txt ::img::data

    foreach n {0 1 2 3} txt {Surveyed "Oneway survey" "Waypoint Altitude"
	"End point delta"} {
	    ::ttk::checkbutton $wb.q$n -text $txt -variable state(quality,$n) \
		-command [list ::Options::NewQuality $n]
	if {! $state(su)} { $wb.q$n config -state disabled}
    }

    for {set i 0} {$i <= 4} {incr i} {
	set state(quality,$i) [expr {$i <= $::zone(goodData) ? 1 : 0}]
    }
    grid x $wb.q0 $wb.q2 -sticky ew -padx {10 0}
    grid x $wb.q1 $wb.q3 -sticky ew -padx {10 0}
    grid columnconfigure $wb 0 -weight 1

    ################################################################
    # Section 4 : Zoom Cleanup
    #
    set w $top.s4
    set txt "The Zoom feature caches map images from the internet "
    append txt "for later quick retrieval."
    ::Options::Section $w "Zoom Cache" $txt ::img::zoom

    set ::Options::stats(current) "Usage: ? mb"
    ::ttk::label $w.current -textvariable ::Options::stats(current)
    ::ttk::button $w.cdelete -text "Delete Cache" -command ::Options::ClearCache
    grid x $w.current $w.cdelete -in $w.buttons -padx {10 0}
    grid columnconfigure $w.buttons 0 -weight 1

    ################################################################
    ################################################################

    pack $top.s1 $top.s2 $top.s3 $top.s4 \
	-fill both -expand 1 -padx 5 -pady 5
    wm deiconify .opt
    update
    after 1000 ::Options::GetDirSize
}
##+##########################################################################
#
# ::Options::Section -- GUI template for a option section
#
proc ::Options::Section {w title txt img} {
    ::my::labelframe $w -text $title
    ::my::label $w.ico -anchor n -image $img

    message $w.txt -text $txt -width 300 -anchor w
    ::Display::TileBGFix $w.txt
    ::my::frame $w.buttons
    grid $w.ico $w.txt -sticky new -padx 10 -row 1
    grid ^ $w.buttons -sticky news -padx 10 -pady 5
    grid rowconfigure $w 0 -minsize 5
    grid columnconfigure $w 1 -weight 1
    grid columnconfigure $w 0 -minsize 100

    return $w
}
##+##########################################################################
#
# ::Options::ClearCache -- deletes our zoom cache
#
proc ::Options::ClearCache {} {
    variable stats

    set cacheDir [::Zoom::FindCache]
    file delete -force -- $cacheDir
    set stats(current) "Usage: ? mb"
}
##+##########################################################################
#
# ::Options::GetDirSize -- walks zoom cache determining total usage
#
proc ::Options::GetDirSize {} {
    variable stats

    set cacheDir [::Zoom::FindCache]
    set stats(current) "Usage: ? mb"
    if {! [winfo exists .opt]} return
    foreach {total cnt} \
	[Data::GetFileUsage $cacheDir ::Options::GetDirSizeCallback] break

    if {$total < 1024} {
	set units "bytes"
    } elseif {$total < 1024*1024} {
	set total [expr {$total / 1024.0}]
	set units "kb"
    } elseif {$total < 1024*1024*1024} {
	set total [expr {$total / 1024.0 / 1024}]
	set units "mb"
    } else {
	set total [expr {$total / 1024.0 / 1024 / 1024}]
	set units "gb"
    }
    set stats(current) "Usage: [comma [Round1 $total]] $units"
    append stats(current) " in [comma $cnt] files"
    set stats(total) $total
    set stats(cnt) $cnt
}
##+##########################################################################
#
# ::Options::GetDirSizeCallback -- Provides feedback while getting directory size
#
proc ::Options::GetDirSizeCallback {cnt} {
    variable stats

    set stats(current) "([comma $cnt] files)"
}
##+##########################################################################
#
# ::Options::SetSuperuser -- called when su state toggles
#
proc super {} {set ::state(su) 1; ::Options::SetSuperuser}
proc unsuper {} {set ::state(su) 0; ::Options::SetSuperuser}
proc ::Options::SetSuperuser {} {
    set idx -1
    catch {set idx [.m index "Special"]}
    if {$::state(su)} {
	if {$idx != -1} return
	.m add cascade -menu .m.special -label "Special" -underline 0

	;# Keep Help menu last
	set h [.m index "Help"]
	if {$h != -1} {
	    .m delete $h
	    .m add cascade -menu .m.xhelp   -label "Help"  -underline 0
	}
    } else {
	if {$idx != -1} {
	    .m delete $idx
	}
    }
}
##+##########################################################################
#
# ::Options::NewQuality -- updates the zone(goodData) and road display
#
proc ::Options::NewQuality {n} {
    global state zone

    if {! $state(quality,$n) && $n > 0} {
	incr n -1
    }
    set zone(goodData) $n
    for {set i 0} {$i <= 4} {incr i} {
	set state(quality,$i) [expr {$i <= $::zone(goodData) ? 1 : 0}]
    }
    ::Route::ClearRoute
    .c delete roads
    ::Display::DrawRoads
}
##+##########################################################################
#
# ::Options::DoReg
#
# Associates .klm extension with this program. If we're running a
# freewrapped version, then we link to it, otherwise we link to wish.
#
#  o assoc .klm=KLIMBScript
#  o ftype KLIMBScript="C:\maps\klimb\klimb.exe" "%1"
#  o ftype KLIMBScript="c:\tcl\bin\wish83.exe" "C:\maps\klimb\klimb.tcl" "%1"
#
#  ? How about HKEY_LOCAL_MACHINE\SOFTWARE\Classes\.klm?
#
proc ::Options::DoReg {onoff} {
    global state argv0

    if {! [::Data::CanDo registry]} {
	WARN "Unable to access the registry"
	return
    }

    if {! $onoff} {
	catch {registry delete {HKEY_CLASSES_ROOT\.klm}}
	catch {registry delete {HKEY_CLASSES_ROOT\KLIMBScript}}
	DoInfo ".KLM file are no longer associated with $::state(progname)" \
	    "$::state(progname) Windows Associations"
	return
    }

    # First check that no one's using .klm already
    set n [catch {set old [registry get {HKEY_CLASSES_ROOT\.klm} {}]} err]
    if {! $n} {
	if {$old ne "KLIMBScript" && $old ne {}} {
	    set msg "Another application has claimed the \".klm\" extension: "
	    append msg "\"$old\""
	    WARN $msg
	    return
	}
    }

    # Set the ftype: different if we're freewrapped, starpacked or not
    if {$state(freewrap) || $state(starpack)} {
	set path [info nameofexecutable]
	set command "\"$path\" \"%1\" %*"
    } else {					;# Straight tcl, find wish.exe
	set path [info nameofexecutable]
	set script [file nativename [file normalize [file join [pwd] $argv0]]]
	set command "\"$path\" \"$script\" \"%1\" %*"
    }

    registry set {HKEY_CLASSES_ROOT\.klm} {} KLIMBScript
    registry set {HKEY_CLASSES_ROOT\KLIMBScript} {} "KLIMB Route File"
    registry set {HKEY_CLASSES_ROOT\KLIMBScript\shell\open\command} {} $command
    if {[file exists $state(iconfile)]} {
	registry set {HKEY_CLASSES_ROOT\KLIMBScript\DefaultIcon} {} \
	    "$state(iconfile),0"
    }
    DoInfo ".KLM file are now associated with $::state(progname)" \
	"$::state(progname) Windows Associations"
}
## EON OPTIONS
## BON NODELIST
##+##########################################################################
#
# ::NodeList::Create
#
# Puts up a listbox of all nodes. Double clicking a node highlights
# it on the map.
#
proc ::NodeList::Create {} {
    global nodes state lb2nodeid region poi photos

    catch {unset lb2nodeid}

    if {[winfo exists .nodes]} {
	.nodes.lb delete 0 end
    } else {
	::my::frame .nodes -borderwidth 3 -relief sunken
	# Don't pack it yet, let ::NodeList::Toggle do it

	::my::label .nodes.l -borderwidth 2 -relief sunken \
	    -text "$state(progname) Nodes" -anchor c
	::ttk::button .nodes.l.chi -image ::img::chi -command ::NodeList::Toggle
	::ttk::scrollbar .nodes.lb_y -command {.nodes.lb yview} -orient vertical
	listbox .nodes.lb -width 30 -yscroll {.nodes.lb_y set} \
	    -exportselection 0 -height 20 -highlightthickness 0
	#::Display::TileBGFix .nodes.lb
	bind .nodes.lb <Double-Button-1> ::Display::LocateNode

	pack .nodes.l -side top -fill x
	pack .nodes.lb_y -side right -fill y
	pack .nodes.lb -side left -fill both -expand 1
	place .nodes.l.chi -relx 1 -rely .5 -anchor e
    }

    set allnodes {}				;# sort-key name type id
    foreach nodeid [array names nodes] {
	foreach {name alt lat lon} $nodes($nodeid) break
	set name [string trim $name]
	if {$name eq ""} continue

	# Crop out of region nodes
	if {[::Display::ClipNode $lat $lon] == 0} continue

	lappend allnodes [list $name $name N $nodeid]
	if {[regexp {(.*)\s+&\s+(.*)} $name {} a b]} {
	    set name "$b & $a"
	    lappend allnodes [list $name $name N $nodeid]
	}
    }

    # Add in all the POI
    foreach pid [array names poi] {
	foreach {type name lat lon} $poi($pid) break
	if {$name eq ""} continue

	# Crop out of region poi
	if {[::Display::ClipNode $lat $lon] == 0} continue

	lappend allnodes [list "\x02$name" "POI: $name" P $pid]
    }

    # Add in all photos
    foreach phid [array names photos] {
	foreach {lat lon url sdesc ldesc} $photos($phid) break
	if {[::Display::ClipNode $lat $lon] == 0} continue
	lappend allnodes [list "\x01$sdesc" "PIC: $sdesc" Ph $phid]
    }

    # Add in all geocaches and possibly waypoints
    set m [expr {[llength [.c find withtag wpt]] > 0 ? "*,*" : "g,*"}]
    foreach wpt [array names ::GPS::wpts $m] {
	foreach {lat lon name desc url type} $::GPS::wpts($wpt) break
	if {[::Display::ClipNode $lat $lon] == 0} continue ;# Off screen
	set pre WPT
	if {$type eq "Geocache"} {set pre GEO}
	if {$type eq "Benchmark"} {set pre MRK}
	if {$desc eq "?"} { set desc $name }
	lappend allnodes [list "\x03$desc" "$pre: $desc" W $wpt]
    }

    set cnt 0
    set allnodes [lsort -index 0 -dictionary $allnodes]
    foreach node $allnodes {
	foreach {key name type id} $node break
	.nodes.lb insert end $name

	set lb2nodeid($cnt) $id		        ;# Map listbox row to nodeid
	lappend lb2nodeid(r,$id) $cnt		;# Reverse mapping
	incr cnt
    }

    # Delete the dummy widget put there for spacing reasons
    destroy .right.spacer
}
##+##########################################################################
#
# ::NodeList::Clear
#
# Removes all the entries in the node list
#
proc ::NodeList::Clear {} {
    if {[winfo exists .nodes]} {
	# Insert a dummy widget to keep the .right frame from changing
	# size when we delete the listbox elements
	destroy .right.spacer
	set w [winfo width .nodes]
	canvas .right.spacer -width $w -height 1 -bd 0 -highlightthickness 0
	pack .right.spacer -side bottom

	.nodes.lb delete 0 end
	.nodes.l config -text ""
    }
}
##+##########################################################################
#
# ::NodeList::Toggle
#
# Toggles the visibility of the nodelist window
#
proc ::NodeList::Toggle {} {
    global state

    if {![winfo exists .nodes.lb]} {		;# Doesn't exist
	::NodeList::Create
	set state(nodelist) 1
    } elseif {[winfo ismapped .nodes]} {	;# Visible on screen
	set state(nodelist) 0
	::Display::HighlightNode2 -1
    } else {					;# Not visible but exists
	set state(nodelist) 1
    }

    ::Display::ShowRightFrame
}
## EON NODELIST
## BON REGION
##+##########################################################################
#
# ::Region::LoadRegions
#
# Given a list of region files, it opens each one and then updates
# the Change Region cascading menu with the new region data.
#
proc ::Region::LoadRegions {flist} {
    set mags {}
    foreach rname $flist {
	set name "[file rootname [file tail $rname]]"
	INFO [format "loading region %-20s" $name]

	set name [::Region::ReadFile $rname]
	if {$name ne {}} {
	    lappend mags {*}$::region($name,mag)
	}
    }
    set ::zone(mags) [lsort -unique -dictionary $mags]
    ::Display::FillRegionMenu
}
##+##########################################################################
#
# ::Region::ReadFile
#
# Gets data about a region from a region file and puts it into our
# region and map arrays.
#
proc ::Region::ReadFile {fname} {
    global map region

    set emsg "Error reading region file \"[file tail $fname]\""
    set n [catch {set FIN [open $fname r]} err]
    if {$n} { WARN "$emsg\n$err"; return {} }

    catch {unset rmap}				;# Map filename and lat/lon
    catch {unset rmag}				;# Maps for each magnification
    catch {unset rmags}				;# Magnification for this region
    set rlabels	{}				;# Magnification labels
    set rname  ""				;# Region name
    set rnodes ""				;# Node files
    set rnodes2 {}				;# All the node files
    set rfirst ""				;# First map to display
    set rCenter ""				;# Node to center initially
    set errlat 0				;# Error in latitude
    set errlon 0				;# Error in longitude
    set rUTM 0					;# Uses UTM coordinates
    set rSlippy 0				;# Uses slippy coordinates
    set rMatrix {}				;# Uses matrix for position
    set rMatrixI {}				;# Uses matrix for reverse position

    while {1} {
	set n [gets $FIN line]
	if {$n == -1} break

	if {[string first "\#" $line] == 0} continue
	regsub {([^\\])\#.*} $line {\1} line	;# Remove comments
	regsub {\\\#} $line \# line		;# Unescape things
	set line [string trim $line]		;# And junk whitespace
	if {[string length $line] == 0} continue

	if {[regexp {^name=(.*)$} $line {} rname]} continue
	if {[regexp {^first=(.*)$} $line {} rfirst]} continue
	if {[regexp {^center=(.*)$} $line {} rCenter]} continue
	if {[regexp {^utm=(.*)$} $line {} rUTM]} continue
	if {[regexp {^slippy=(.*)$} $line {} rSlippy]} continue
	if {[regexp {^matrix=(.*)$} $line {} rMatrix]} continue
	if {[regexp {^matrixi=(.*)$} $line {} rMatrixI]} continue

	if {[regexp {^nodes=(.*)$} $line {} rnodes]} {
	    lappend rnodes2 $rnodes
	    continue
	}
	if {[regexp {^map=(...*?):(.*?):(.*)$} $line {} mname mag coords]} {
	    set rmap($mname) $coords
	    lappend rmag($mag) $mname
	    set rmags($mag) 1
	    continue
	}
	if {[regexp {^mag=(\d+):(.*)} $line {} mag lbl]} {
	    lappend rlabels $mag $lbl
	    continue
	}

	INFO "ignoring unknown line: '$line'"
    }
    close $FIN

    if {$rname	eq {}} {        WARN "$emsg : missing region name"; return {}}
    if {$rnodes eq {}} {        WARN "$emsg : missing node file"  ; return {}}
    if {![info exists rmags]} { WARN "$emsg : missing map data"   ; return {}}

    lappend region(names) $rname
    set region($rname,mag) [lsort -dictionary [array names rmags]]
    set region($rname,nodes) $rnodes2
    set region($rname,center) $rCenter
    set region($rname,UTM) $rUTM
    set region($rname,UTMZONE) [lindex $rmap([lindex [array names rmap] 0]) 2]
    if {! $rUTM} {
	set region($rname,UTMZONE) 0
    }
    set region($rname,slippy) $rSlippy

    # Insure we have either 0 or 2 transformation matrices
    if {($rMatrix ne {} && $rMatrixI eq {}) ||
	($rMatrix eq {} && $rMatrixI ne {})} {
	WARN "improper region: only one transformatio matrix specified."
	set region($rname,matrix) {}
	set region($rname,matrixI) {}
    } else {
	set region($rname,matrix) $rMatrix
	set region($rname,matrixI) $rMatrixI
    }

    foreach {mag lbl} $rlabels {
	set region($rname,$mag,label) $lbl
    }
    foreach mname [array names rmap] {
	set map($mname) $rmap($mname)
    }
    foreach mag $region($rname,mag) {
	set idx [lsearch $rmag($mag) $rfirst]
	if {$idx == -1} {set idx 0}
	set region($rname,$mag,maps) \
	    [concat [lrange $rmag($mag) $idx end] \
		 [lrange $rmag($mag) 0 [expr {$idx-1}]]]
	lappend region($mag) $rname
    }
    return $rname
}
##+##########################################################################
#
# ::Region::Lookup
#
# Given a region name, finds the proper name for it, allowing for
# unambiguous abbreviations and case-mismatching.
#
proc ::Region::Lookup {rname varName} {
    global region
    upvar 1 $varName why

    set why "Unknown region"
    if {$rname eq "(none)" || $rname eq ""} {return {} }
    set len [string length $rname]		;# For prefix matching

    set found {}
    foreach r [array names region *,mag] {
	foreach r2 [split $r ","] break
	if {[string equal -nocase $r2 $rname]} { return $r2 } ;# Exact match
	if {[string equal -nocase -length $len $r2 $rname]} { ;# Prefix match
	    if {$found ne {}} {			;# Ambiguous, so fail
		set why "Ambiguous region name"
		return ""
	    }
	    set found $r2
	}
    }
    return $found
}
##+##########################################################################
#
# ::Region::Select -- Public interface into graphically selecting a new region.
#
proc ::Region::Select {} {
    #if {! [::Region::Display]} return		;# Put up the map
    if {! [::Region::Dialog]} return		;# Put up the map
    ::Region::NewMag
    grab $::Region::S(W)
    tkwait window $::Region::S(W)
}
proc ::Region::NewMagTrace {var1 var2 op} {
    if {! [winfo exists $::Region::S(W)]} return
    if {! [winfo ismapped $::Region::S(W)]} return
    ::Region::NewMag
}
proc ::Region::NewMag {} {
    global state
    variable mag
    variable S

    ::Region::DrawRegions			;# Draw the regions
    $S(WBTN).select config -state disabled
    if {$state(mag) == $mag} {			;# Highlight current one
	foreach r $state(region,multi) {
	    ::Region::Click $r
	}
    }
}
##+##########################################################################
#
# ::Region::SelectDone
#
# Called when user has choosen which region he wants.
#
proc ::Region::SelectDone {} {
    variable rdata
    variable mag
    variable S

    # Figure out who is on
    set who {}
    foreach arr [array names rdata *,onoff] {
	if {$rdata($arr)} {
	    foreach rname [split $arr ","] break
	    lappend who $rname
	}
    }
    if {$who eq {}} return
    destroy $S(W)				;# Release the grab
    ::Region::GoRegion2 $who $mag
}
##+##########################################################################
#
# ::Region::Display
#
# Puts up the region select dialog
#
proc ::Region::Display {} {
    variable S
    global zone region

    set fname [::Init::LocateZoneFile $zone(zone,map) 1 0]
    if {! [file isfile $fname]} {
	WARN "Advanced region selection is not available for this zone"
	return 0
    }
    if {[lsearch [image names] ::img::region] == -1} {
	image create photo ::img::region
    }
    ::img::region config -file $fname

    set S(WB) $S(W)
    set S(WBTN) $S(W)
    destroy $S(W)
    toplevel $S(W)
    wm title $S(W) "$::state(progname) Region Selection"
    wm resizable $S(W) 0 0
    wm withdraw $S(W)
    ::my::frame $S(W).top -borderwidth 2 -relief ridge
    ::my::frame $S(W).right -borderwidth 0 -padding .1i
    ::my::frame $S(W).buttons -borderwidth 2 -relief ridge

    # Get map coordinates and image size so we can get the
    # scaling factors to place everything correctly on the canvas
    set zcoords $zone(zone,coords)
    if {[string match "utm:*" $zcoords]} {
	foreach {n0 e0 z0 . n1 e1 z1} [string range $zcoords 4 end] break
	foreach {lat0 lon0} [::Data::utm2ll $n0 $e0 $z0] break
	foreach {lat1 lon1} [::Data::utm2ll $n1 $e1 $z1] break

	set zcoords [list $lat0 0 0 $lon0 0 0 $lat1 0 0 $lon1 0 0]
    }
    foreach who {top left bottom right} {d m s} $zcoords {
	set latlon [lat2int $d $m $s]
	set $who $latlon
	set ::Display::coords(zone,$who) $latlon
    }

    set ::Display::coords(zone,h)  [expr {$bottom - $top}]
    set ::Display::coords(zone,w)  [expr {$right - $left}]
    set ::Display::coords(zone,iw) [image width ::img::region]
    set ::Display::coords(zone,ih) [image height ::img::region]

    set w [expr {$::Display::coords(zone,iw) + 2}]
    set h [expr {$::Display::coords(zone,ih) + 2}]
    canvas $S(W).c -width $w -height $h -highlightthickness 0 -bg black
    $S(W).c xview moveto 0 ; $S(W).c yview moveto 0
    $S(W).c create image 0 0 -image ::img::region -anchor nw -tag map
    $S(W).c config -scrollregion [$S(W).c bbox all]

    #::ttk::label $S(W).lb_t -text "Region List" -font boldFont
    ::ttk::labelframe $S(W).lb_t -text "Region List"
    ::ttk::frame $S(W).lb

    ::ttk::button $S(W).cancel -text Dismiss -command [list destroy $S(W)]
    ::ttk::checkbutton $S(W).multi -text "Multiple Regions" \
	-variable ::Region::multi -command {::Region::Click ""}
    if {! $zone(multiple)} {$S(W).multi config -state disabled}
    ::ttk::checkbutton $S(W).zoom -text "Zoom Out" -variable ::state(zoomout)
    ::ttk::button $S(W).select -text "Select Region" -command ::Region::SelectDone

    # Get all legal mags for this zone
    set mags {}
    foreach a [array names region *,mag] {
	set mags [concat $mags $region($a)]
    }
    set mags [lsort -unique -dictionary $mags]
    set ::Region::mag $::state(mag)
    if {[lsearch $mags $::Region::mag] == -1} {
	set ::Region::mag [lindex $mags 0]
    }
    eval ::Display::MyComboBox $S(W).mag ::Region::mag $mags
    if {[llength $mags] <= 1} { $S(W).mag config -state disabled }
    ::Data::UniqueTrace ::Region::mag ::Region::NewMagTrace

    grid $S(W).top -row 0 -sticky ew
    pack $S(W).c -in $S(W).top -side left -fill both -expand 1
    pack $S(W).right -in $S(W).top -side right -fill y

    pack $S(W).mag $S(W).multi $S(W).zoom -in $S(W).right -side top \
	-anchor w

    pack $S(W).lb_t -in $S(W).right -side top -fill x -pady {.5i 0}
    pack $S(W).lb -in $S(W).lb_t -side top -fill y

    grid $S(W).buttons -sticky ew
    pack $S(W).cancel $S(W).select -in $S(W).buttons -side right \
	-pady 15 -padx 10
    grid rowconfigure $S(W) 10 -weight 1
    grid columnconfigure $S(W) 10 -weight 1
    ::Display::CenterWindow $S(W)
    wm deiconify $S(W)

    return 1
}

proc ::Region::Dialog {} {
    global zone region
    variable S

    set fname [::Init::LocateZoneFile $zone(zone,map) 1 0]
    if {! [file isfile $fname]} {
	WARN "Advanced region selection is not available for this zone"
	return 0
    }
    if {[lsearch [image names] ::img::region] == -1} {
	image create photo ::img::region
    }
    ::img::region config -file $fname

    set S(WB) $S(W).body
    set S(WBTN) $S(W).buttons
    set title "$::state(progname) Region Select"

    ::Display::MakeDialogBox $S(W) $title $title [list ::img::icon klimb.gif] 0
    wm transient $S(W) .
    wm resizable $S(W) 1 1
            wm deiconify $S(W)

    ::ttk::button $S(WBTN).select -text "Select Region" \
	-command ::Region::SelectDone
    ::ttk::button $S(WBTN).cancel -text Dismiss -command [list destroy $S(W)]
    ::Display::GridChildren $S(WBTN) 1

    ::my::frame $S(WB).right -borderwidth 0 -padding .1i

    ::ttk::checkbutton $S(WB).multi -text "Multiple Regions" \
	-variable ::Region::multi -command {::Region::Click ""}
    if {! $zone(multiple)} {
	$S(WB).multi config -state disabled
	set ::Region::multi 0
    }
    ::ttk::checkbutton $S(WB).zoom -text "Zoom Out" -variable ::state(zoomout)

    # Get all legal mags for this zone
    set mags {}
    foreach a [array names region *,mag] {
	set mags [concat $mags $region($a)]
    }
    set mags [lsort -unique -dictionary $mags]
    set ::Region::mag $::state(mag)
    if {[lsearch $mags $::Region::mag] == -1} {
	set ::Region::mag [lindex $mags 0]
    }
    eval ::Display::MyComboBox $S(WB).mag ::Region::mag $mags
    if {[llength $mags] <= 1} { $S(WB).mag config -state disabled }
    ::Data::UniqueTrace ::Region::mag ::Region::NewMagTrace

    #::ttk::label $S(WB).lb_t -text "Region List" -font boldFont
    ::ttk::labelframe $S(WB).lb_t -text "Region List"
    ::ttk::frame $S(WB).lb ;# Filled in ::Region::DrawRegion



    # Get map coordinates and image size so we can get the
    # scaling factors to place everything correctly on the canvas
    set zcoords $zone(zone,coords)
    if {[string match "utm:*" $zcoords]} {
	foreach {n0 e0 z0 . n1 e1 z1} [string range $zcoords 4 end] break
	foreach {lat0 lon0} [::Data::utm2ll $n0 $e0 $z0] break
	foreach {lat1 lon1} [::Data::utm2ll $n1 $e1 $z1] break

	set zcoords [list $lat0 0 0 $lon0 0 0 $lat1 0 0 $lon1 0 0]
    }
    foreach who {top left bottom right} {d m s} $zcoords {
	set latlon [lat2int $d $m $s]
	set $who $latlon
	set ::Display::coords(zone,$who) $latlon
    }

    set ::Display::coords(zone,h)  [expr {$bottom - $top}]
    set ::Display::coords(zone,w)  [expr {$right - $left}]
    set ::Display::coords(zone,iw) [image width ::img::region]
    set ::Display::coords(zone,ih) [image height ::img::region]

    set w $::Display::coords(zone,iw)
    set h $::Display::coords(zone,ih)
    ::ttk::frame $S(WB).left -borderwidth 2 -relief solid
    canvas $S(WB).c -width $w -height $h -highlightthickness 0 \
	-bg [$S(W) cget -bg]
    $S(WB).c xview moveto 0 ; $S(WB).c yview moveto 0
    $S(WB).c create image 0 0 -image ::img::region -anchor nw -tag map
    $S(WB).c config -scrollregion [$S(WB).c bbox all]

    pack $S(WB).left -side left -fill both -expand 1
    pack $S(WB).c -in $S(WB).left -side left -fill both -expand 1
    pack $S(WB).right -side right -fill y
    pack $S(WB).mag $S(WB).multi $S(WB).zoom -in $S(WB).right -side top \
	-anchor w
    pack $S(WB).lb_t -in $S(WB).right -side top -fill x -pady {.5i 0}
    pack $S(WB).lb -in $S(WB).lb_t -side top -fill y

    ::Display::CenterWindow $S(W)
    wm deiconify $S(W)
    return 1
}

##+##########################################################################
#
# ::Region::DrawRegions
#
# Draws the regions on the display.
#
proc ::Region::DrawRegions {} {
    global region
    variable rdata
    variable mag
    variable S

    set colors [list blue yellow magenta green brown red]
    lappend colors deepskyblue darkgreen darkorchid hotpink
    lappend colors gray50 lightblue
    unset -nocomplain rdata

    $S(WB).c delete region
    eval destroy [winfo children $S(WB).lb]
    if {! [info exists region($mag)]} return

    set cnt -1
    foreach rname [::Region::SortRegions] {	;# All region in advanced mag
	if {$rname eq "all" && [llength $region($mag)] > 1} continue
	set rdata($rname,onoff) 0
	set tag r,$rname

	set color [lindex $colors 0]
	set colors [concat [lrange $colors 1 end] $color]
	set xy [::Region::Walk $rname]
	$S(WB).c delete $tag
	$S(WB).c create poly $xy -tag [list $tag region] \
          -width 5 -outline $color -fill $color -stipple gray12
	::Region::Stipple $tag $color

	$S(WB).c bind $tag <Button-1> [list ::Region::Click $rname]
	::Balloon::Create [list $S(WB).c $tag] region $rname \
						    "$rname Region" ""
	set w $S(WB).lb.[incr cnt]
	::ttk::checkbutton $w -text "$rname Region" \
          -command [list ::Region::Click $rname 1] \
          -variable ::Region::rdata($rname,onoff)
	pack $w -side top -fill x -padx {.125i 0}
    }
    $S(WB).c lower xstipple
}
##+##########################################################################
#
# ::Region::Stipple
#
# Mac can't seem to do stippling, so we'll fake it. Only the
# select regions will show stippling, the others will be hidden.
#
proc ::Region::Stipple {tag color} {
    variable S
    if {[::Data::CanDo stipple]} return

    $S(WB).c itemconfig $tag -stipple {} -fill {}

    # We're assuming the region is a rectangle
    foreach {x0 y0 x1 y1} [$S(WB).c bbox $tag] break
    incr x0 5; incr y0 5; incr x1 -5; incr y1 -5

    set step 5
    set tag [list xstipple ${tag}_stipple $tag]
    for {set x [expr {$x0 + $step}]} {$x < $x1} {incr x $step} {
	$S(WB).c create line $x $y0 $x $y1 -tag $tag -fill $color
    }
    for {set y [expr {$y0 + $step}]} {$y < $y1} {incr y $step} {
	$S(WB).c create line $x0 $y $x1 $y -tag $tag -fill $color
    }
}
##+##########################################################################
#
# ::Region::Revert -- undo all new nodes, roads and splits
#
# TODO: update ::Data::changed array
proc ::Region::Revert {} {
    global nodes roads splits state photos

    ::Route::ClearRoute
    ::Postit::Reset
    foreach nodeid [array names nodes X*]  { ::Edit::DeleteNode $nodeid 1 }
    foreach rid [array names roads Xr*] { ::Edit::DeleteRoad $rid 1 }
    foreach phid [array names photos X*] { ::Photo::Delete $phid }
    set state(nodes,next) 99
    set state(roads,next) 99

    if {! [info exists splits(undo)]} return

    foreach rid $splits(undo) {
	set roads($rid) $splits(u,$rid)
	set n [::Data::ProcessRoads $rid]	;# NB. also check for bad road
	if {$n} {
	    ::Display::DrawRoads $rid
	} else {
	    unset roads($rid)
	}
    }
    unset -nocomplain splits; array set splits {}
    ::Data::ClearModified
}
##+##########################################################################
#
# ::Region::Click
#
# Handles a button click in a window
#
proc ::Region::Click {who {checkButton 0}} {
    variable S
    variable rdata
    variable multi

    set tag r,$who
    array set stipple {on gray75 off gray12}
    if {! [::Data::CanDo stipple]} { array set stipple {on {} off {}}}

    # If no name given, then it means we're toggling multi modes. If
    # we're turning it off, we must turn off all but one region.
    if {$who eq ""} {
	if {$multi} return
	foreach who [lsort -dictionary -decr [array names rdata *,onoff]] {
	    if {$rdata($who) != 0} break
	}
	regsub {,onoff} $who {} who
	set rdata($who,onoff) [expr {! $rdata($who,onoff)}];# Negate toggling
    }

    # Remember what state WHO was in so we can toggle it
    # NB. checkbutton interface pre-toggles for us
    set newState $rdata($who,onoff)
    if {! $checkButton} { set newState [expr {! $newState}]}

    if {! $multi} {
	foreach arr [array names rdata *,onoff] { ;# Turn off everybody
	    set rdata($arr) 0
	}
	$S(WB).c itemconfig region -stipple $stipple(off)
	$S(WB).c lower xstipple
    }

    set rdata($who,onoff) $newState
    if {$rdata($who,onoff)} {
	$S(WB).c itemconfig $tag -stipple $stipple(on)
	$S(WB).c raise $tag
	$S(WB).c raise ${tag}_stipple
    } else {
	$S(WB).c itemconfig $tag -stipple $stipple(off)
	$S(WB).c lower ${tag}_stipple
    }

    # Do we need to enable the select button?
    foreach arr [array names rdata *,onoff] {
	if {$rdata($arr)} {
	    $::Region::S(WBTN).select config -state normal
	    break
	}
    }
}
##+##########################################################################
#
# ::Region::Merge
#
# Creates a new region $name by merging a bunch of regions together.
#
proc ::Region::Merge {name rnames} {
    global region

    set xnodes {}
    set xmags  {}
    array unset xmap
    foreach r $rnames {
	set xnodes [concat $xnodes $region($r,nodes)]
	set xmags  [concat $xmags  $region($r,mag)]
	foreach mag $region($r,mag) {
	    lappend xmap($mag)			;# Make sure it exists
	    set xmap($mag) [concat $xmap($mag) $region($r,$mag,maps)]
	}
    }
    set region($name,nodes) [lsort -unique -dictionary $xnodes]
    set region($name,mag)   [lsort -unique -dictionary $xmags]
    set region($name,UTM) $region($r,UTM)
    set region($name,UTMZONE) $region($r,UTMZONE)
    set region($name,center) $region($r,center)
    set region($name,slippy) $region($r,slippy)
    foreach mag $region($name,mag) {
	set region($name,$mag,maps) [::Data::lunique $xmap($mag)]
    }
    set region($name,matrix) {}
    set region($name,matrixI) {}
}
##+##########################################################################
#
# ::Region::Walk
#
# Walks a region and returns a coordinate list for the outline of it.
#
proc ::Region::Walk {rname} {
    variable rdata

    set n [::Region::GetCells $rname]
    if {$n == 0} {				;# Couldn't get cells
	set xy [::Region::GetBbox $rname]	;# Just do a bounding box
	return $xy
    }

    set dirs(e,left) n ; set dirs(e,right) s
    set dirs(s,left) e ; set dirs(s,right) w
    set dirs(w,left) s ; set dirs(w,right) n
    set dirs(n,left) w ; set dirs(n,right) e
    array set corner {e ne  s se  w sw	n nw}

    set coords {}

    foreach {toprow leftcol} $rdata(cells) break
    foreach {row col} $rdata(cells) {		;# Get topleft cell
	if {$row < $toprow} {
	    set toprow $row
	    set leftcol $col
	}
	if {$row == $toprow && $col < $leftcol} {
	    set leftcol $col
	}
    }

    foreach {row col dir} [list $toprow $leftcol e] break
    set coords [concat $coords [::Region::CellXY $row $col nw]]
    set cnt -1
    while {1} {
	if {$row == $toprow && $col == $leftcol && $dir eq "n"} {
	    #puts "done"
	    break
	}
	if {[incr cnt] > 10000} {		;# Sanity check
	    puts stderr "ERROR: infinite loop"
	    break
	}

	#puts -nonewline "$cnt: at ($row,$col) going $dir"
	# Can we turn left here?
	set left $dirs($dir,left)
	foreach {r2 c2 yesno} [::Region::CanMove $row $col $left] break
	if {$yesno} {
	    set dir $left
	    set row $r2
	    set col $c2
	    #puts " : turning left to $dir"
	    continue
	}

	# Can we go straight here?
	foreach {r2 c2 yesno} [::Region::CanMove $row $col $dir] break
	if {$yesno} {
	    set coords [concat $coords [::Region::CellXY $row $col $corner($dir)]]
	    #puts " : going straight to $dir"
	    set row $r2
	    set col $c2
	    continue
	}

	# We have to turn right here
	set coords [concat $coords [::Region::CellXY $row $col $corner($dir)]]
	set dir $dirs($dir,right)
	#puts " : turning right to $dir"

    }
    return $coords
}
##+##########################################################################
#
# ::Region::GetCells
#
# Puts all the cells in a region into an associative array.
#
proc ::Region::GetCells {rname} {
    global region
    variable rdata
    variable mag

    set rdata(cells) {}
    array unset rdata in,*
    foreach cell $region($rname,$::Region::mag,maps) {
	# NB. fails for Ohio w/ top & bot in map names
	if {[regexp -nocase {(?:sf\d_|ohio)(\d\d)(\d\d)\.gif} $cell {} row col]} {
	    regsub {^0} $row {} row
	    regsub {^0} $col {} col
	    lappend rdata(cells) $row $col
	    set rdata(in,$row,$col) 1
	    set rdata(map,$row,$col) $cell
	}
    }

    # Check for weird regions with no cell info
    if {[llength $rdata(cells)] == 0} { return 0 }
    return 1
}
##+##########################################################################
#
# ::Region::CellXY
#
# Returns the coordinates on the canvas of a given corner of a given cell
#
proc ::Region::CellXY {row col corner} {
    global map
    variable rdata

    set who $rdata(map,$row,$col)
    foreach where {top left bottom right} {l1 l2 l3} $map($who) {
	set $where [lat2int $l1 $l2 $l3]
    }
    switch -exact -- $corner {
	"nw" { foreach {x y} [list $top $left]     break }
	"ne" { foreach {x y} [list $top $right]    break }
	"sw" { foreach {x y} [list $bottom $left]  break }
	"se" { foreach {x y} [list $bottom $right] break }
    }
    set xy [::Display::pos2canvas zone $x $y]
    return $xy
}
##+##########################################################################
#
# ::Region::CanMove
#
# Returns true if we can walk from row,col in direction dir
#
proc ::Region::CanMove {row col dir} {
    variable rdata

    if {$dir eq "n"} {incr row -1}
    if {$dir eq "s"} {incr row 1}
    if {$dir eq "e"} {incr col 1}
    if {$dir eq "w"} {incr col -1}

    set yesno [info exists rdata(in,$row,$col)]
    return [list $row $col $yesno]
}
##+##########################################################################
#
# ::Region::IsSubset
#
# Checks to see if list newRegions is a subset of the current region.
# Returns: 0 is not
#	   1 is subset
#	   2 is equal
#
proc ::Region::IsSubset {newRegions} {
    global state

    foreach r $newRegions {
	set n [lsearch $state(region,multi) $r]
	if {$n == -1} { return 0 }
    }
    if {[llength $newRegions] == [llength $state(region,multi)]} {
	return 2
    }
    return 1
}
proc ::Region::SortRegions {} {
    set l [lsort -unique $::region($::Region::mag)]
    return [lsort -command ::Region::SortRegionCmd $l]
}
proc ::Region::SortRegionCmd {A B} {
    foreach {Alat Alon} [::Region::TopLeft $A] break
    foreach {Blat Blon} [::Region::TopLeft $B] break

    if {$Alat == $Blat} {
	if {$Alon >= $Blon} { return -1}
	return 1
    }
    if {$Alat >= $Blat} { return -1 }
    return 1
}
proc ::Region::TopLeft {rname} {
    global region map

    set maps $region($rname,$::Region::mag,maps)	;# List of maps
    set map1 [lindex $maps 0]

    # Get first map data
    if {$region($rname,UTM)} {
	foreach {a b} {top left bottom right} {n e z} $map($map1) {
	    foreach [list $a $b] [::Data::utm2ll $n $e $z] break
	}
    } else {
	foreach where {top left bottom right} {d m s} $map($map1) {
	    set $where [lat2int $d $m $s]
	}
    }

    # Check every map for bigger bbox
    foreach mapname $maps {
	if {$region($rname,UTM)} {
	    foreach {a b} {xtop xleft xbottom xright} {n e z} $map($mapname) {
		foreach [list $a $b] [::Data::utm2ll $n $e $z] break
	    }
	} else {
	    foreach who {xtop xleft xbottom xright} {d m s} $map($mapname) {
		set $who [lat2int $d $m $s]
	    }
	}
	if {$xtop    > $top}	{set top    $xtop}
	if {$xleft   > $left}	{set left   $xleft}
    }
    return [list $top $left]
}
proc ::Region::GetBbox {rname} {
    global region map

    set maps $region($rname,$::Region::mag,maps)	;# List of maps
    set map1 [lindex $maps 0]

    # Get first map data
    if {$region($rname,UTM)} {
	foreach {a b} {top left bottom right} {n e z} $map($map1) {
	    foreach [list $a $b] [::Data::utm2ll $n $e $z] break
	}
    } else {
	foreach where {top left bottom right} {d m s} $map($map1) {
	    set $where [lat2int $d $m $s]
	}
    }

    # Check every map for bigger bbox
    foreach mapname $maps {
	if {$region($rname,UTM)} {
	    foreach {a b} {xtop xleft xbottom xright} {n e z} $map($mapname) {
		foreach [list $a $b] [::Data::utm2ll $n $e $z] break
	    }
	} else {
	    foreach who {xtop xleft xbottom xright} {d m s} $map($mapname) {
		set $who [lat2int $d $m $s]
	    }
	}
	if {$xtop    > $top}	{set top    $xtop}
	if {$xbottom < $bottom} {set bottom $xbottom}
	if {$xleft   > $left}	{set left   $xleft}
	if {$xright  < $right}	{set right  $xright}
    }
    set xy {}
    foreach {a b} {top left top right bottom right bottom left} {
	set xy [concat $xy \
	    [::Display::pos2canvas zone [set $a] [set $b] $region(UTMZONE)]]
    }
    return $xy
}
##+##########################################################################
#
# ::Region::GoRegion
#
# Starts the process rolling, or restarts with new parameters
#
proc ::Region::GoRegion {{where {}} {mag {}}} {
    set ::where $where ; set ::mag $mag
    global state region

    # BUG: menu uses state(menu,region) but if we cancel we
    # must revert them
    #set ans [::Data::SaveData]
    #if {$ans eq "cancel"} return

    Busy 1					;# Doing a long operation
    if {! [winfo exists .splash]} {
	::Display::MakeProgressBar . "Loading new region" 1 1
    }

    set save_overview $state(overview)
    set state(overview) 0			;# Disable overview map

    if {$where eq {}} {				;# Zoom current region
	set where $state(region)
	set multi $state(region,multi)
	set mag $state(mag)
    } else {
	#set state(zoomout) 0
	set multi [list $where]
    }
    set state(region) $where
    set state(region,multi) $multi
    set state(region,pretty) [join $state(region,multi) "\n"]
    set state(region,pretty2) [join $state(region,multi) ", "]
    set state(mag) $mag
    set region(UTM) $region($where,UTM)
    set region(UTMZONE) $region($where,UTMZONE)
    set region(slippy) $region($where,slippy)
    set region(matrix) $region($where,matrix)
    set region(matrixI) $region($where,matrixI)

    ::Init::ReInit

    ::Region::Clear
    ::Route::ClearRoute
    ::Postit::Reset
    ::Overview::Clear
    ::NodeList::Clear
    ::GPS::Clear
    ::Info::CloseDialog
    ::RInfo::CloseDialog
    ::Atlas::Dismiss

    ::Display::BboxAll				;# Get overview info of region
    if {$save_overview} {
	::Overview::BBox	                ;# Show which region is selected
    }

    ::Display::DeleteAllMaps			;# Delete existing map images
    ::Display::Create
    ::Display::FirstMap				;# Determine our scaling factor
    ::Data::ReadMapData				;# Read in the raw data
    ::Display::DoProgressBar
    ::Display::DrawRoads			;# Draw the roads
    ::Display::DoProgressBar
    ::Display::DrawNodes			;# ...and the nodes
    ::Display::DrawPOI
    ::NodeList::Create				;# Draw node list window
    ::Route::DoButtons				;# Route::ClearRoute too early

    # Get the splash window to stay above the main window
    if {[winfo exists .splash] && ! $state(stealth)} {
	wm deiconify .
	raise .splash
	update idletasks
	wm transient .splash .
    }
    ::Display::CreateAllMaps
    set state(overview) $save_overview		;# Re-enable overmap
    ::Overview::Do				;# Show current view
    ::Legend::Create

    destroy .splash
    wm title . $state(title)

    update idletasks
    #.c config -scrollregion [.c bbox all]
    .c config -scrollregion [.c bbox maps]
    update
    ::Display::ToCenter $region($state(region),center)

    wm geom . [wm geom .]			;# Window won't grow w/ overview
    Busy 0
    focus -force .c
}
##+##########################################################################
#
# ::Region::Clear -- clears out data specific to current region
#
proc ::Region::Clear {} {
    global region

    foreach arr [list node road poi] {
	set region($arr,visible) {}
    }
}
##+##########################################################################
#
# ::Region::GoRegion2
#
# Handles loading multiple regions (by first merging them into one big
# region.
#
proc ::Region::GoRegion2 {who mag} {
    global state

    set len [llength $who]
    if {$len > 1} {				;# Multiple regions
	if {$len > 3} {
	    set txt "Are you sure you want to load $len regions?\n\n"
	    append txt "Opening too many regions can overload\n"
	    append txt "the computer and even cause it to crash"
	    if {! [::Edit::AreYouSure 0 "Select Region" [WRAPUNIX $txt]]} return
	}

	::Region::Merge Multiple $who		;# Yes, merge them into one
	::Region::GoRegion Multiple $mag
	set state(region,multi) $who
    } elseif {$who ne {}} {
	set who [lindex $who 0]
	if {1 || $state(mag) != $mag || $state(region) != $who} {
	    ::Region::GoRegion $who $mag
	}
    }
    set state(region,pretty) [join $state(region,multi) "\n"]
    set state(region,pretty2) [join $state(region,multi) ", "]
}
##+##########################################################################
#
# ::Region::GetNamesAtMag -- Returns a list of all region names available
# at a given mag
#
proc ::Region::GetNamesAtMag {mag} {
    global region

    if {$mag eq "*"} { return $region(names) }

    set who {}
    foreach rname $region(names) {
	if {[lsearch $region($rname,mag) $mag] > -1} {
	    lappend who $rname
	}
    }
    return $who
}
## EON REGION
## BON INFO
##+##########################################################################
#
# ::Info::Toggle -- Displays or destroys Region Info dialog
#
proc ::Info::Toggle {} {
    if {$::state(regionInfo)} {
	::Info::Dialog
    } else {
	::Info::CloseDialog
    }
}
##+##########################################################################
#
# ::Info::Dialog -- draws the region info dialog
#
proc ::Info::Dialog {} {

    ::Info::GetInfo				;# Fill in the values

    set W .info
    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Region Information"
    set title "$wtitle\n$::state(region,pretty)"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::bigInfo bigInfo.gif]
    wm protocol $W WM_DELETE_WINDOW ::Info::CloseDialog

    ::ttk::button $WBTN.dismiss -text Dismiss -command ::Info::CloseDialog
    ::Display::GridChildren $WBTN 0

    # Size data
    ::my::labelframe $WB.size -text "Size"
    ::my::label $WB.size.a0 -text "Width:" -anchor w -width 15
    ::my::label $WB.size.a1 -textvariable ::Info::extremes(width) -anchor c
    ::my::label $WB.size.b0 -text "Height:" -anchor w -width 15
    ::my::label $WB.size.b1 -textvariable ::Info::extremes(height) -anchor c
    ::my::label $WB.size.c0 -text "Area:" -anchor w -width 15
    ::my::label $WB.size.c1 -textvariable ::Info::extremes(area) -anchor c
    ::my::label $WB.size.d0 -text "Pixels:" -anchor w -width 15
    ::my::label $WB.size.d1 -textvariable ::Info::extremes(pixels) -anchor c
    grid columnconfigure $WB.size 0 -minsize 20
    grid columnconfigure $WB.size 2 -weight 1
    grid columnconfigure $WB.size 4 -minsize 5
    grid x $WB.size.a0 $WB.size.a1 -sticky ew
    grid x $WB.size.b0 $WB.size.b1 -sticky ew
    grid x $WB.size.c0 $WB.size.c1 -sticky ew
    grid x $WB.size.d0 $WB.size.d1 -sticky ew

    # Node info
    ::my::labelframe $WB.nodes -text "Nodes"
    ::my::label $WB.nodes.a0 -text "Count:" -anchor w -width 15
    ::my::label $WB.nodes.a1 -textvariable ::Info::extremes(ncnt) -anchor c
    ::my::label $WB.nodes.b0 -text "Highest:" -anchor w -width 15
    ::my::label $WB.nodes.b1 -textvariable ::Info::extremes(high,val) -anchor c
    ::ttk::button $WB.nodes.b2 -image ::img::star \
	-command [list ::Display::LocateNode $::Info::extremes(high,nid)]
    ::Balloon::Create $WB.nodes.b0 node $::Info::extremes(high,nid)
    ::Balloon::Create $WB.nodes.b1 node $::Info::extremes(high,nid)
    ::Balloon::Create $WB.nodes.b2 node $::Info::extremes(high,nid)
    ::my::label $WB.nodes.c0 -text "Lowest:" -anchor w -width 15
    ::my::label $WB.nodes.c1 -textvariable ::Info::extremes(low,val) -anchor c
    ::ttk::button $WB.nodes.c2 -image ::img::star \
	-command [list ::Display::LocateNode $::Info::extremes(low,nid)]
    ::Balloon::Create $WB.nodes.c0 node $::Info::extremes(low,nid)
    ::Balloon::Create $WB.nodes.c1 node $::Info::extremes(low,nid)
    ::Balloon::Create $WB.nodes.c2 node $::Info::extremes(low,nid)

    grid columnconfigure $WB.nodes 0 -minsize 20
    grid columnconfigure $WB.nodes 2 -weight 1
    grid columnconfigure $WB.nodes 4 -minsize 5
    grid x $WB.nodes.a0 $WB.nodes.a1 -sticky ew
    grid x $WB.nodes.b0 $WB.nodes.b1 $WB.nodes.b2 -sticky ew
    grid x $WB.nodes.c0 $WB.nodes.c1 $WB.nodes.c2 -sticky ew

    # Road info
    ::my::labelframe $WB.roads -text "Roads"
    ::my::label $WB.roads.a0 -text "Count:" -anchor w -width 15
    ::my::label $WB.roads.a1 -textvariable ::Info::extremes(rcnt) -anchor c
    ::my::label $WB.roads.b0 -text "Distance:" -anchor w -width 15
    ::my::label $WB.roads.b1 -textvariable ::Info::extremes(dist) -anchor c
    ::my::label $WB.roads.c0 -text "Longest:" -anchor w -width 15
    ::my::label $WB.roads.c1 -textvariable ::Info::extremes(long,val) -anchor c
    ::ttk::button $WB.roads.c2 -image ::img::star \
	-command [list ::Display::LocateRoad $::Info::extremes(long,rid)]
    ::Balloon::Create $WB.roads.c0 road $::Info::extremes(long,rid)
    ::Balloon::Create $WB.roads.c1 road $::Info::extremes(long,rid)
    ::Balloon::Create $WB.roads.c2 road $::Info::extremes(long,rid)
    ::my::label $WB.roads.d0 -text "Most Climbing:" -anchor w -width 15
    ::my::label $WB.roads.d1 -textvariable ::Info::extremes(climb,val) -anchor c
    ::ttk::button $WB.roads.d2 -image ::img::star \
	-command [list ::Display::LocateRoad $::Info::extremes(climb,rid)]
    ::Balloon::Create $WB.roads.d0 road $::Info::extremes(climb,rid)
    ::Balloon::Create $WB.roads.d1 road $::Info::extremes(climb,rid)
    ::Balloon::Create $WB.roads.d2 road $::Info::extremes(climb,rid)

    grid columnconfigure $WB.roads 0 -minsize 20
    grid columnconfigure $WB.roads 2 -weight 1
    grid columnconfigure $WB.roads 4 -minsize 5
    grid x $WB.roads.a0 $WB.roads.a1 -sticky ew
    grid x $WB.roads.b0 $WB.roads.b1 -sticky ew
    grid x $WB.roads.c0 $WB.roads.c1 $WB.roads.c2 -sticky ew
    grid x $WB.roads.d0 $WB.roads.d1 $WB.roads.d2 -sticky ew

    grid $WB.size -sticky ew
    grid $WB.nodes -sticky ew
    grid $WB.roads -sticky ew
    grid columnconfigure $WB 0 -weight 1

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Info::CloseDialog -- cleans up our Info dialog
#
proc ::Info::CloseDialog {} {
    destroy .info
    set ::state(regionInfo) 0
}
##+##########################################################################
#
# ::Info::GetInfo -- extracts information about the current region
#
proc ::Info::GetInfo {} {
    global region nodes roads
    variable extremes

    foreach who {ncnt low,val low,nid high,val high,nid \
		     rcnt dist climb,val climb,rid long,val long,rid \
		     short,val short,rid width height area pixels
    } {
	set extremes($who) "-"
    }

    # Get node extremes: count, high and low
    set extremes(ncnt) [llength $region(node,visible)]
    foreach nid $region(node,visible) {
	if {! [info exists nodes($nid)]} {
	    incr extremes(ncnt) -1
	    continue
	}

	set ele [lindex $nodes($nid) 1]
	if {[::BadMath::IsBad $ele]} continue
	if {$extremes(low,nid) eq "-"} {
	    set extremes(low,val) [set extremes(high,val) $ele]
	    set extremes(low,nid) [set extremes(high,nid) $nid]
	} else {
	    if {$ele < $extremes(low,val)} {
		set extremes(low,val) $ele
		set extremes(low,nid) $nid
	    } elseif {$ele > $extremes(high,val)} {
		set extremes(high,val) $ele
		set extremes(high,nid) $nid
	    }
	}
    }

    # Get road extremes: count, longest, distance and biggest climb
    set extremes(rcnt) [llength $region(road,visible)]
    set tdist 0

    foreach rid $region(road,visible) {
	if {! [info exists roads($rid)]} {
	    incr extremes(rcnt) -1
	    continue
	}
	foreach {. . climb dist desc . . . xy} $roads($rid) break
	set dist [::BadMath::Real $dist]
	if {$extremes(long,val) eq "-" || $dist > $extremes(long,val)} {
	    set extremes(long,val) $dist
	    set extremes(long,rid) $rid
	}
	if {$extremes(short,val) eq "-" || $dist < $extremes(short,val)} {
	    set extremes(short,val) $dist
	    set extremes(short,rid) $rid
	}

	set tdist [expr {$tdist + $dist}]

	foreach val [list $climb $desc] {
	    set val [::BadMath::Real $val]
	    if {$extremes(climb,rid) eq "-" || $val > $extremes(climb,val)} {
		set extremes(climb,rid) $rid
		set extremes(climb,val) $val
	    }
	}
    }
    set extremes(dist) [Round0 [::BadMath::Real $tdist]]

    # Get area info
    foreach {lat0 lon0 lat1 lon1} [::Display::GetBounds] break

    set extremes(width) [Round1 [::Data::Distance $lat0 $lon0 $lat0 $lon1]]
    set extremes(height) [Round1 [::Data::Distance $lat0 $lon0 $lat1 $lon0]]
    set extremes(area) [Round1 [expr {$extremes(width) * $extremes(height)}]]
    foreach {x0 y0 x1 y1} [.c bbox maps] break
    set extremes(pixels) "[comma [expr {$x1-$x0}]] x [comma [expr {$y1-$y0}]]"

    # Make everything look pretty
    set extremes(ncnt) [comma $extremes(ncnt)]
    set extremes(high,val) [::Data::Units $extremes(high,val) climb 1]
    set extremes(low,val) [::Data::Units $extremes(low,val) climb 1]

    set extremes(rcnt) [comma $extremes(rcnt)]
    set extremes(dist) [::Data::Units $extremes(dist) dist 1]
    set extremes(climb,val) [::Data::Units $extremes(climb,val) climb 1]
    set extremes(long,val) [::Data::Units $extremes(long,val) dist 1]

    set extremes(width) [::Data::Units $extremes(width) dist 1]
    set extremes(height) [::Data::Units $extremes(height) dist 1]
    set extremes(area) [::Data::Units $extremes(area) area 1]
}
## EON INFO
## BON OVERVIEW
##+##########################################################################
#
# ::Overview::Create
#
# Creates the overview window and sets some global variables
#
proc ::Overview::Create {} {
    global overview region zone state

    if {![info exists zone(overview1,map)]} {
	WARN "An overmap doesn't exist for this zone"
	set state(overview) 0
	return
    }

    catch {unset overview}
    ::my::frame .over -borderwidth 3 -relief sunken
    # Don't pack it here, let ::Overview::Toggle do it

    ::my::label .over.title -text "$state(progname) Overview" \
	-borderwidth 2 -relief sunken -anchor c
    ::ttk::button .over.title.chi -image ::img::chi -command ::Overview::Toggle
    pack .over.title -side top -fill x
    place .over.title.chi -relx 1 -rely .5 -anchor e

    set widgets {}
    for {set i 1} {[info exists zone(overview$i,map)]} {incr i} {
	set name overview$i
	::my::frame .over.f$i -borderwidth 2 -relief ridge
	set w .over.c$i
	if {[lsearch [image names] ::img::$name] == -1} {
	    set fname [::Init::LocateZoneFile $zone($name,map)]
	    image create photo ::img::$name -file $fname
	}
	set iw [image width ::img::$name]
	set ih [image height ::img::$name]

	canvas $w -width $iw -height $ih -takefocus 0 -highlightthickness 0
	::Display::TileBGFix $w
	set widgets [concat .over.f$i $widgets]
	pack $w -in .over.f$i -expand 1 -side top

	# Put in an overview map label
	set tvar ""
	if {$i == 1} {
	    ::my::label .over.l$i -textvariable state(region,pretty)
	    pack .over.l$i -in .over.f$i -expand 1 -side bottom
	} elseif {$i == 2} {
	    ::my::label .over.l$i -textvariable state(zone)
	    pack .over.l$i -in .over.f$i -expand 1 -side bottom
	}

	$w xview moveto 0; $w yview moveto 0
	$w create image 0 0 -image ::img::$name -anchor nw
	if {$i == 1} {
	    bind $w <Button-1> [list ::Overview::View %W %x %y down]
	    bind $w <B1-Motion> [list ::Overview::View %W %x %y move]
	    bind $w <ButtonRelease-1> [list ::Overview::View %W %x %y done]
	    #bind $w <Control-Button-3> [list PointMe %W %x %y] ;# debugging
	}

	foreach who {top left bottom right} {d m s} $zone($name,coords) {
	    set latlong [lat2int $d $m $s]
	    set $who $latlong
	    set ::Display::coords($name,$who) $latlong
	}

	set ::Display::coords($name,h) [expr {$bottom - $top}]
	set ::Display::coords($name,w) [expr {$right  - $left}]
	set ::Display::coords($name,iw) $iw
	set ::Display::coords($name,ih) $ih
	set ::Display::coords($name,xscale) \
	    [expr {$iw * 1.0 / $::Display::coords($name,w)}]
	set ::Display::coords($name,yscale) \
	    [expr {$ih * 1.0 / $::Display::coords($name,h)}]
    }
    if {[llength $widgets] > 0} {
	eval pack $widgets -side top
    }
}
##+##########################################################################
#
# ::Overview::Toggle
#
# Toggles the visibility of the overview window
#
proc ::Overview::Toggle {} {
    global state

    if {![winfo exists .over.c1]} {		;# Doesn't exist
	set state(overview) 1
	::Overview::Create
    } elseif {[winfo ismapped .over]} {		;# Visible on screen
	set state(overview) 0
    } else {					;# Not visible but exists
	set state(overview) 1
    }

    ::Display::ShowRightFrame
    if {$state(overview)} {
	::Overview::BBox			;# Draw the region box
	::Overview::Do				;# Draw the viewport
    }
}
##+##########################################################################
#
# ::Overview::Clear
#
# Clears all the boxes on the overview map. Needed when changing regions.
#
proc ::Overview::Clear {} {
    if {[winfo exists .over]} {
	.over.c1 delete box
    }
}
##+##########################################################################
#
# ::Overview::Do
#
# Puts up the overview viewport box based on the scroll bar percentages
#
proc ::Overview::Do {} {
    if {! $::state(overview)} return

    foreach {l r} [.sb_x get] break
    foreach {t b} [.sb_y get] break
    ::Overview::_Do $l $r $t $b v
    #::PrintPS::_Overview
}
##+##########################################################################
#
# ::Overview::_Do
#
# Draws the actual box on the overview image
#
proc ::Overview::_Do {l r t b what {who 1}} {
    global overview region

    set name overview$who
    set w .over.c$who
    set left $::Display::coords($name,left)
    set xscale $::Display::coords($name,xscale)
    set top $::Display::coords($name,top)
    set yscale $::Display::coords($name,yscale)

    foreach a {left width top height} {
	set zz($a) $::Display::coords(zone,$a)
    }
    set cl [expr {($zz(left) + $l * $zz(width) - $left) * $xscale}]
    set cr [expr {($zz(left) + $r * $zz(width) - $left) * $xscale}]

    set ct [expr {($zz(top) + $t * $zz(height) - $top) * $yscale}]
    set cb [expr {($zz(top) + $b * $zz(height) - $top) * $yscale}]

    $w delete $what
    $w create rect $cl $ct $cr $cb -outline blue \
	-tag [list $what box] -width 2
    if {[string equal $what "r"]} {
	$w itemconfig $what -outline black
    }
    set overview($what) [list $cl $ct $cr $cb]
}
##+##########################################################################
#
# ::Overview::BBox
#
# Draws the black bounding box for each overview map
#
proc ::Overview::BBox {} {
    global overview

    #if {$::region(UTM)} return
    set them zone
    for {set i 1} {[winfo exists .over.c$i]} {incr i} {
	set w .over.c$i
	set us overview$i

	foreach x {top left bottom right} {
	    set parent($x) $::Display::coords($them,$x)
	}
	set xy1 [::Display::pos2canvas $us $parent(top) $parent(left)]
	set xy2 [::Display::pos2canvas $us $parent(bottom) $parent(right)]
	set xy [concat $xy1 $xy2]
	set width [expr {$i == 1 ? 2 : 3}]
	$w create rect $xy -outline black -width $width -tag box
	if {$i == 1} {set overview(r) $xy}

	set them $us
    }
}
##+##########################################################################
#
# ::Overview::View
#
# Handles mousing in the overview window. It moves the view box to follow
# the cursor.
#
proc ::Overview::View {W x y what} {
    global overview

    if {$what eq "done"} {
	$W config -cursor {}
	focus .c
	return
    }
    if {![info exists overview(r)]} return
    if {![info exists overview(v)]} return

    focus $W
    $W config -cursor dotbox

    set px [$W canvasx $x]			;# Convert into canvas coords
    set py [$W canvasy $y]

    foreach {rl rt rr rb} $overview(r) break	;# Region box
    foreach {vl vt vr vb} $overview(v) break	;# View box
    set vw2 [expr {($vr - $vl) / 2.0}]		;# View width & height
    set vh2 [expr {($vb - $vt) / 2.0}]

    # Now constrain box to be w/i the region box
    set nl [expr {$px - $vw2}]
    set nr [expr {$px + $vw2}]
    if {$nl < $rl} {
	set d [expr {$nl - $rl}]
	set nl [expr {$nl - $d}]
	set nr [expr {$nr - $d}]
    } elseif {$nr > $rr} {
	set d [expr {$nr - $rr}]
	set nl [expr {$nl - $d}]
	set nr [expr {$nr - $d}]
    }

    set nt [expr {$py - $vh2}]
    set nb [expr {$py + $vh2}]

    if {$nt < $rt} {
	set d [expr {$nt - $rt}]
	set nt [expr {$nt - $d}]
	set nb [expr {$nb - $d}]
    } elseif {$nb > $rb} {
	set d [expr {$nb - $rb}]
	set nt [expr {$nt - $d}]
	set nb [expr {$nb - $d}]
    }

    # Create the new view box
    $W delete v
    $W create rectangle $nl $nt $nr $nb -outline blue \
	-tag [list v box] -width 2
    #set overview(v2) [list $nl $nt $nr $nb]
    ::Overview::Link $nl $nt
}
##+##########################################################################
#
# ::Overview::Link
#
# Scrolls the main canvas so that it matches the overview view box
#
proc ::Overview::Link {vl vt} {
    global overview

    foreach {rl rt rr rb} $overview(r) break
    set rw [expr {double($rr - $rl)}]
    set rh [expr {double($rb - $rt)}]

    set l [expr { ($vl - $rl) / $rw}]
    set t [expr { ($vt - $rt) / $rh}]

    .c yview moveto $t
    .c xview moveto $l
}
## EON OVERVIEW
## BON LEGEND
##+##########################################################################
#
# ::Legend::Toggle -- toggles visibility of the legend window
#
proc ::Legend::Toggle {} {
    global state

    if {![winfo exists .legend]} {		;# Doesn't exist
	set state(legend) 1
	::Legend::Create
    } elseif {[winfo ismapped .legend]} {	;# Visible on screen
	set state(legend) 0
    } else {					;# Not visible but exists
	set state(legend) 1
    }

    ::Display::ShowRightFrame
}
##+##########################################################################
#
# ::Legend::Create -- creates the legend window
#
proc ::Legend::Create {} {
    global state trails

    if {[winfo exists .legend]} {
	foreach w [winfo child .legend] {destroy $w}
    } else {
	::my::frame .legend -borderwidth 3 -relief sunken
    }
    ::my::label .legend.title -text "$state(progname) Legend" \
	-borderwidth 2 -relief sunken -anchor c
    ::ttk::button .legend.title.chi -image ::img::chi -command ::Legend::Toggle
    grid .legend.title - - - -row 0 -sticky ew
    place .legend.title.chi -relx 1 -rely .5 -anchor e

    set row 1
    foreach type [lsort -dictionary [array names trails user,*]] {
	set type [lindex [split $type ","] end]
	set w .legend.cu$type
	canvas $w -bd 0 -highlightthickness 0 -width 40 -height 0
	::Display::TileBGFix $w
	$w create line 10 10 1000 10 -tag line \
	    -fill $state(r,0,$type,color) -width $state(r,0,$type,width)
	::my::label .legend.lu$type -text " $trails(user,$type)" -anchor w
	grid x $w .legend.lu$type -sticky news -row $row
	incr row
    }
    # Display bar if there were user trails
    if {$row > 1} {
	set w .legend.bar$row
	canvas $w -height 20 -width 0 -bd 0 -highlightthickness 0
	::Display::TileBGFix $w
	$w create line 0 10 1000 10 -width 3
	grid x $w - -sticky news -row $row -padx 10
	incr row
    }
    for {set i 0} {[info exists trails(type,$i)]} {incr i} {
	set w .legend.c$i
	canvas $w -bd 0 -highlightthickness 0 -width 40 -height 0
	::Display::TileBGFix $w
	$w create line 10 10 1000 10 -tag line \
	    -fill $state(r,0,$i,color) -width $state(r,0,$i,width)
	::my::label .legend.l$i -text " $trails(type,$i)" -anchor w
	grid x $w .legend.l$i -sticky news -row $row
	incr row
    }

    # Display the scale
    set w .legend.cscale
    set width [expr {[winfo reqwidth .legend.c0] + [winfo reqwidth .legend.l0]}]
    ::Display::DoScale $w $width
    grid x $w - -sticky news -padx 10
    ::Display::ShowRightFrame
    grid columnconfigure .legend {0 3} -weight 1 ;# Allow title to expand
}
##+##########################################################################
#
# ::Legend::Update -- updates the legend window if it exists
#
proc ::Legend::Update {} {
    if {[winfo exists .legend]} ::Legend::Create
}
## EON LEGEND
## BON EDIT
##+##########################################################################
#
# ::Edit::CreateNode
#
# Fills in the nnode array to create the Create Node dialog box
#
proc ::Edit::CreateNode {{nid ""} {latlon {}}} {
    global nnode nodes

    catch {unset nnode}
    set labels {Description Elevation "USGS Elevation"}
    set values {"" <unknown> "?"}
    set types  {0 1 8}				;# 1 number, 2 read-only, 4 su

    if {$nid eq {}} {				;# Create a new node
	if {$latlon eq {}} {
	    # Convert click location into latitude and longitude
	    set ll [eval ::Display::canvas2pos $::state(popup)]
	    foreach {lat lon cx cy dlat dlon} $ll break
	    foreach {lat_d lat_m lat_s} $lat {lon_d lon_m lon_s} $lon break
	} else {
	    foreach {lat lon} $latlon break
	    foreach {lat_d lat_m lat_s} [int2lat $lat] break
	    foreach {lon_d lon_m lon_s} [int2lat $lon] break
	    foreach {cx cy} [::Display::pos2canvas root $lat $lon] break
	    set ::state(popup,p) {}
	}
	# Display a marker on map where node will go
	.c delete cross
	foreach {x1 y1 x2 y2} [::Display::MakeBox [list $cx $cy] 8] break
	.c create line $x1 $y1 $x2 $y2 -tag cross -fill red -width 5
	.c create line $x2 $y1 $x1 $y2 -tag cross -fill red -width 5

	set nnode(wtitle) "$::state(progname) Create New Node"
	set nnode(title)  "Create New Node\n"
	set values [list "My new node $::state(nodes,next)" <unknown> "?"]
    } else {					;# Edit an existing node
	if {$nid eq "popup"} {
	    set nid $::state(popup,who)
	}
	foreach {name elevation lat lon cxy usgs} $nodes($nid) break
	set usgs [expr {[string is double -strict $usgs] ? $usgs : "?"}]
	set usgs [comma [::Data::Convert $usgs climb]]
	set values [list $name [::Data::Convert $elevation climb] $usgs]

	foreach {lat_d lat_m lat_s} [int2lat $lat] break
	foreach {lon_d lon_m lon_s} [int2lat $lon] break

	if {! $::state(su) && ! [string match "X*" $nid]} {
	    set types  {2 3 8}
	}
	set nnode(wtitle) "$::state(progname) Node Info"
	set nnode(title)  "Info for node $nid\n"

	if {! [::Display::ClipNode2 $nid]} {	;# Out of this region
	    lappend labels "Region"
	    set where [::Data::WhichRegion $nid]
	    if {$where eq {}} {
		lappend values "unknown"
		lappend types 16
	    } else {
		set tmp {}
		foreach {rname mag} [::Data::Flatten $where] {
		    lappend tmp $rname
		}
		lappend values [join $tmp \n]
		lappend types 16
	    }
	}

	set ::nid $nid
    }
    append nnode(title) "Latitude  $lat_d\xB0 $lat_m' $lat_s\x22N\n"
    append nnode(title) "Longitude $lon_d\xB0 $lon_m' $lon_s\x22W"
    set nnode(latlon) [list $lat_d $lat_m $lat_s $lon_d $lon_m $lon_s]

    for {set i 0} {$i < [llength $labels]} {incr i} {
	set nnode(l$i) [lindex $labels $i]
	set nnode(e$i) [lindex $values $i]
	set nnode(t$i) [lindex $types  $i]
    }
    ::Edit::NewDlg Node [llength $labels] $nid ;# Create the dialog
}
##+##########################################################################
#
# ::Edit::CreateNodeLatLon -- creates a node at an exact lat/lon
#
proc ::Edit::CreateNodeLatLon {lat lon} {
    ::Edit::CreateNode {} [list $lat $lon]
}
##+##########################################################################
#
# ::Edit::CreateRoad
#
# Fills in the nnode array to create the Create Road dialog box
#
proc ::Edit::CreateRoad {{rid {}} {nid1 {}} {nid2 {}} {rname {}}} {
    global nnode roads route NR state nodes

    catch {unset nnode}

    set labels {"Road Name" "Starting Node" "Ending Node" Distance \
		    "Climb from Start" "Climb from End" Comment Type}
    if {$rname eq {}} {
	set rname "My new road"
	if {$state(su)} {
	    catch {set rname [lindex $nodes($::nid) 0]}
	}
    }
    if {$nid1 eq {} && $nid2 eq {} && $route(tail) != -1} {
	set nid1 [::Edit::PrettyNode $route(tail)]
    }
    if {$nid1 eq {} && $nid2 eq {} && [info exists ::nid]} {
	set nid2 [::Edit::PrettyNode $::nid]
    }
    set values [list $rname $nid1 $nid2 <unknown> <unknown> <unknown> "" 4]
    if {$state(su)} {
	set values [lreplace $values 7 7 0]
    }
    set types {0 0 0 1 1 1 0 4}

    if {$rid eq {}} {
	set nnode(wtitle) "$::state(progname) Create New Road"
	set nnode(title)  "Create New Road"
    } else {
	if {[string equal $rid "popup"]} {
	    set rid $state(popup,who)
	}
	set nnode(wtitle) "$::state(progname) Road Info"
	set nnode(title)  "Info for road $rid"
	#if {$state(su) && [lindex $roads($rid) 11] eq "zoom"} {append nnode(title) "*"}
	append nnode(title) [::RideLog::Info range $rid]
	set ::rid $rid

	# Put in the real values from roads() and nodesroads()
	# id1 is ALWAYS north node
	foreach {id1 id2 north distance south type name comment} \
	    $roads($rid) break
	set distance [::Data::Convert $distance dist]
	set climb [::Data::Convert $south climb]
	set desc [::Data::Convert $north climb]

	set values [list $name $id1 $id2 $distance $climb $desc $comment $type]
	if {$state(su) || [string match "X*" $rid]} {
	    set types {0 2 2 1 1 1 0 4}
	} else {
	    set types {2 2 2 3 3 3 2 6}
	}
    }

    for {set i 0} {$i < 8} {incr i} {
	set nnode(l$i) [lindex $labels $i]
	set nnode(e$i) [lindex $values $i]
	set nnode(t$i) [lindex $types  $i]
    }
    if {$state(su)} { set nnode(t7) 4}
    ::Edit::NewDlg Road 8 $rid			;# Create the dialog
}
##+##########################################################################
#
# ::Edit::CreateSplit
#
# Fills in the nnode array to create the Split Road dialog box
# * state(what), state(who)
#   => state(popup) to compute lat/lon and cx,cy
#      OR state(popup,latlon) if called from zoom
#
proc ::Edit::CreateSplit {} {
    global state nodes roads
    global nnode

    unset -nocomplain nnode
    set what $state(popup,what)

    if {$what ne "road" && $what ne "zoom"} return
    set rid $state(popup,who)
    foreach {r1 r2 . . . . rname} $roads($rid) break
    set r1x $r1
    regsub {^n} $r1x {} r1x
    regsub {\.[0-9]*} $r1x {} r1x

    # Convert click location into latitude and longitude
    if {$what eq "road"} {
	set ll [eval ::Display::canvas2pos $state(popup)]
	foreach {lat lon cx cy} $ll break
	set degrees [concat $lat $lon]
    } else {					;# Zoom interface
	foreach {lat lon} $state(popup,latlon) break
	foreach {cx cy} [::Display::pos2canvas root $lat $lon] break
	set degrees [concat [int2lat $lat] [int2lat $lon]]
    }

    # Display a marker on map where node will go
    .c delete cross
    foreach {x1 y1 x2 y2} [::Display::MakeBox [list $cx $cy] 8] break
    .c create line $x1 $y1 $x2 $y2 -tag cross -fill red -width 5
    .c create line $x2 $y1 $x1 $y2 -tag cross -fill red -width 5

    foreach {plat plon} [eval ::Display::PrettyLat $degrees] break
    set nnode(wtitle) "$::state(progname) Split Road"
    set nnode(title) "Split Road $rid\n"
    append nnode(title) "Latitude  $plat\n"
    append nnode(title) "Longitude $plon"
    set nnode(latlon) $degrees

    set title "My new node $::state(nodes,next) on $rname"
    array set nnode [list \
	l0 "Node Description" e0 $title t0 0 \
	l1 "Elevation" e1 "<unknown>" t1 1 \
	l2 "USGS Elevation" e2 "?" t2 8 \
	l3 "Distance from node $r1x" e3 "<unknown>" t3 1 \
	l4 "Climbing from node $r1x" e4 "<unknown>" t4 1 \
	l5 "Descending from node $r1x" e5 "<unknown>" t5 1 \
    ]
    ::Edit::NewDlg Split 6 $rid			;# Create the dialog
}

proc ::Edit::CreatePhoto {{phid ""}} {
    global nnode photos

    unset -nocomplain nnode
    set labels {URL "Short Description" "Long Description"}
    set values {"" "" ""}
    set types  {0 0 0}

    if {$phid eq {}} {				;# Create a new photo
	# Convert click location into latitude and longitude
	set ll [eval ::Display::canvas2pos $::state(popup)]
	foreach {lat lon cx cy} $ll break
	foreach {lat_d lat_m lat_s} $lat {lon_d lon_m lon_s} $lon break

	# Display a marker on map where node will go
	.c delete cross
	foreach {x1 y1 x2 y2} [::Display::MakeBox [list $cx $cy] 8] break
	.c create line $x1 $y1 $x2 $y2 -tag cross -fill red -width 5
	.c create line $x2 $y1 $x1 $y2 -tag cross -fill red -width 5

	set nnode(wtitle) "$::state(progname) Create New Photo"
	set nnode(title)  "Create New Photo\n"
    } else {					;# Edit an existing photo
	if {! $::state(su) && ! [string match "X*" $phid]} {
	    set types  {2 2 2}
	}
	foreach {lat lon url sdesc ldesc} $photos($phid) break
	foreach {lat_d lat_m lat_s} [int2lat $lat] break
	foreach {lon_d lon_m lon_s} [int2lat $lon] break
	set values [list $url $sdesc $ldesc]

	set nnode(wtitle) "$::state(progname) Update Photo"
	set nnode(title)  "Update Photo\n"
	set ::phid $phid
    }
    append nnode(title) "Latitude  $lat_d\xB0 $lat_m' $lat_s\x22N\n"
    append nnode(title) "Longitude $lon_d\xB0 $lon_m' $lon_s\x22W"
    set nnode(latlon) [list $lat_d $lat_m $lat_s $lon_d $lon_m $lon_s]

    for {set i 0} {$i < [llength $labels]} {incr i} {
	set nnode(l$i) [lindex $labels $i]
	set nnode(e$i) [lindex $values $i]
	set nnode(t$i) [lindex $types  $i]
    }

    ::Edit::NewDlg Photo [llength $labels] $phid ;# Create the dialog
}
##+##########################################################################
#
# ::Edit::NewDlg
#
# Creates the ::Edit::CreateNode, ::Edit::CreateRoad,
# ::Edit::CreateSplit, ::Edit::AddRoutePoint
#
# Type bits: 1 => numeric
#            2 => read-only
#            4 => Road type optionMenu
#            8 => USGS button
#           16 => label
#
#
proc ::Edit::NewDlg {who rows id} {
    global nnode state trails

    set normals 0				;# How many non-disabled entries
    set nnode(who) $who
    set node [string equal $who "Node"]
    set zoom [string equal $who "Route Point"]
    set canvas [expr {$zoom ? ".zoom.c" : ".c"}]

    set W .nnode
    set WB $W.body
    set WBTN $W.buttons
    set WC $W.c
    ::Display::MakeDialogBox $W $nnode(wtitle) $nnode(title) ""
    wm transient $W [winfo parent $canvas]
    wm protocol $W WM_DELETE_WINDOW "$canvas delete cross ; destroy $W"

    set focus ""
    set w [expr {$node ? 20 : 20}]

    for {set i 0} {$i < $rows} {incr i} {
	::my::label $WB.l$i -textvariable nnode(l$i) -anchor e
	if {$nnode(t$i) & 4} {
	    set types {}
	    foreach type [lsort -dictionary [array names trails type,*]] {
		lappend types $trails($type)
	    }
	    if {[info exists trails(type,$nnode(e$i))]} {
		set nnode(e$i) $trails(type,$nnode(e$i))
	    } elseif {[info exists trails(user,$nnode(e$i))]} {
		set nnode(e$i) $trails(user,$nnode(e$i))
	    }
	    eval tk_optionMenu $WB.e$i nnode(e$i) $types
	    $WB.e$i config -highlightthickness 0 -relief sunken
	} elseif {$nnode(t$i) & 8} {
	    ::my::frame $WB.e$i -relief sunken -borderwidth 2
	    ::my::label $WB.e$i.v -textvariable nnode(e$i) -justify center \
		-width $w  -borderwidth 0 -anchor c
	    $WB.e$i.v config -state readonly
	    ::ttk::button $WB.e$i.star -image ::img::star -takefocus 0 \
		-command [list ::Edit::DoUSGS $W $nnode(latlon) $i]
	    bind $WB.e$i.star <Button-3> \
		[list ::Edit::FixElevation $W $nnode(latlon)]
	    pack $WB.e$i.v -side left -fill both -expand 1
	    pack $WB.e$i.star -side right

	    set txt "Query USGS for elevation"
	    ::Balloon::Create $WB.e$i.star usgs btn $txt $txt
	} elseif {$nnode(t$i) & 16} {
	    ::my::label $WB.e$i -textvariable nnode(e$i) -justify center \
		-width $w -relief sunken -anchor c
	} else {
	    ::my::entry $WB.e$i -textvariable nnode(e$i) -justify center -width $w
	}
	grid $WB.l$i $WB.e$i -sticky ew


	if {$nnode(t$i) & 2} {			;# Is it read-only??
	    $WB.e$i config -state disabled
	} elseif {($nnode(t$i) & (8+16)) == 0}  {
	    incr normals
	    if {$focus eq ""} { set focus $WB.e$i }
	}

	if {[expr {$nnode(t$i) & 1}]} {		;# Is it a number
	    $WB.e$i config -validate key \
		-validatecommand [list ::Edit::NumberValidate %W %P]
	}

	bind $WB.e$i <Key-Return> [bind all <Tab>]
    }
    ::my::frame $WB.btn

    if {$who eq "photo"} {
	::Display::MakeImage ::img::camera camera.gif
	$WC create image 50 50 -image ::img::camera
    } else {
	$WC create line 20 80 50 20 -fill blue -width 3
	$WC create line 50 20 80 80 -fill blue -width 3 -dash 1
	$WC create oval 10 70 30 90 -fill yellow
	$WC create oval 40 10 60 30 -fill yellow
	$WC create rect 70 70 90 90 -fill yellow -dash 1
    }

    # Doit, delete, zoom, dismiss
    #   DOIT always calls ::Edit::Add${who}
    set xwho [string map {" " ""} $who]
    set wstate [expr {$normals > 0 ? "normal" : "disabled"}]
    ::ttk::button $W.doit -text "Update $who" -state $wstate \
	-command [list ::Edit::Add$xwho $id]
    bind $W.doit <3> [list ::Edit::Add$xwho $id zoom]
    ::ttk::button $W.delete -text "Delete $who" -state $wstate \
	-command [list ::Edit::Delete$who $id]
    ::ttk::button $WBTN.zoom -text "Zoom" \
	-command "destroy $W ; ::Zoom::Go $who $id"
    ::ttk::button $WBTN.view -text "Google Maps" \
	-command "destroy $W ; ::Zoom::Google $who $id"
    ::ttk::button $WBTN.dismiss -text "Dismiss" \
	-command "destroy $W ; $canvas delete cross"
    eval pack $W.doit $W.delete [winfo children $WBTN] -in $WBTN \
	-side left -expand 1 -pady 10 -padx 2

    if {($who ne "Node" && $who ne "Road") || $id eq ""} {
	pack forget $WBTN.view
    }
    if {$who eq "Route Point"} {
	$W.doit config -text "Add Elevation"
	pack forget $W.delete
	pack forget $WBTN.zoom
    } elseif {$who eq "Split"} {
	$W.doit config -text "Split Road"
	pack forget $W.delete
	pack forget $WBTN.zoom
    } elseif {$id eq ""} {			;# Adding new node/road
	$W.doit config -text "Add $who"
	pack forget $W.delete
	pack forget $WBTN.zoom
    } elseif {$who eq "Photo"} {
	pack forget $WBTN.zoom
    } else {
	grid $WB.btn -columnspan 2 -sticky ew -row 100
	pack $W.doit $W.delete -in $WB.btn -expand 1
    }

    if {$focus ne ""} { focus $focus ; catch {::tk::TabToWindow $focus }}

    bind $W.doit       <Key-Return> [list $W.doit invoke]
    bind $W.delete     <Key-Return> [bind all <Tab>]
    bind $WBTN.zoom    <Key-Return> [bind all <Tab>]
    bind $WBTN.dismiss <Key-Return> [bind all <Tab>]

    # Figure out where to put the window
    if {$id ne ""} {
	set w .
	if {[winfo exists .sanity]} {
	    set w .sanity
	    wm transient $W .sanity
	}
	::Display::CenterWindow $W $w
    } else {
	if {$::state(popup,p) eq {}} {
	    ::Display::CenterWindow $W .
	} else {
	    update
	    set w [winfo reqwidth $W] ; set h [winfo reqheight $W]
	    foreach {px py} $::state(popup,p) break

	    set nx [expr {$px - $w / 2}]
	    if {$nx < 0} {set nx 0}
	    set ny [expr {$py - $h - 40}]
	    if {$ny < 0} {set ny [expr {$py + 10}]}

	    wm geom $W "+$nx+$ny"
	}
    }
    wm deiconify $W
}
##+##########################################################################
#
# ::Edit::USGSCallback -- called when the USGS elevation query finishes
#
;#proc ::Edit::USGSCallback {elev} {
;#    global nnode
;#
;#    # First convert to external units
;#    set elev [::Data::Convert $elev climb]
;#
;#    set row 2
;#    if {$nnode(who) eq "Route Point"} { incr row -1}
;#
;#    if {! [string is double -strict $elev]} {
;#	set nnode(e$row) $elev
;#	return
;#    }
;#
;#    set nnode(e$row) [::Data::Label $elev climb 3]
;#    incr row -1
;#
;#    # See if we should update KLIMB's elevation
;#    if {[string is double -strict $nnode(e$row)]} return
;#    if {$nnode(t$row) & 2} return
;#    set nnode(e$row) $elev
;#}
proc ::Edit::DoUSGS {W latlon row} {
    global nnode

    set elev [::USGS::Dialog $W $latlon]
    set elev [::Data::Convert $elev climb]	;# To external units

    if {! [string is double -strict $elev]} {
	set nnode(e$row) $elev
	return
    }
    set nnode(e$row) [::Data::Label $elev climb 3]

    # See if we should update KLIMB's elevation
    incr row -1
    if {[string is double -strict $nnode(e$row)]} return
    if {$nnode(t$row) & 2 || ! ($nnode(t$row) & 1)} return ;# Writable number
    set nnode(e$row) $elev
}
proc ::Edit::FixElevation {W latlon} {
    global nnode

    set elev [::USGS::Dialog $W $latlon]
    set elev [::Data::Convert $elev climb]	;# To external units

    set row [expr {$nnode(who) eq "Route Point" ? 1 : 2}]
    if {! [string is double -strict $elev]} {
	set nnode(e$row) $elev
	return
    }

    set nnode(e$row) [::Data::Label $elev climb 3]
    incr row -1

    # Update KLIMB's elevation
    set nnode(e$row) [Round10 $elev]
}
##+##########################################################################
#
# ::Edit::NumberValidate
#
# Entry validation command to only allow numbers
#
proc ::Edit::NumberValidate {w str} {
    regsub -all {,} $str {} str
    regsub -all {\?} $str {} str
    regsub -all {\+} $str {} str
    if {$str eq "."} { return 1 }
    if {[string is double $str]} { return 1}
    return 0
}
##+##########################################################################
#
# ::Edit::GetNextID -- Generates a new id for user nodes and roads
#
proc ::Edit::GetNextID {prefix {preprefix ""}} {
    global nodes roads state splits

    set type "nodes"
    if {$prefix eq "r"} {set type "roads"}
    if {$prefix eq "a"} {set type "postit"}
    if {$prefix eq "c"} {set type "photos" }
    if {! [info exists state($type,next)]} {
	set state($type,next) 1
	if {$type eq "roads" || $type eq "nodes"} {
	    set state($type,next) 99
	}
    }
    if {$preprefix ne ""} {
	append prefix $preprefix
    } elseif {! $state(su)} {
	set prefix "X$prefix"
    } else {
	if {[info exists state($type,prefix)]} {;# For my road creating
	    append prefix $state($type,prefix)
	}
    }

    if {$type eq "roads"} {
	set ridLast [lindex [lsort -dictionary [array names roads]] end]
	regexp {\d+} $ridLast state($type,next)
    }

    while {1} {
	incr state($type,next)
	set id "${prefix}$state($type,next)"
	if {[array names $type "$id.*"] ne {}} continue
	if {[info exists splits(f,$id)]} continue
	if {[array names $type "$id"] eq {}} break
    }
    if {! $state(su) && $type ne "postit"} {
	append id "." [expr {abs([clock clicks -milliseconds])}]
    }
    incr state($type,next)
    return $id
}
##+##########################################################################
#
# ::Edit::AddNode
#
# Called to create a new node using date from ::Edit::CreateNode in nnode
# Also called by ::Zoom::Save
#
proc ::Edit::AddNode {nid {zoom ""}} {
    destroy .nnode
    .c delete cross

    set name $::nnode(e0)
    if {$nid eq {}} {set nid [::Edit::GetNextID n]}
    set alt [::Data::RConvert [::BadMath::Fix $::nnode(e1)] climb]
    set usgs ""
    regsub -all {[^0-9]} $::nnode(e2) "" usgs
    set ndata [concat [list $name] $alt $::nnode(latlon) $usgs]
    ::Edit::AddNode2 $nid $ndata
    ::Profile::DeleteLabelImages $nid

    set ::nid $nid
    if {$zoom ne ""} {
	::Zoom::Go node $nid
    }
    return $nid
}
##+##########################################################################
#
# ::Edit::AddNode2
#
# Does the actual inserting of a new node. Called by ::Edit::AddNode and
# by ::Route::Load.
#
proc ::Edit::AddNode2 {nid ndata} {
    foreach {name alt lat1 lat2 lat3 lon1 lon2 lon3 usgs} $ndata break

    ::Data::ProcessOneNode $nid $name $alt $lat1 $lat2 $lat3 \
	$lon1 $lon2 $lon3 $usgs

    foreach who [array names ::NR *,$nid] {
	foreach {rid . .} [split $who ","] break
	::Data::ReProcessOneRoad $rid
    }
    ::Display::DrawNodes $nid 0
    lappendUnique ::region(node,visible) $nid
    ::NodeList::Create
    ::Balloon::ClearText node $nid
    ::Route::StatRoute 1			;# Redraw route
}
##+##########################################################################
#
# ::Edit::AddRoad
#
# Called to create a new road using data from ::Edit::CreateRoad in nnode
#
proc ::Edit::AddRoad {rid {XY {}} {Z {}}} {
    global nnode nodes state trails NR
    set zoom ""
    if {$XY eq "zoom"} {
	set XY {}
	set zoom zoom
    }

    set name	$nnode(e0)
    set id1	$nnode(e1)
    set id2	$nnode(e2)
    set dist	[::Data::RConvert [::BadMath::Fix $nnode(e3)] dist]
    set north	[::Data::RConvert [::BadMath::Fix $nnode(e4)] climb]
    set south	[::Data::RConvert [::BadMath::Fix $nnode(e5)] climb]
    set comment $nnode(e6)
    set type	$nnode(e7)

    if {[info exists trails(rtype,$type)]} {
	set type $trails(rtype,$type)
    } elseif {! [info exists trails(type,$type)] && \
		  ! [info exists trails(user,$type)]} {
	set type 4
    }

    set id1 [::Edit::FindNode $id1]
    set id2 [::Edit::FindNode $id2]
    if {$id1 eq {} && $id2 eq {}} {
	WARN "Starting and Ending Nodes don't exist"
	return
    } elseif {$id1 eq {}} {
	WARN "Starting Node doesn't exist"
	return
    } elseif {$id2 eq {}} {
	WARN "Ending Node doesn't exist"
	return
    }

    if {$rid eq {}} {			;# Nope, new road
	set r [array names NR *,$id1,$id2]
	if {[llength $r] > 0 && ! $state(su)} {
	    WARN "Such a road already exists"
	    return
	}
	set rid [::Edit::GetNextID r]
	set xy [::Data::AddZ2XY $XY $Z]
    } else {
	set xy [::Data::AddZ2XY [lindex $::roads($rid) 8] \
		    [lindex $::roads($rid) 9]]
    }

    # If id1 north of id2 then "climb from start" is southbound
    if {[::Data::IsNorthNode $id1 $id2]} {
	foreach {north south} [list $south $north] break
    }
    destroy .nnode

    ::Edit::AddRoad2 $rid [list $id1 $id2 $north $dist $south $type \
					$name $comment $xy]
    ::Profile::DeleteLabelImages $rid
    set ::rid $rid
    if {$zoom ne ""} {
	::Zoom::Go road $rid
    }
    return $rid
}
##+##########################################################################
#
# ::Edit::AddRoad2
#
# Does the actual inserting of a new road. Called by ::Edit::AddRoad and
# by ::Route::Load.
#
proc ::Edit::AddRoad2 {rid rinfo} {
    foreach {id1 id2 north dist south type name comment xy} $rinfo break
    set ::xy $xy
    if {$xy ne {} && ! [string match "xy*" [lindex $xy 0]]} {
	set xy [concat "xy" $xy]
    }

    ::Balloon::ClearText road $rid
    ::Data::ProcessOneRoad $rid $id1 $id2 $north $dist $south $type \
	$name $comment $xy ""
    ::Data::ProcessRoads $rid
    ::Display::DrawRoads $rid
    ::Route::StatRoute 1			;# Redraw route
}
##+##########################################################################
#
# ::Edit::AddAlt -- adds some altitude (Z) info to a road
# unused (?)
#
#proc ::Edit::AddAlt {rid} {
#    global roads nnode
#
#    set elev [::Data::RConvert $nnode(e1) climb]
#    if {! [string is double -strict $elev] || $elev < 0} return
#
#    set xy [lindex $roads($rid) 8]
#    set z [lindex $roads($rid) 9]
#    if {$z eq {}} {
#	set z [string repeat "? " [expr {[llength $xy] / 6}]]
#    }
#    foreach {xy1 xy2} [::Edit::FindXYSplitPoint $rid] break
#
#    set xy [concat $xy1 $nnode(latlon) $xy2]
#    set len [expr {[llength $xy1] / 6}]
#    set zz [concat [lrange $z 0 [expr {$len-1}]] $elev [lrange $z $len end]]
#    lset roads($rid) 8 $xy
#    lset roads($rid) 9 $zz
#
#    ::Data::MarkModified road $rid
#    destroy .nnode
#    .c delete cross
#    set ::rid $rid
#}
##+##########################################################################
#
# ::Edit::AddSplit
#
# Deletes current road, adds a new node and two new roads.
#
proc ::Edit::AddSplit {rid {zoom ""}} {
    global nnode roads NR splits state

    if {$state(popup,what) eq "zoom"} ::Zoom::Close

    # Save off data for later
    foreach {id1 id2 v(n,org) v(d,org) v(s,org) type rname} $roads($rid) break
    if {! $state(su)} {set type 4}
    foreach {xy1 xy2 z1 z2} [::Edit::FindXYSplitPoint $rid] break

    # Fixup user data and make sure it's not too big
    set v(d,user) [::BadMath::Fix $nnode(e2)]
    set v(s,user) [::BadMath::Fix $nnode(e3)]
    set v(n,user) [::BadMath::Fix $nnode(e4)]
    set v(d,user) [::BadMath::Min $v(d,user) [::Data::RConvert $v(d,org) dist]]
    set v(s,user) [::BadMath::Min $v(s,user) [::Data::RConvert $v(s,org) climb]]
    set v(n,user) [::BadMath::Min $v(n,user) [::Data::RConvert $v(n,org) climb]]

    # Delete the existing road
    lappend splits(undo) $rid
    set splits(u,$rid) $roads($rid)
    ::Edit::DeleteRoad $rid 1

    # Add the new node: we rely on nnode(e0) and nnode(e1) being set properly
    set nid [::Edit::AddNode {}]

    # Now add the northern most of the two new roads
    set nnode(e0) $rname
    set nnode(e1) $id1
    set nnode(e2) $nid
    set nnode(e3) $v(d,user)			;# Dist from north node
    set nnode(e4) $v(s,user)			;# Climb from north node
    set nnode(e5) $v(n,user)			;# Descent from north node
    set nnode(e6) ""
    set nnode(e7) $type
    set rid1 [::Edit::AddRoad {} $xy1 $z1]

    # Compute distance, climbing and descending for second leg
    foreach {. . v(n,1st) v(d,1st) v(s,1st)} $roads($rid1) break

    set v(d,2nd) [::BadMath::Max 0 [::BadMath::Sub $v(d,org) $v(d,1st)]]
    set v(n,2nd) [::BadMath::Max 0 [::BadMath::Sub $v(n,org) $v(n,1st)]]
    set v(s,2nd) [::BadMath::Max 0 [::BadMath::Sub $v(s,org) $v(s,1st)]]

    set nnode(e0) $rname
    set nnode(e1) $nid
    set nnode(e2) $id2
    set nnode(e3) [::Data::Convert $v(d,2nd) dist]
    set nnode(e4) [::Data::Convert $v(s,2nd) climb]
    set nnode(e5) [::Data::Convert $v(n,2nd) climb]
    set nnode(e6) ""
    set nnode(e7) $type
    set rid2 [::Edit::AddRoad {} $xy2 $z2]

    set splits(r,$rid1) $rid
    set splits(f,$rid) [list $nid $rid1 $rid2]
    set splits(r,$rid1) $rid
    set splits(r,$rid2) $rid
    set splits(r,$rid2) $rid
    ::Data::MarkModified split f,$rid

    if {$zoom ne ""} {
	::Zoom::Go node $nid
    }
}
##+##########################################################################
#
# ::Edit::AddPhoto -- Adds the actual photo markup
#
proc ::Edit::AddPhoto {phid {zoom ""}} {
    global nnode

    destroy .nnode
    .c delete cross

    set lat [eval lat2int [lrange $nnode(latlon) 0 2]]
    set lon [eval lat2int [lrange $nnode(latlon) 3 5]]
    set url $nnode(e0)
    set sdesc $nnode(e1)
    set ldesc $nnode(e2)
    ::Photo::AddNew $phid $lat $lon $url $sdesc $ldesc
}
##+##########################################################################
#
# ::Edit::FindXYSplitPoint
#
# Takes the XY list for a given road, finds which segment is closest
# to the mouse point and splits the list at that point.
#
proc ::Edit::FindXYSplitPoint {rid} {
    global state roads

    set xy [lindex $roads($rid) 8]		;# XY in lat/lon
    set z [lindex $roads($rid) 9]
    if {[llength $xy] == 0} { return [list {} {} {} {}] }
    set cxy [::Display::GetRoadPoints $rid]	;# XY in canvas (x,y)
    foreach {cx cy} $state(popup,c) break

    set debug 0
    if {$debug} {
	set colors [list red blue yellow cyan green]
	.c delete xy
	foreach {x1 y1 x2 y2} [::Display::MakeBox [list $cx $cy] 8] break
	.c create line $x1 $y1 $x2 $y2 -tag xy -fill red -width 5
	.c create line $x2 $y1 $x1 $y2 -tag xy -fill red -width 5
    }

    # Loop through each line segment, finding which is closest to
    # the split point
    foreach {x0 y0} $cxy break
    set idx 0
    set sp -1
    foreach {x1 y1} [lrange $cxy 2 end] {
	set dist [::Data::DistanceToLine $cx $cy $x0 $y0 $x1 $y1]
	if {$sp == -1 || $dist < $mdist} {
	    set sp $idx
	    set mdist $dist
	}
	if {$debug} {
	    set color [lindex $colors 0]
	    set colors [concat [lrange $colors 1 end] $color]
	    .c create line $x0 $y0 $x1 $y1 -fill $color -width 5 -tag xy
	    puts "    $idx: $dist ($color)\t => $sp: $mdist"
	}
	foreach {x0 y0} [list $x1 $y1] break
	incr idx
    }

    set xy1 [lrange $xy 0 [expr {$sp*6-1}]]
    set xy2 [lrange $xy [expr {$sp*6}] end]
    set z1 [lrange $z 0 [expr {$sp-1}]]
    set z2 [lrange $z $sp end]
    return [list $xy1 $xy2 $z1 $z2]
}
##+##########################################################################
#
# ::Edit::DeleteNode
#
# Deletes a node and all incoming roads. We assume the user's
# permissions have already been checked.
#
proc ::Edit::DeleteNode {nid {dontask 0}} {
    global roads route nodes
    global NR

    set txt "Are you sure you want to delete this node?"
    if {![::Edit::AreYouSure $dontask "Delete Node" $txt]} return

    array unset nodes $nid
    destroy .nnode
    foreach rinfo [array names NR *,$nid] {
	set rid [lindex $NR($rinfo) 0]
	::Edit::DeleteRoad $rid 1
    }

    .c delete inode_$nid
    if {[lsearch $route(nodes) $nid] != -1} {
	::Route::ClearRoute
    }
    ::Data::MarkModified node $nid 1
    INFO "Delete node $nid"
}
##+##########################################################################
#
# ::Edit::DeleteRoad
#
# Deletes the specified road. We assume that the user's permissions have
# already been checked.
#
proc ::Edit::DeleteRoad {rid {dontask 0}} {
    global roads route region
    global NR

    if {! [info exists roads($rid)]} return

    set txt "Are you sure you want to delete this road?"
    if {![::Edit::AreYouSure $dontask "Delete Road" $txt]} return

    destroy .nnode
    foreach {node1 node2} $roads($rid) break
    unset roads($rid)
    foreach a [array names NR $rid,*] {
	unset NR($a)
    }
    set n [lsearch $region(road,visible) $rid]
    set region(road,visible) [lreplace $region(road,visible) $n $n]

    .c delete road_$rid
    if {[lsearch $route(roads) $rid] != -1} {
	::Route::ClearRoute
    }
    ::Data::MarkModified road $rid 1
    INFO "Delete road $rid"
}
proc ::Edit::DeletePhoto {phid} {
    destroy .nnode
    ::Photo::Delete $phid
}
##+##########################################################################
#
# ::Edit::AreYouSure
#
# On my Windows NT machine which has X-mouse turned on, grab doesn't
# fully work. In particular, the .nnode buttons aren't disabled when
# tk_messageBox is up. So we have to remove then restore all bindings
# before showing the messageBox.
#
proc ::Edit::AreYouSure {dontask title txt} {
    if {$dontask} { return 1 }

    set bindings {}
    foreach child [winfo children .] {
	lappend bindings $child [bindtags $child]
	bindtags $child Nothing
    }

    set title "$::state(progname) $title"
    set n [tk_messageBox -parent . -title $title -message $txt \
	       -icon question -type yesno -default no]

    foreach {child binding} $bindings {
	bindtags $child $binding
    }
    return [string equal "yes" $n]
}
##+##########################################################################
#
# ::Edit::FindNode
#
# Does its best to locate the node given nodeid. Likely scenarios:
#   n33 => n33
#   33 => n33
#   x33 => Xn33
#   d33 => nD33
#   nd23 => nD23
#
proc ::Edit::FindNode {nid} {
    global nodes

    if {[info exists nodes($nid)]} { return $nid } ;# Exact match
    if {[string match -nocase "n*" $nid]} {
	set nid "n[string totitle [string range $nid 1 end]]"
    } elseif {[string match -nocase "Xn*" $nid]} {
	set nid [string totitle $nid]
    } elseif {[string match -nocase "X*" $nid]} {
	set nid "Xn[string range $nid 1 end]"
    } else {
	set nid "n[string totitle $nid]"
    }
    if {[info exists nodes($nid)]} { return $nid } ;# Exact match
    set id [array names nodes "$nid.*"]
    if {[llength $id] == 1} {
	return [lindex $id 0]
    }
    return ""
}
##+##########################################################################
#
# ::Edit::PrettyNode -- turns internal nid into a pretty format
#
proc ::Edit::PrettyNode {nid} {
    regsub {^Xn(\d+)\.\d*$} $nid {X\1} nid	;# User nodes
    regsub {^n} $nid {} nid			;# Clean up node
    return $nid
}
## EON EDIT
## BON USGS
##+##########################################################################
#
# ::USGS::Dialog -- puts up "please wait" dialog and queries USGS
#
proc ::USGS::Dialog {parent latlon} {
    variable W
    variable elev "?"

    ::USGS::_MakeWaitDialog $parent $latlon
    update
    # Set off background http request and then freeze the UI until done
    after idle [list ::USGS::Query $W $latlon]
    DoGrab $W $W
    return $elev
}
##+##########################################################################
#
# ::USGS::_MakeWaitDialog -- draws our dialog box
#
proc ::USGS::_MakeWaitDialog {parent {latlon ""}} {
    variable W

    set W .usgs
    destroy $W

    set WB $W.body
    set WBC $WB.c
    set WBTN $W.buttons

    set wtitle "Querying USGS Elevation"
    set title $wtitle
    if {$latlon ne ""} {
	foreach {lat lon} [eval ::Display::PrettyLat $latlon] break
	append title "\nLatitude $lat\nLongitude $lon"
    }
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::usgs usgs.gif]
    wm transient $W $parent

    ::ttk::button $WBTN.cancel -text Cancel -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    ::my::label $WB.l -text "Please Wait" -font bigBold -foreground red
    ::my::label $WB.msg -textvariable ::USGS::S(msg) -anchor w
    set ::USGS::S(msg) ""
    pack $WB.l $WB.msg -side top -fill x

    ::Display::CenterWindow $W $parent
    wm deiconify $W
    return $W
}
##+##########################################################################
#
# ::USGS::Query -- background http request getting USGS elevation
#
proc ::USGS::Query {W latlon} {
    variable elev

    set lat [eval lat2int [lrange $latlon 0 2]]
    set lon [eval lat2int [lrange $latlon 3 5]]
    set usgs [::USGS::GetElevation $lat "-$lon"]
    destroy $W					;# Release the grab

    set elev $usgs
    return $usgs
}
##+##########################################################################
#
# ::USGS::GetElevation -- gets USGS's estimate for elevation at a point
# see http://gisdata.usgs.net/XmlWebServices/TNM_Elevation_Service.php
# see also http://ned.usgs.gov/
# 2017/08/22 : moved to nationalmap.gov
#
# Result is in INTERNAL units
#
proc ::USGS::GetElevation {lat lon {sanityVarName ""}} {
    if {! [::Data::CanDo internet]} {
	return [WARN "This feature requires the http extension"]
    }

    if {$sanityVarName ne ""} {
	upvar 1 $sanityVarName save
    }


    set units [expr {$::state(units,internal) eq "english" ? "Feet" : "Meters"}]
    set url [subst https://nationalmap.gov/epqs/pqs.php?x=${lon}&y=${lat}&units=${units}&output=xml]
    set save [list url $url lat $lat lon $lon qs ""]
    set token [::URL::GetUrlFollowRedirects $url]

    if {0} { old code
        set url http://gisdata.usgs.gov/XMLWebServices/TNM_Elevation_Service.asmx/getElevation
        set url http://gisdata.usgs.gov/xmlwebservices2/elevation_service.asmx/getElevation
        #set url http://gisdata.usgs.gov/xmlwebservices2/elevation_service.asmx/getElevation?AspxAutoDetectCookieSupport=1
        set units [expr {$::state(units,internal) eq "english" ? "FEET" : "METERS"}]
        set qs [::http::formatQuery X_Value $lon Y_Value $lat \
                    Elevation_Units $units Source_Layer "" Elevation_Only ""]
        set save [list url $url lat $lat lon $lon qs $qs]
        set token [::http::geturl $url -query $qs]
        ::http::wait $token
        #upvar #0 $token _state
    }
    set ncode [::http::ncode $token]
    if {$ncode != 200} {
	::http::reset $token
	set ::USGS_ERROR $save
	return "web error: $ncode"
    }
    # Check content-type???
    # set meta [set [set token](meta)]

    set data [::http::data $token] ; list
    ::http::cleanup $token
    set ::XML $data ; list
    lappend save xml $data ; list

    # Do primitive XML parsing
    set xml [string map {&gt; > &lt; < &amp; & &apos; ; &quot; \x22} $data]
    regsub -all {<!--.*?-->} $xml {} xml
    set n [regexp {<Elevation>(.*?)</Elevation>} $xml => elev]
    if {! $n} {set ::USGS_ERROR $save; return "XML error"}
    if {$elev == -1000000 || $elev == -1.79769313486231E+308} {
	set ::USGS_ERROR $save;
	return "Unknown Elevation"
    }

    # Convert result to internal units (this SHOULD be a nop)
    set xunits Feet
    regexp {<Units>(.*?)</Units>} $xml => xunits
    set xunits [string toupper $xunits]
    set elev [::Data::RConvert2 $elev climb \
		  [expr {$xunits eq "FEET" ? "english" : "metric"}]]
    set elev [Round0 $elev]
    return $elev
}
## EON USGS
## BON SAVE
proc DumpAllData {{who ""} {fname "road.data"}} {
    array unset lchanged

    set lchanged(node) [lsort -dictionary [array names ::nodes $who*]]
    set lchanged(road) [lsort -dictionary [array names ::roads $who*]]
    set lchanged(photo) [lsort -dictionary [array names ::photos $who*]]
    set lchanged(poi) [lsort -dictionary [array names ::poi $who*]]
    set lchanged(split) [lsort -dictionary [array names ::splits f,*]]
    set lchanged(geo) {}
    set lchanged(trail) [lsort -dictionary [array names ::trails user,*]]

    ::Save::SaveUserData $fname lchanged
    puts "saved into $fname"
}
proc DumpToUserNodes {} {
    set fname [::Init::LocateZoneFile $::Save::fileName 0]
    DumpAllData "" $fname
}
proc DumpChangedData {} {
    set fname "road.data"

    array unset lchanged
    set lchanged(node) [lsort -dictionary [array names ::nodes X*]]
    set lchanged(road) [lsort -dictionary [array names ::roads X*]]
    set lchanged(poi) [lsort -dictionary [array names ::poi X*]]
    set lchanged(photo) [lsort -dictionary [array names ::photos X*]]
    set lchanged(split) [lsort -dictionary [array names ::splits f,*]]
    set lchanged(trail) [lsort -dictionary [array names ::trails user,*]]
    set lchanged(photo) {}
    set lchanged(geo) {}
    foreach arr [array names ::Data::changed] {
	set lchanged($arr) [lsort -unique \
				[concat $lchanged($arr) $::Data::changed($arr)]]
    }

    ::Save::SaveUserData $fname lchanged
    puts "saved into $fname"
}
##+##########################################################################
#
# SaveUserDataCmd
#
# Causes all user created data to be saved to "user.nodes" file.
#
proc ::Save::SaveUserDataCmd {{quiet 0}} {
    variable fileName
    global state

    unset -nocomplain lchanged
    set lchanged(node) [lsort -dictionary [array names ::nodes X*]]
    set lchanged(road) [lsort -dictionary [array names ::roads X*]]
    set lchanged(poi) [lsort -dictionary [array names ::poi X*]]
    set lchanged(photo) [lsort -dictionary [array names ::photos X*]]
    set lchanged(split) [lsort -dictionary [array names ::splits f,*]]
    #set lchanged(trail) [lsort -dictionary [array names ::trails user,*]]
    set lchanged(trail) {}
    set lchanged(geo) {}
    foreach arr [array names ::Data::changed] {
	set lchanged($arr) [concat $lchanged($arr) $::Data::changed($arr)]
    }

    set fname [::Init::LocateZoneFile $fileName 0]
    set err [::Save::SaveUserData $fname lchanged]
    if {$err ne ""} {
	WARN $err
	return
    }
    if {! $quiet && ! $state(su)} {
	set txt "Saved user data to file $fname.\n\n"
	append txt "The data will automatically be loaded everytime \n"
	append txt "you load the $state(zone) zone."
	DoInfo $txt "KLIMB Save User Data"
    }
    ::Data::ClearModified
}
##+##########################################################################
#
# SaveUserData -- writes out specific node, road, poi, split and trails.
#
proc ::Save::SaveUserData {fname _changed} {
    global roads nodes poi photos splits trails state

    upvar 1 $_changed lchanged

    if {$fname eq "-"} {
	set FOUT stdout
    } else {
	set n [catch {set FOUT [open $fname "w"]} err]
	if {$n} {return $err}
    }

    set nids [lsort -unique -dictionary $lchanged(node)]
    if {$nids ne {}} {
	puts $FOUT "# Node data"
	puts $FOUT "# N nodeid \"description\" alt lat1 lat2 lat3 lon1 lon2 lon3 usgs"
	foreach nid $nids {
	    foreach {name alt lat lon xy usgs} $nodes($nid) break
	    regsub -all {\n} $name {\n} name
	    puts $FOUT "N $nid \"$name\" $alt [int2lat $lat] [int2lat $lon] $usgs"
	}
	puts $FOUT ""
    }

    set rids [lsort -unique -dictionary $lchanged(road)]
    if {$rids ne {}} {
	puts $FOUT "# Road data"
	puts $FOUT "# R roadid id1 id2 north distance south type name comment xy survey"
	foreach rid $rids {
	    puts $FOUT [::Save::PackageRoadData $rid]
	}
	puts $FOUT ""
    }

    set phids [lsort -unique -dictionary $lchanged(photo)]
    if {$phids ne {}} {
	puts $FOUT "# Photo data"
	puts $FOUT "# Ph lat lon url sdesc ldesc"
	foreach phid $phids {
	    foreach {lat lon url sdesc ldesc} $photos($phid) break
	    puts $FOUT "Ph $phid $photos($phid)"
	}
	puts $FOUT ""
    }

    set pids [lsort -unique -dictionary $lchanged(poi)]
    if {$pids ne {}} {
	puts $FOUT "# Poi data"
	puts $FOUT "# P pid type name lat lon location ldesc url"
	puts $FOUT "#  type: W water B bathroom F food H historical marker X <name>"
	puts $FOUT "#  if type is X then use NAME"
	puts $FOUT "#    balloon help: TYPE/NAME "
	puts $FOUT "#    status bar:   TYPE/NAME at LOCATION -- status bar"
	puts $FOUT "#    dialog box:   TYPE/NAME :: at LOCATION :: ldesc"
	puts $FOUT "# "

	foreach pid $pids {
	    foreach {type name lat lon location ldesc , url} $poi($pid) break
	    set line [format {P %s %s "%s" %s %s "%s" "%s" %s} \
			  $pid $type $name [int2lat $lat] [int2lat $lon] \
			  $location $ldesc $url]
	    puts $FOUT $line
	}
	puts $FOUT ""
    }

    set lsplits [lsort -unique -dictionary $lchanged(split)]
    if {$lsplits ne {}} {
	puts $FOUT "# Split Road Data"
	puts $FOUT "# S rid => nid rid1 rid2"
	foreach who $lsplits {
	    set rid [lindex [split $who ","] 1]
	    if {! [info exists splits(f,$rid)]} {
		puts "missing split: $who"
		set ::badSplits $lchanged(split)
	    } else {
		puts $FOUT "S $rid => $splits(f,$rid)"
	    }
	}
	puts $FOUT ""
    }

    set ltrails [lsort -unique -dictionary $lchanged(trail)]
    if {$ltrails ne {}} {
	puts $FOUT "# Trail data"
	puts $FOUT "# T tid name color1 width1 color2 width2"
	foreach trail $ltrails {
	    set tid [lindex [split $trail ","] end]
	    set line [list T $tid $trails($trail) \
			  $state(r,0,$tid,color) $state(r,0,$tid,width) \
			  $state(r,1,$tid,color) $state(r,1,$tid,width)]
	    regsub -all {[{}]} $line "\"" line
	    puts $FOUT $line
	}
	puts $FOUT ""
    }
    if {$fname ne "-"} {
	close $FOUT
    }
}
##+##########################################################################
#
# ::Save::PackageRoadData -- returns road in format for saving
#
proc ::Save::PackageRoadData {rid} {
    global roads

    foreach {id1 id2 north dist south type name comment xy z quality survey} \
	$roads($rid) break

    if {! [string is double -strict $north]} { set north "?"}
    if {! [string is double -strict $dist]}  { set dist  "?"}
    if {! [string is double -strict $south]} { set south "?"}

    set line [list R $rid $id1 $id2 $north $dist $south $type \
		  $name $comment]
    regsub -all "\#" $line {\#} line
    regsub -all {[{}]} $line "\"" line
    set xy [::Data::MakeXYZ $xy $z]
    if {$xy ne {} || $survey ne ""} {append line " {$xy}"}
    if {$survey ne ""} {append line " $survey"}
    return $line
}
## EON SAVE
## BON GALLERY
##+##########################################################################
#
# ::Gallery::Dialog -- puts up our picture gallery dialog
#
proc ::Gallery::Dialog {} {
    variable WB
    variable WBTN
    variable vcols 3

    set W .gallery
    destroy $W

    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Gallery"
    set title "$::state(progname) Biking Picture Gallery"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::album album.gif]
    wm protocol $W WM_DELETE_WINDOW ::Gallery::TearDown

    ::ttk::button $WBTN.large -text "Full Size" -state disabled \
	-command ::Gallery::Large
    ::ttk::button $WBTN.dismiss -text Dismiss -command ::Gallery::TearDown
    ::Display::GridChildren $WBTN 0

    ::tk::frame $WB.f -bg white -bd 2 -relief ridge
    ::ttk::scrollbar $WB.sb -orient vertical -command [list $WB.c yview]
    canvas $WB.c -bd 0 -highlightthickness 0 -bg white \
	-yscrollcommand [list $WB.sb set]
    bind $WB.c <Key-Prior> [list $WB.c yview scroll -1 page]
    bind $WB.c <Key-Next> [list $WB.c yview scroll 1 page]
    bind $W <Control-w> {destroy .labout}
    pack $WB.f -fill both -expand 1
    pack $WB.sb -in $WB.f -side right -fill y
    pack $WB.c -in $WB.f -side left -fill both -expand 1

    ::Gallery::_Dialog

    ::Display::CenterWindow $W
    wm deiconify $W
    wm resizable $W 1 1
    focus $WB.c
}

proc ::Gallery::_Dialog {} {
    variable WB
    variable meta
    variable vcols
    variable vrows

    ::Gallery::GetPhotoData
    for {set i $vcols} {$i > 0} {incr i -1} {
	set w [expr {$i * $meta(maxW)}]
	if {$w + 200 < [winfo screenwidth [winfo toplevel $WB]]} break
    }
    for {set i $vrows} {$i > 0} {incr i -1} {
	set h [expr {$i * $meta(maxH)}]
	if {$h + 150 < [winfo screenheight [winfo toplevel $WB]]} break
    }
    incr w 5
    incr h 5
    $WB.c config -width $w -height $h
    bind $WB.c <Configure> ::Gallery::FillGallery
}
##+##########################################################################
#
# ::Gallery::FillGallery -- manually lays out our image gallery based on the
# size of the canvas
#
proc ::Gallery::FillGallery {} {
    variable WB
    variable meta

    $WB.c delete all
    ::Gallery::Click ""				;# Clear selection

    set w [winfo width $WB.c]
    if {$w == 0} { set w [winfo reqwidth $WB.c] } ;# Just be safe
    if {$w == 0} return

    set cols [expr {$w / $meta(maxW)}]
    if {$cols == 0} {set cols 1}
    set cwidth [expr {$w / $cols}]
    set clr white

    for {set idx 0} {$idx < $meta(cnt)} {incr idx} {
	set row [expr {$idx / $cols}]
	set col [expr {$idx % $cols}]
	#set clr [expr {(($row+$col) & 1) ? "green" : "yellow"}]

	set img $::About::bmsg($idx,img)
	set txt $::About::bmsg($idx,short)
	#append txt [eval format [list "\n(%dx%d)"] $meta($idx,size)]
	set btxt1 $::About::bmsg($idx,long)
	set btxt2 $::About::bmsg($idx,short)


	set x0 [expr {$col * $cwidth+1}]
	set y0 [expr {$row * $meta(maxH)+1}]
	set x1 [expr {$x0 + $cwidth-2}]
	set y1 [expr {$y0 + $meta(maxH)-1}]
	$WB.c create rect $x0 $y0 $x1 $y1 -fill $clr -width 0 \
	    -tag [list cell$idx cell]
	set x [expr {($x0+$x1)/2}]
	set y [expr {($y0+$y1)/2}]
	$WB.c create image $x $y -image $img -tag img$idx
	set y2 [expr {$y + [image height $img] / 2 - 5}]
	$WB.c create text $x $y2 -text $txt -font boldFont -anchor n \
	    -tag txt$idx -justify center

	foreach tag [list cell$idx img$idx txt$idx] {
	    $WB.c bind $tag <1> [list ::Gallery::Click $idx]
	    $WB.c bind $tag <Double-1> ::Gallery::Large
	}
	::Balloon::Create [list $WB.c img$idx] gallery $idx $btxt1 $btxt2
    }
    $WB.c config -scrollregion [$WB.c bbox all]
}
##+##########################################################################
#
# ::Gallery::TearDown -- ends the gallery dialog
#
proc ::Gallery::TearDown {} {
    foreach arr [array names ::About::bmsg *,img] {
	image delete $::About::bmsg($arr)
	unset ::About::bmsg($arr)
    }

    destroy .gallery
}
##+##########################################################################
#
# ::Gallery::Click -- handles clicking on an image
#
proc ::Gallery::Click {idx} {
    variable WB
    variable WBTN
    variable meta

    $WB.c itemconfig cell -width 0
    $WBTN.large config -state disabled

    if {$idx eq ""} return
    $WB.c itemconfig cell$idx -width 2
    $WBTN.large config -state normal
    set meta(active) $idx
}
##+##########################################################################
#
# ::Gallery::Large -- puts up the large version of the selected image
#
proc ::Gallery::Large {} {
    variable meta

    ::About::Large $meta(active)
}
##+##########################################################################
#
# ::Gallery::GetPhotoData -- creates shadow images of each about image
# and figures out the largest dimensions.
#
proc ::Gallery::GetPhotoData {} {
    variable meta
    variable vrows
    variable vcols

    ::About::_InitImage
    if {[info exists ::About::bmsg(0,img)]} return
    set maxW 0
    set maxH 0

    for {set idx 0} {[info exists ::About::bmsg($idx,iname)]} {incr idx} {
	set iname [file join $::state(idir) about $::About::bmsg($idx,iname)]
	set ::About::bmsg($idx,img) [::Display::MakeShadowPhoto \
					 ::img::about::img$idx $iname white]

	set w [image width  $::About::bmsg($idx,img)]
	set h [image height $::About::bmsg($idx,img)]
	#set meta($idx,size) [::Gallery::GetLargeSize $::About::bmsg($idx,iname)]
	if {$w > $maxW} {set maxW $w}
	if {$h > $maxH} {set maxH $h}
    }
    set meta(cnt) $idx
    set meta(maxW) [expr {$maxW + 10}]
    set meta(maxH) [expr {$maxH + 30}]
}
##+##########################################################################
#
# ::Gallery::GetLargeSize -- returns the dimensions of the large about image
#
proc ::Gallery::GetLargeSize {iname} {
    set iname2 [file join $::state(idir) about org $iname]
    if {! [file exists $iname2]} {
	set iname2 [file join $::state(idir) about $iname]
    }
    image create photo ::img::about::tmp -file $iname2
    set w [image width  ::img::about::tmp]
    set h [image height ::img::about::tmp]
    image delete ::img::about::tmp

    return [list $w $h]
}
## EON GALLERY
## BON SNAPSHOT
##+##########################################################################
#
# ::Snapshot::Dialog -- puts up the snapshot dialog
#
proc ::Snapshot::Dialog {} {
    variable S
    variable W
    variable WW
    variable BOX

    if {! [::Data::CanDo snapshot]} return

    destroy $W

    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Snapshot"
    set title "Snapshot"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::camera camera.gif]

    ::ttk::button $WBTN.snap -text "Take Snapshot" -command ::Snapshot::_Snap
    set WW(snap) $WBTN.snap
    ::ttk::button $WBTN.dismiss -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    # Body stuff
    $WB config -pad 15
    ::my::frame $WB.f -borderwidth 5 -relief ridge
    $WB.f config -pad 5
    set WW(c) $WB.c
    canvas $WW(c) -highlightthickness 0 -width $S(w) -height $S(h)
    ::Display::TileBGFix $WW(c)
    set maps [info commands ::map::*]
    set mymap [lindex $maps [expr {int(rand() * [llength $maps])}]]
    $WW(c) create image 0 0 -tag img -image $mymap -anchor nw

    ::my::label $WB.l1 -text "Click on the cells to include\nin the snapshot" \
	-font boldFont -anchor c -justify c
    ::my::label $WB.l2 -textvariable ::Snapshot::BOX(size) -font boldFont -anch c

    pack $WB.f -side top
    pack $WW(c) -side top -in $WB.f
    pack $WB.l1 -side top -fill x
    pack $WB.l2 -side top -fill x

    ::Snapshot::_MakeGrid
    ::Snapshot::_click $BOX(me,row) $BOX(me,col)

    ::Display::CenterWindow $W
    wm deiconify $W
    after 4000 ::Snapshot::Anim
    DoGrab $W $WBTN.snap
}
##+##########################################################################
#
# ::Snapshot::CanSnapshot -- tests whether we have the img::window package
# and at least one of img::jpeg and img::png
#
proc ::Snapshot::CanSnapshot {} {
    global state

    if {[info exists state(can,snapshot)]} { return $state(can,snapshot) }
    set n1 [::Data::CanDo grabWindow]
    set n2 [::Data::CanDo jpeg]
    set n3 [::Data::CanDo png]

    set state(can,snapshot) 1			;# Assume we can
    if {$n1 && ($n2 || $n3)} { return 1}

    set state(can,snapshot) 0
    WARN "Snapshot requires the Img package."
    return 0
}
##+##########################################################################
#
# ::Snapshot::_MakeGrid -- draws the grid to select cells on
#
proc ::Snapshot::_MakeGrid {} {
    variable WW
    variable BOX
    variable S

    ::Snapshot::_GetDimensions

    foreach arr [array names BOX xy,*] {
	scan $arr "xy,%d,%d" row col
	set tag box$row,$col

	foreach {x0 y0 x1 y1} $BOX($arr) break
	set x0 [expr {$x0 * $S(w)}]
	set y0 [expr {$y0 * $S(h)}]
	set x1 [expr {$x1 * $S(w)}]
	set y1 [expr {$y1 * $S(h)}]

	$WW(c) create rect $x0 $y0 $x1 $y1 -tag $tag -width 3 \
	    -outline black -fill black -stipple gray50
	$WW(c) bind $tag <1> [list ::Snapshot::_click $row $col]
	set BOX(val,$row,$col) 0
    }
}
##+##########################################################################
#
# ::Snapshot::_click -- handles clicking on a grid cell
#
proc ::Snapshot::_click {row col} {
    variable WW
    variable BOX

    set tag box$row,$col
    if {$BOX(val,$row,$col) == 0} {
	set BOX(val,$row,$col) 1
	$WW(c) itemconfig $tag -fill red -stipple gray75
    } else {
	set BOX(val,$row,$col) 0
	$WW(c) itemconfig $tag -fill black -stipple gray50
    }
    ::Snapshot::_GetISize
}
##+##########################################################################
#
# ::Snapshot::_GetISize -- Figures outs image size based on clicked cells
#
proc ::Snapshot::_GetISize {} {
    variable BOX
    variable WW

    set cnt 0
    for {set row 0} {$row < $BOX(rows)} {incr row} {
	for {set col 0} {$col < $BOX(cols)} {incr col} {
	    if {$BOX(val,$row,$col) == 0} continue
	    if {[incr cnt] == 1} {
		set rmin $row
		set rmax $row
		set cmin $col
		set cmax $col
	    } else {
		if {$row < $rmin} {set rmin $row}
		if {$row > $rmax} {set rmax $row}
		if {$col < $cmin} {set cmin $col}
		if {$col > $cmax} {set cmax $col}
	    }
	}
    }
    if {$cnt == 0} {
	set BOX(size) "? x ?"
	$WW(snap) config -state disabled
	return
    }

    set w [expr {$cmax - $cmin + 1}]
    set h [expr {$rmax - $rmin + 1}]
    $WW(snap) config -state [expr {$cnt == ($w*$h) ? "normal" : "disabled"}]

    foreach var {rmin rmax cmin cmax} {
	set BOX($var) [set $var]
    }
    foreach {. . w h} [::Snapshot::_GetToCoords $BOX(rmax) $BOX(cmax)] break
    set BOX(size) "[comma $w] x [comma $h]"
    set BOX(cnt) $cnt
}
##+##########################################################################
#
# ::Snapshot::_GetDimensions -- get scroll percentages for all cells
#
proc ::Snapshot::_GetDimensions {} {
    variable BOX

    unset -nocomplain BOX

    # Get size of whole screen
    foreach {l t r b} [.c cget -scrollregion] break
    set BOX(s,w) [expr {$r - $l}]
    set BOX(s,h) [expr {$b - $t}]


    foreach {xlo xxhi} [.c xview] break
    foreach {ylo yyhi} [.c yview] break
    set wx [expr {$xxhi - $xlo}]
    set wy [expr {$yyhi - $ylo}]


    for {set x $xlo} {$x > $wx} {set x [expr {$x - $wx}]} {}
    set xx 0
    if {$x == 0} {set x $wx}
    while {$x < 1} {
	lappend xx $x
	set x [expr {$x + $wx}]
    }
    lappend xx 1
    set BOX(cols) [expr {[llength $xx]-1}]

    for {set y $ylo} {$y > $wy} {set y [expr {$y - $wy}]} {}
    set yy 0
    if {$y == 0} {set y $wy}
    while {$y < 1} {
	lappend yy $y
	set y [expr {$y + $wy}]
    }
    lappend yy 1
    set BOX(rows) [expr {[llength $yy]-1}]

    # Now we can compute coordinates for all the boxes
    for {set col0 0; set col1 1} {$col1 < [llength $xx]} {incr col0; incr col1} {
	set xlo [lindex $xx $col0]
	set xhi [lindex $xx $col1]
	if {abs($xhi - $xxhi) < .0001} { set BOX(me,col) $col0 }

	for {set row0 0; set row1 1} {$row1 < [llength $yy]} {incr row0; incr row1} {
	    set ylo [lindex $yy $row0]
	    set yhi [lindex $yy $row1]
	    if {abs($yhi - $yyhi) < .0001} { set BOX(me,row) $row0 }
	    set BOX(xy,$row0,$col0) [list $xlo $ylo $xhi $yhi]
	}
    }
}
##+##########################################################################
#
# ::Snapshot::_Snap -- High level handler for capturing image
#
proc ::Snapshot::_Snap {} {
    variable W
    variable saveName
    variable msg "Taking Snapshot..."

    destroy $W
    ::Display::HideToplevels 1
    destroy .bbar.wait
    ::tk::label .bbar.wait -textvariable ::Snapshot::msg \
	-fg red -font bigBold \
	-bd 5 -relief solid -padx 10 -pady 5 -bg white
    place .bbar.wait -in .bbar -relx .5 -rely 0 -bordermode outside -anchor n

    set iname [::Snapshot::_MakeImage]

    destroy .bbar.wait
    ::Display::HideToplevels 0

    ::Snapshot::_Save $iname
    if {1} {
	image delete $iname
    } else {
	# Show the result for testing
	destroy .vsnap
	toplevel .vsnap -bg red
	::tk::label .vsnap.l -image $iname
	pack .vsnap.l -padx 10 -pady 10
    }
    return
}
##+##########################################################################
#
# ::Snapshot::_MakeImage -- middle level handler for creating image
#
proc ::Snapshot::_MakeImage {} {
    variable BOX
    variable msg

    set iname ::snap::img
    set tname ::snap::tmp
    foreach cmd [info commands ::snap::*] {image delete $cmd}

    foreach {. . w h} [::Snapshot::_GetToCoords $BOX(rmax) $BOX(cmax)] break
    image create photo $iname -width $w -height $h

    set cnt 0
    for {set row $BOX(rmin)} {$row <= $BOX(rmax)} {incr row} {
	for {set col $BOX(cmin)} {$col <= $BOX(cmax)} {incr col} {
	    incr cnt
	    set msg "Taking Snapshot $cnt/$BOX(cnt)"
	    ::Snapshot::_MakeOneImage $tname $row $col
	    set to [::Snapshot::_GetToCoords $row $col]
	    set from [::Snapshot::_GetFromCoords $row $col $tname]
	    eval $iname copy $tname -to $to -from $from
	}
    }
    image delete $tname
    ::Snapshot::_AddCopyright $iname
    ::Snapshot::_MoveTo $BOX(me,row) $BOX(me,col)
    return $iname
}
##+##########################################################################
#
# ::Snapshot::_MakeOneImage -- lowest level handler for creating image
#
proc ::Snapshot::_MakeOneImage {iname row col} {
    ::Snapshot::_MoveTo $row $col
    if {[info commands $iname] ne ""} {image delete $iname}
    image create photo $iname -data .c
    return $iname
}
##+##########################################################################
#
# ::Snapshot::_GetToCoords -- returns coords where this cell goes in
# the final image
#
proc ::Snapshot::_GetToCoords {row col} {
    variable BOX

    # Get top left corner of image in percentages
    foreach {xx yy} $BOX(xy,$BOX(rmin),$BOX(cmin)) break

    foreach {x0 y0 x1 y1} $BOX(xy,$row,$col) break
    set x0 [expr {round(($x0-$xx) * $BOX(s,w))}]
    set x1 [expr {round(($x1-$xx) * $BOX(s,w))}]
    set y0 [expr {round(($y0-$yy) * $BOX(s,h))}]
    set y1 [expr {round(($y1-$yy) * $BOX(s,h))}]
    return [list $x0 $y0 $x1 $y1]
}
##+##########################################################################
#
# ::Snapshot::_GetFromCoords -- for the extreme right column
# and bottom row we might have to grab from within the image
#
proc ::Snapshot::_GetFromCoords {row col img} {
    variable BOX

    set fromX 0
    set fromY 0

    foreach {x0 y0 x1 y1} $BOX(xy,$row,$col) break
    if {$x1 >= 1 && $x0 > 0} {
	set needX [expr {round($BOX(s,w) * ($x1-$x0))}]
	set fromX [expr {[image width $img] - $needX}]
    }
    if {$y1 >= 1 && $y0 > 0} {
	set needY [expr {round($BOX(s,h) * ($y1-$y0))}]
	set fromY [expr {[image height $img] - $needY}]
    }
    return [list $fromX $fromY]
}
##+##########################################################################
#
# ::Snapshot::_MoveTo -- Moves screen so a given cell is visible
#
proc ::Snapshot::_MoveTo {row col} {
    variable BOX
    foreach {xmin ymin} $BOX(xy,$row,$col) break
    .c xview moveto $xmin
    .c yview moveto $ymin
    update
}
##+##########################################################################
#
# ::Snapshot::_AddCopyright -- adds border and a copyright notice to an image
# See also ::Display::AddCopyright
#
proc ::Snapshot::_AddCopyright {img} {
    ::Display::MakeImage ::img::copyright copyright.gif
    if {[lsearch [image names] ::img::copyright] == -1} {
	image create photo ::img::copyright -data {
	    R0lGODlhHQEWAIAAAAAAAP///yH5BAAAAAAALAAAAAAdARYAAAL/jI+py+0Po5y0
	    2ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+AVgEf8NIEeg4GoLKwLDpXAKm
	    UwaVKsRKq9viVfjxRhNPo4kLhKrUCnZD/CYv21JyGdHMy5FHJn48t/cXKCGmN+HG
	    gVYHk4hUAWc1CPi46HT3WKnF5sf3l3hI+QAXalbSGeWFxqSmlbqFx+Xqeika6bdZ
	    S0coOobaqRRMiUrXN9wrJ1uVuzqJeVemzNfa/ET86QlozUu4rd0NHuidadiNWSmI
	    Xn75lbwLZhzPniVOfk5eny/te/+tO74H2K5ImfBx82WQ4Bxc+fx9EhZwYUNu15Ah
	    zLZQob9bywXDvULn8Nk7kQfrPct1MNQVVbLSoOzFEJrBWLwORZto6xgUgsR6jvSo
	    8dYimeGCgnQYkehFmD8FkXRW7OPTUkYRKqXYJeWkjxI7bpyp8qhSUl7JenQKcl/Y
	    kOKmngUL9B3OpWbLysWKkSvThqrwHvvKFmlRTZKACrTksiCtZYzmudyZ8KndlQKL
	    rrRy2U67duxYQm7LiJVYqBc5dlbcLI1FC45+uO7RekdsCLNf27ZRm4ZGDLlv+270
	    m9bv4cSLGz+OPLny5cybOygAADs=
	}
    }

    set w [image width  $img]
    set h [image height $img]
    set crw [image width ::img::copyright]
    set crh [image height ::img::copyright]

    set bd 2					;# Borderwidth
    set w2 [expr {$w + 2*$bd}]
    set h2 [expr {$h + 2*$bd}]
    set h3 [expr {$crw > $w ? $h2 : ($h2 + $crh)}] ;# Height w/ copyright

    image create photo ::img::temp -width $w2 -height $h3
    ::img::temp put white -to 0 0 $w2 $h3
    ::img::temp put black -to 0 0 $w2 $h2
    ::img::temp copy $img -to $bd $bd
    if {$crw <= $w} {
	::img::temp copy ::img::copyright -to [expr {$w2 - $crw}] [expr {$h3 - $crh}]
    }
    $img config -width $w2 -height $h3
    $img copy ::img::temp
    image delete ::img::temp
    return $img
}
##+##########################################################################
#
# ::Snapshot::Anim -- does animation for our dialog
#
proc ::Snapshot::Anim {} {
    variable W

    if {! [winfo exists $W]} return
    ::Display::MakeImage ::img::cameraOn cameraOn.gif
    $W.icon config -image ::img::cameraOn
    update
    after 200
    catch {$W.icon config -image ::img::camera}
    update

    set delay [expr {round(5000 + 10000 * rand())}]
    after $delay ::Snapshot::Anim
}
##+##########################################################################
#
# ::Snapshot::_Save -- Saves our image in a file
#
proc ::Snapshot::_Save {iname} {
    variable saveName

    set types {}
    if {$::state(can,png)} {lappend types {"PNG Files" ".png"}}
    if {$::state(can,jpeg)} {lappend types {"JPEG Files" ".jpg"}}
    #set types {{"JPEG Files" ".jpg"}}
    set ext [lindex $types 0 1]

    set fname [tk_getSaveFile -defaultextension $ext \
		   -title "$::state(progname) Save Snapshot" \
		   -filetypes $types \
		   -initialdir [file dirname $saveName] \
		   -initialfile [file tail [file rootname $saveName]]]
    if {$fname eq ""} return
    set saveName $fname

    set fmt [expr {[file extension $saveName] eq ".png" ? "png" : "jpeg"}]
    $iname write $saveName -format $fmt
}
## EON SNAPSHOT
## BON TRACE
##+##########################################################################
#
# ::Trace::Trace -- puts up trace dialog and begins the animation
#
proc ::Trace::Trace {} {
    ::Trace::Dialog
    catch {${::Trace::W}.buttons.stop config -text "Stop Tracing"}
    ::Trace::DoTrace 0
}
##+##########################################################################
#
# ::Trace::Dialog -- draws the trace dialog
#
proc ::Trace::Dialog {} {
    variable tdata
    variable W

    if {[winfo exists $W]} return

    set WC $W.c
    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Trace Route"
    set title "Trace Route Running Totals"
    ::Display::MakeDialogBox $W $wtitle $title ""
    wm protocol $W WM_DELETE_WINDOW [list ::Trace::Clear 1]

    $WC config -height 130 -width 110
    ::Trace::DrawAnimation $WC

    ::ttk::button $WBTN.stop -text "Stop Tracing" -command ::Trace::StartStop
    ::ttk::button $WBTN.dismiss -text Dismiss -command [list ::Trace::Clear 1]
    ::Display::GridChildren $WBTN 0

    # Body stuff
    ::my::label $WB.ldist -text "Distance" -width 11 -anchor e
    #::my::label $WB.dist -textvariable ::Trace::tdata(d,miles) -width 8 -anchor e
    ::my::entry $WB.dist -textvariable ::Trace::tdata(d,miles) -width 8 -justify right
    ::my::label $WB.udist -width 5 -anchor w
    ::my::label $WB.lclimb -text "Climbing" -width 11 -anchor e
    ::my::label $WB.climb -textvariable ::Trace::tdata(d,climb) -width 8 -anchor e
    ::my::label $WB.uclimb -width 5  -anchor w
    ::my::label $WB.ldesc -text "Descending" -width 11 -anchor e
    ::my::label $WB.desc -textvariable ::Trace::tdata(d,desc) -width 8 -anchor e
    ::my::label $WB.udesc -width 5 -anchor w
    grid $WB.ldist $WB.dist $WB.udist -sticky e
    grid $WB.lclimb $WB.climb $WB.uclimb -sticky e
    grid $WB.ldesc $WB.desc $WB.udesc -sticky e
    ::Data::UniqueTrace ::Trace::tdata(d,miles) ::Trace::VarTrace

    set mphs [::Description::GetMPHS]
    if {$mphs ne {}} {
	::my::label $WB.ltime -text "Times:" -width 11
	grid $WB.ltime -pady {10 0}
	foreach {mph unit} $mphs {
	    ::my::label $WB.ltime_$mph -text "@ $mph $unit" -width 11 -anchor e
	    ::my::label $WB.ttime_$mph -textvariable ::Trace::tdata(d,$mph) \
		-width 8 -anchor e
	    grid $WB.ltime_$mph $WB.ttime_$mph -sticky e
	}
    }
    ::Trace::Units

    ::Display::LeftWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Trace::DoTrace
#
# Does the actual animation of list of nodes. If restart is true, then
# we pick up from where we left off.
#
proc ::Trace::DoTrace {restart} {
    variable tdata
    set step [::Trace::ComputeStepSize $tdata(anim,pixels)]

    if {! $restart || $tdata(reset)} {		;# Recompute data?
	::Trace::GetData
	set tdata(startat) 0
    }

    if {[llength $tdata(dist)] == 0} return	;# Nothing to do

    # Give a way for the user to stop the animation
    bind all <Escape>	 {set ::Trace::tdata(anim) 0}
    set ::Trace::tdata(anim) 1

    # Create our animation image at the first node
    foreach {X1 Y1} [lindex $tdata(xy) 0] break
    set angle [lindex $tdata(angle) 0]
    ::Trace::Biker .c $X1 $Y1 $angle

    set end [expr {[lindex $tdata(dist) end] * $step}] ;# End of animation
    set start 0
    if {$restart} {set start [expr {1 + int($tdata(startat) * $step)}]}
    set tdata(mphs) [::Description::GetMPHS]
    for {set idx $start} {$idx <= $end} {incr idx} {
	if {! [winfo exists $::Trace::W]} {
	    ::Trace::Clear 1
	    break
	}

	set mp [expr {$idx / double($step)}]	;# Milepost for animation
	::Trace::_DrawBikerAt $mp
	::Trace::DialogAnimation $idx

	update
	after $tdata(anim,delay)
	if {! $tdata(anim)} break
    }

    if {$tdata(anim)} {				;# If completed full trace
	::Trace::DrawBiker .c 0			;# Then delete animation
	::Profile::Trace 0 1			;# ...and off the profile
	set tdata(startat) 0
    } else {
	set tdata(startat) $mp
    }

    set tdata(anim) 0
    catch {unset ::nodes(biker)}
    bind all <Escape> {}

    ::Trace::StartStop 1
}
##+##########################################################################
#
# ::Trace::_DrawBikerAt -- Draws biker on the main screen and profile graph
#
proc ::Trace::_DrawBikerAt {mp {skipDist 0}} {
    variable tdata

    set xya [::Trace::Mile2Canvas $mp]	        ;# Where it should go

    foreach {X Y angle} $xya break
    ::Trace::Biker .c $X $Y $angle
    ::Profile::Trace $mp 0			;# Animate the profile window

    # Running stats in the trace window
    set x [::Trace::Mile2Data $mp]
    foreach {perc dist climb desc} $x break
    set dist [::Data::Convert $dist dist]
    if {$dist ne ""} { set dist [format %.1f $dist]}
    if {! $skipDist} {
	set tdata(d,miles) [comma $dist]
    }
    set tdata(d,climb) [comma [::Data::Convert $climb climb]]
    set tdata(d,desc)  [comma [::Data::Convert $desc climb]]
    foreach {mph unit} $tdata(mphs) {
	set seconds 0
	catch {set seconds [expr {round($dist *60.0*60/ $mph)}]} ;# TODO:metric
	set tdata(d,$mph) [clock format $seconds -gmt 1 -format %H:%M]
    }

    # Make sure we can see the node
    set ::nodes(biker) [list 0 1 2 3 [list $X $Y]] ;# Fake node for IsVisible
    ::Display::ToCenter biker

}
##+##########################################################################
#
# ::Trace::ComputeStepSize -- computes step size (ticks per mile) so
# that each step is a fixed number of pixels away. Makes trace speed
# independent of map scale.
#
proc ::Trace::ComputeStepSize {pxlsPerStep} {
    foreach {. . . . lat1 lon1} [::Display::canvas2pos 0 0] break
    foreach {. . . . lat2 lon2} [::Display::canvas2pos $pxlsPerStep 0] break
    set feet [::Data::Distance $lat1 $lon1 $lat2 $lon2 1]
    set step [expr {round(5280./$feet)}]
}
##+##########################################################################
#
# ::Trace::Clear
#
# Updates the display when tracing info is no longer valid.
#
proc ::Trace::Clear {destroy} {
    variable tdata

    catch {::Trace::DrawBiker .c 0}             ;# May not yet exist
    ::Profile::Trace 0 1			;# Delete off of profile

    set tdata(anim)	0			;# Turn off animation
    set tdata(reset)	1			;# Must restart at beginning
    set tdata(d,miles) "?"			;# Reset what it displays
    set tdata(d,climb) "?"
    set tdata(d,desc)  "?"

    catch {unset ::nodes(biker)}
    bind all <Escape> {}
    if {$destroy} {
	destroy $::Trace::W
    }
}
##+##########################################################################
#
# ::Trace::StartStop
#
# Toggles tracing animation. Also, allows restarting from where it left off.
#
proc ::Trace::StartStop {{stop 0}} {
    variable tdata
    variable W
    global trace state route

    after cancel $tdata(afterId)
    if {$stop || $tdata(anim)} {		;# We're currently tracing
	set tdata(anim) 0			;# Turn it off
	if {[winfo exists $W]} {
	    $W.buttons.stop config -text "Start Tracing"
	    $W.body.dist config -state normal
	    #$W.c itemconfig r -dash {}
	    #$W.c delete biker
	}
    } else {
	catch {$W.buttons.stop config -text "Stop Tracing"}
	$W.body.dist config -state disabled
	::Trace::DoTrace 1
    }
}
##+##########################################################################
#
# ::Trace::GetData
#
# Turns the current route info into a format easily useable for animating it.
#
proc ::Trace::GetData {{who root}} {
    variable tdata
    global nodes roads route
    global NR

    set tdata(reset)  0
    set tdata(xy)     {}
    set tdata(ll)     {}
    set tdata(dist)   {}
    set tdata(angle)  {}
    set tdata(ndist)  [list 0]
    set tdata(nclimb) [list 0]
    set tdata(ndesc)  [list 0]
    set tdata(nbad)   [list 0]
    set bad	      0
    set angle         0

    # Now get xy and dist between legs of all roads
    set from [lindex $route(nodes) 0]
    foreach rid $route(roads) to [lrange $route(nodes) 1 end] {
	foreach {. ldist climb desc} $NR($rid,$from,$to) break
	foreach {lat lon} [lrange $nodes($to) 2 3] break ;# Ending lat/lon

	foreach {ldist bad} [::BadMath::StillGood $ldist $bad] break
	foreach {climb bad} [::BadMath::StillGood $climb $bad] break
	foreach {desc  bad} [::BadMath::StillGood $desc  $bad] break

	# Running totals between nodes
	lappend tdata(ndist)  [expr {[lindex $tdata(ndist)  end] + $ldist}]
	lappend tdata(nclimb) [expr {[lindex $tdata(nclimb) end] + $climb}]
	lappend tdata(ndesc)  [expr {[lindex $tdata(ndesc)  end] + $desc}]
	lappend tdata(nbad)   [expr {[lindex $tdata(nbad)   end] || $bad}]

	set angle [eval ::Trace::GetAngle [lindex $nodes($from) 4] \
		       [lindex $nodes($to) 4]]

	set xy [lindex $roads($rid) 8]		;# Extra line XY positions
	if {$from != [lindex $roads($rid) 0]} {	;# Going in correct direction??
	    set xy [::Data::XYReverse $xy]	;# Nope, so reverse XY coords
	}
	set xy [concat $xy [int2lat $lat] [int2lat $lon]];# Add ending lat/lon

	if {$tdata(dist) eq {}} {		;# First entry
	    set p1 [lindex $nodes($from) 4]	;# Starting canvas location
	    lappend tdata(xy) $p1		;# Get all the legs of the road
	    lappend tdata(dist) 0
	}

	set temp {}
	set sum 0
	foreach {a1 a2 a3 b1 b2 b3} $xy {
	    set a [lat2int $a1 $a2 $a3]
	    set b [lat2int $b1 $b2 $b3]
	    set p2 [::Display::pos2canvas $who $a $b]
	    lappend tdata(xy) $p2		;# Canvas xy for this leg
	    lappend tdata(angle) $angle
	    lappend tdata(ll) $a $b

	    foreach {x1 y1} $p1 {x2 y2} $p2 break
	    set dist [expr {hypot(($x1-$x2), ($y1-$y2))}]
	    lappend temp $dist
	    set sum [expr {$sum + $dist}]

	    set p1 $p2
	}
	foreach dist $temp {
	    set dist [expr {$ldist * $dist / $sum}]
	    lappend tdata(dist) $dist
	}
	set from $to
    }

    set temp {}
    set sum 0
    foreach dist $tdata(dist) {
	set sum [expr {$sum + $dist}]
	lappend temp $sum
    }
    set tdata(dist) $temp
    set tdata(nbad) [concat [lrange $tdata(nbad) 1 end] $bad]
    lappend tdata(angle) $angle
    return ""
}
##+##########################################################################
#
# ::Trace::GetAngle -- returns angle from clockwise from horizontal
#
proc ::Trace::GetAngle {x0 y0 x1 y1} {
    set dx [expr {$x1 - $x0}]
    set dy [expr {$y1 - $y0}]

    set pi [expr {acos(-1)}]
    set radian [expr {atan2($dx,$dy)}]
    set degree [expr {$radian * 360 / 2 / $pi}]
    set degree [expr {450 - $degree}]
    while {$degree >= 360} { set degree [expr {$degree - 360}]}
    return $degree
}
##+##########################################################################
#
# ::Trace::Mile2Canvas
#
# Given a distance along the current route, returns the corresponding
# canvas position.
#
proc ::Trace::Mile2Canvas {mp} {
    variable tdata

    set angle1 [lindex $tdata(angle) 0]
    if {$mp == 0} {
	return [concat [lindex $tdata(xy) 0] $angle1]
    }

    set pos1  [lindex $tdata(xy)   0]
    set dist1 [lindex $tdata(dist) 0]
    foreach pos2 $tdata(xy) dist2 $tdata(dist) angle2 $tdata(angle) {
	if {$dist2 >= $mp} break
	if {abs($dist2 - $mp) < .0001} break
	set pos1 $pos2
	set dist1 $dist2
	set angle1 $angle2
    }
    set perc [expr {($mp - $dist1) / ($dist2 - $dist1)}]

    foreach {x1 y1} $pos1 {x2 y2} $pos2 break
    set x [expr {$x1 + $perc * ($x2 - $x1)}]
    set y [expr {$y1 + $perc * ($y2 - $y1)}]

    return [list $x $y $angle1]
}
##+##########################################################################
#
# ::Trace::Mile2Percentage
#
# Given a distance along the current route, returns the percentage
# along the road that spot is.
#
proc ::Trace::Mile2Data {mp} {
    variable tdata

    if {$mp == 0} { return 0 }

    set dist1  [lindex $tdata(ndist)  0]
    set climb1 [lindex $tdata(nclimb) 0]
    set desc1  [lindex $tdata(ndist)  0]
    set bad1   [lindex $tdata(nbad)   0]
    foreach dist2 $tdata(ndist) climb2 $tdata(nclimb) desc2 \
	$tdata(ndesc) bad2 $tdata(nbad) {
	if {$dist2 >= $mp} break
	if {abs($dist2 - $mp) < .0001} break
	set dist1  $dist2
	set climb1 $climb2
	set desc1  $desc2
	set bad1   $bad2
    }
    if {$bad1} {set bad "+?"} {set bad {}}

    set perc [expr {($mp - $dist1) / ($dist2 - $dist1)}]
    set climb [expr {round($climb1 + $perc * ($climb2 - $climb1))}]
    set desc  [expr {round($desc1  + $perc * ($desc2  - $desc1))}]

    set dist  $mp$bad
    set climb $climb$bad
    set desc  $desc$bad

    return [list $perc $dist $climb $desc]
}
##+##########################################################################
#
# ::Trace::Units -- handles changing display units
#
proc ::Trace::Units {} {
    variable W
    if {[winfo exists $W]} {
	set dlabel [lindex [::Data::Label 0 dist 3] 1]
	set clabel [lindex [::Data::Label 0 climb 3] 1]
	$W.body.udist config -text $dlabel
	$W.body.uclimb config -text $clabel
	$W.body.udesc config -text $clabel
    }
}
##+##########################################################################
#
# ::Trace::Biker -- draws a biker icon for trace animation
#
proc ::Trace::Biker {w x y angle {yflip 0}} {
    variable tdata

    if {[$w find withtag biker] eq {}} {::Trace::DrawBiker $w 1}

    # Move to (x,y)
    foreach {Ox Oy} $tdata($w,Oxy) break
    set tdata($w,Oxy) [list $x $y]
    set dx [expr {$x - $Ox}]
    set dy [expr {$y - $Oy}]
    $w move biker $dx $dy

    # Rotate to angle
    foreach {Ox Oy} $tdata($w,Oxy) break
    while {$angle > 360} { set angle [expr {$angle - 360}] }
    while {$angle < 0} { set angle [expr {$angle + 360}] }

    # Avoid upside down image by flipping it if leaning over too far,
    # but avoid too much flipping for near vertical angles.
    set vert 20
    if {$angle > 90+$vert && $angle < 270-$vert} {
	set flip 1
    } elseif {$angle < 90-$vert || $angle > 270+$vert} {
	set flip 0
    } else {
	set flip $tdata($w,flip)
    }

    if {$flip != $tdata($w,flip)} {		;# Flip if needed
	$w scale biker $Ox $Oy -1 1
	set tdata($w,flip) $flip
	set tdata($w,angle) [expr {180 - $tdata($w,angle)}]
    }
    if {$tdata($w,angle) ne $angle} {		;# Rotate if needed
	if {$tdata($w,yflip)} {
	    $w scale biker $Ox $Oy 1 -1
	    set tdata($w,yflip) 0
	}
	::Trace::RotateItem $w biker $Ox $Oy [expr {$angle - $tdata($w,angle)}]
	set tdata($w,angle) $angle
    }
    if {$yflip != $tdata($w,yflip)} {		;# Flip in y axis
	$w scale biker $Ox $Oy 1 -1
	set tdata($w,yflip) $yflip
    }
}
##+##########################################################################
#
# Trace::DrawBiker -- draws the biker image at 0,0
#
proc ::Trace::DrawBiker {w onoff} {
    variable tdata

    if {! $onoff} {
	$w delete biker
	return
    }

    set XY {
	{wheel1 2 oval {-16 -17 -4 -4}}
	{wheel2 2 oval {7 -17 20 -4}}
	{head   0 oval {2 -34 8 -28}}
	{body   4 line {2 -8 2 -16 -6 -21 1 -27}}
	{arm    3 line {2 -27 5 -22 11 -22}}
    }
    set clr black
    foreach xy $XY {
	foreach {tag width type xy} $xy break
	if {$type eq "oval"} {
	    set type poly
	    set etc [list -fill {} -outline $clr -smooth 1]
	    if {$tag eq "head"} { lappend etc -fill $clr}
	    set xy [eval ::Trace::Oval2Poly $xy 16]
	} else {
	    set etc [list -capstyle round -joinstyle round -fill $clr]
	}
	lappend tag biker
	eval [list $w create $type $xy -width $width -tag $tag] $etc
    }
    set tdata($w,angle) 0
    set tdata($w,Oxy) [list 0 0]
    set tdata($w,Oxy) [list 2 -3]
    set tdata($w,flip) 0
    set tdata($w,yflip) 0
}
##+##########################################################################
#
# ::Trace::Oval2Poly -- returns coordinates for a poly that's a circle
#
proc ::Trace::Oval2Poly {x0 y0 x1 y1 n} {
    set xm [expr {($x0+$x1)/2.0}]
    set ym [expr {($y0+$y1)/2.0}]
    set rx [expr {$xm-$x0}]
    set ry [expr {$ym-$y0}]
    if {$n == 0} {
	set n [expr {round(($rx+$ry) * 0.5)}]
    }
    set step [expr {atan(1) * 8/$n}]
    set xy ""
    set th [expr {atan(1)*6}] ;#top
    for {set i 0} {$i < $n} {incr i} {
	lappend xy [expr {$xm + $rx*cos($th)}] [expr {$ym + $ry*sin($th)}]
	set th [expr {$th + $step}]
    }
    return $xy
}
##+##########################################################################
#
# ::Trace::RotateItem -- rotates an item by angle degrees clockwise
#
proc ::Trace::RotateItem {w tagOrId Ox Oy angle} {
    set angle [expr {$angle * atan(1) * 4 / 180.0}] ;# Radians
    foreach id [$w find withtag $tagOrId] {     ;# Do each component separately
	set xy {}
	foreach {x y} [$w coords $id] {
	    # rotates vector (Ox,Oy)->(x,y) by angle clockwise

	    set x [expr {$x - $Ox}]             ;# Shift to origin
	    set y [expr {$y - $Oy}]

	    set xx [expr {$x * cos($angle) - $y * sin($angle)}] ;# Rotate
	    set yy [expr {$x * sin($angle) + $y * cos($angle)}]

	    set xx [expr {$xx + $Ox}]           ;# Shift back
	    set yy [expr {$yy + $Oy}]
	    lappend xy $xx $yy
	}
	$w coords $id $xy
    }
}
##+##########################################################################
#
# ::Trace::DialogAnimation -- Drives our trace animation
#
proc ::Trace::DialogAnimation {idx} {
    #${::Trace::W}.c itemconfig r -dash $::Trace::Dash([expr {$idx % 6}])
    foreach {x y a yflip} [::Trace::_GetDialogAnimationXYA $idx] break
    ::Trace::Biker ${::Trace::W}.c $x $y $a $yflip
}
##+##########################################################################
#
# ::Trace::_GetDialogAnimationXYA -- Gets coordinates for animation update
#
proc ::Trace::_GetDialogAnimationXYA {idx} {

    lassign [${::Trace::W}.c coords r] _x(0) _y(0) _x(1) _y(1) _x(2) _y(2) _x(3) _y(3)
    set sideLen [expr {hypot($_x(1)-$_x(0),$_y(1)-$_y(0))}]
    set stepSize 10
    set stepsPerSide [expr {2 + int($sideLen/$stepSize)}]

    set whichSide [expr {($idx%(3*$stepsPerSide))/$stepsPerSide}]
    set sideIdx [expr {$idx % $stepsPerSide}]
    set a $whichSide
    set b [expr {$a + 1}]

    if {$sideIdx == $stepsPerSide-1} {             ;# Turning the corner special case
	set angle [lindex {0 -120 120} $whichSide]
	set yflip [expr {$whichSide != 0}]
	return [list $_x($b) $_y($b) $angle $yflip]
    }

    set V [::Data::VReScale [::Data::VSub [list $_x($b) $_y($b)] [list $_x($a) $_y($a)]] 1]
    set xy [::Data::VAdd [list $_x($a) $_y($a)] $V [expr {$stepSize*$sideIdx}]]
    set angle [lindex {-60 60 180} $whichSide]
    set yflip [expr {$whichSide == 2}]
    return [concat $xy $angle $yflip]
}
##+##########################################################################
#
# ::Trace::DrawAnimation -- Draws what we'll animate
#
proc ::Trace::DrawAnimation {WC} {
    set _x(0) 30    ;set _x(1) 55   ;set _x(2) 80
    set _y(0) 95    ;set _y(1) 35   ;set _y(2) 95

    $WC delete all
    $WC create line $_x(0) $_y(0) $_x(1) $_y(1) $_x(2) $_y(2) $_x(0) $_y(0) \
	-width 3 -fill blue -tag r
    $WC create oval [::Display::MakeBox [list $_x(0) $_y(0)] 10] -fill yellow
    $WC create oval [::Display::MakeBox [list $_x(1) $_y(1)] 10] -fill yellow
    $WC create oval [::Display::MakeBox [list $_x(2) $_y(2)] 10] -fill yellow

    ::Trace::DialogAnimation 0
    return
    $WC create line 20 100 50 40 80 100 20 100 -fill blue -width 3 -tag r
    $WC create oval 10 90 30 110 -fill yellow
    $WC create oval 40 30 60 50 -fill yellow
    $WC create oval 70 90 90 110 -fill yellow
}
##+##########################################################################
#
# ::Trace::VarTrace -- Handles trace on the distance variable
#
proc ::Trace::VarTrace {var1 var2 op} {
    variable tdata

    after cancel $tdata(afterId)
    if {! [winfo exists $::Trace::W]} return
    if {$tdata(anim)} return
    if {! [string is double -strict $tdata(d,miles)]} return
    if {$tdata(d,miles) < 0} { set tdata(d,miles) 0 }
    if {$tdata(d,miles) > 9999} { set tdata(d,miles) 9999 }
    set tdata(afterId) [after 500 ::Trace::_VarTraceAfterHandler]
}
##+##########################################################################
#
# ::Trace::_VarTraceAfterHandler -- Updates trace to be at distance
# specified by user. Done after a delay to avoid hysteresis.
#
proc ::Trace::_VarTraceAfterHandler {} {
    variable tdata

    after cancel $tdata(afterId)
    if {! [winfo exists $::Trace::W]} return
    if {$tdata(anim)} return
    if {! [string is double -strict $tdata(d,miles)]} return

    if {$tdata(d,miles) < 0} { set tdata(d,miles) 0 }
    if {$tdata(d,miles) > [lindex $tdata(dist) end]} {
	set tdata(d,miles) [Round1 [lindex $tdata(dist) end]]
    }
    set tdata(startat) $tdata(d,miles)
    ::Trace::_DrawBikerAt $tdata(d,miles) 1
}
## EON TRACE
## BON CONFIG
##+##########################################################################
#
# ::Config::Copy -- Copies the cdata values into the state array or vice versa.
#
#  factory == as set in this file
#  zone    == after reading <zone>/klimb.rc
#  user    == after reading klimb.rc
#  cdata   == values for dialog box
#  backup  == so user can press cancel
#  state   == actively used values

proc ::Config::Copy {dir {filter {}}} {
    variable cdata
    variable backup
    variable factory
    variable zone
    variable user
    global state

    set names [array names factory]		;# Only do "official" entries
    if {$filter ne {}} {			;# Apply a filter list
	set names2 {}
	foreach n $filter {
	    if {[lsearch $names $n] != -1} {	;# Validate filter entry
		lappend names2 $n
	    }
	}
	set names $names2
    }

    foreach arr $names {
	if {$dir eq "u2s"} {			;# User => state: reading rc
	    set state($arr) $user($arr)
	} elseif {$dir eq "s2c"} {		;# State => dialog: dialog init
	    set cdata($arr) $state($arr)
	} elseif {$dir eq "z2c"} {		;# Zone => dialog: default btn
	    set cdata($arr) $zone($arr)
	} elseif {$dir eq "s2b"} {		;# State => backup: safety
	    set backup($arr) $state($arr)
	} elseif {$dir eq "b2s"} {		;# Backup => state: safety
	    set state($arr) $backup($arr)
	} elseif {$dir eq "c2s"} {		;# Dialog => state: apply/done
	    set state($arr) $cdata($arr)
	}
    }
}
##+##########################################################################
#
# ::Config::Dialog -- Handles the config dialog box.
#
proc ::Config::Dialog {{tab ""}} {
    variable cdata
    variable W
    variable TAB
    variable dialRedraw
    global state trails

    ::Config::Copy s2c				;# Snapshot state into our world

    set W .config
    destroy $W
    toplevel $W
    ::Display::TileBGFix $W
    wm withdraw $W
    wm title $W "$::state(progname) Customize"
    wm transient $W .
    wm protocol $W WM_DELETE_WINDOW [list ::Config::Done c]

    # Buttons
    set WB $W.buttons
    ::ttk::frame $WB
    ::ttk::button $W.ok     -text "OK"	    -width 10 \
	-command [list ::Config::Done o]
    ::ttk::button $W.apply  -text "Apply"   -width 10 \
	-command [list ::Config::Done a]
    ::ttk::button $W.reset  -text "Default" -width 10 \
	-command [list ::Config::Done r]
    ::ttk::button $W.cancel -text "Dismiss" -width 10 \
	-command [list ::Config::Done c]
    pack $W.cancel $W.reset $W.apply $W.ok -side right -padx 10 -pady 5 -in $WB

    # Tile notebook to hold everything
    set WNB "$W.nb"
    ttk::notebook $WNB -padding 6
    ttk::notebook::enableTraversal $WNB

    pack $WB -side bottom -fill x -padx 10 -pady {0 10}
    pack $WNB -side top -padx 10 -pady 10 -fill both -expand 1

    #
    # Section 1: Road colors
    #
    set WROAD "$WNB.s1"
    ::ttk::frame $WROAD -pad 10
    $WNB add $WROAD -text "Road Display"

    ::ttk::label $WROAD.title -text "Road Color and Width" -font bigFont \
	-anchor c
    ::ttk::label $WROAD.l2 -text "Color"
    ::ttk::label $WROAD.l3 -text "Width"
    ::ttk::label $WROAD.l4 -text "Selected\nColor"
    ::ttk::label $WROAD.l5 -text "Selected\nWidth"
    grid $WROAD.title - - - - -sticky ew
    grid x $WROAD.l2 $WROAD.l3 $WROAD.l4 $WROAD.l5 -sticky s

    for {set idx 0} {[info exists trails(type,$idx)]} {incr idx} {
	set Y [binary format "c" [expr {$idx + 97}]]
	::ttk::label $WROAD.l${Y}1 -text $trails(type,$idx) -anchor e
	::Config::ColorWidget $WROAD.b${Y}2 ::Config::cdata(r,0,$idx,color)
	::ttk::entry $WROAD.e${Y}3 -width 6 -justify center \
	    -textvariable ::Config::cdata(r,0,$idx,width) \
	    -validate key -validatecommand {string is double %P}
	::Config::ColorWidget $WROAD.b${Y}4 ::Config::cdata(r,1,$idx,color)
	::ttk::entry $WROAD.e${Y}5 -width 6 -justify center \
	    -textvariable ::Config::cdata(r,1,$idx,width) \
	    -validate key -validatecommand {string is double %P}
	grid $WROAD.l${Y}1 $WROAD.b${Y}2 $WROAD.e${Y}3 $WROAD.b${Y}4 \
	    $WROAD.e${Y}5 -sticky ns -padx 5
	grid configure $WROAD.l${Y}1 -sticky e
    }
    ::ttk::button $WROAD.page -text "Page Default" -takefocus 0 \
	-command [list ::Config::PageDefaults $WROAD]
    grid $WROAD.page - - - - -pady 20
    grid rowconfigure $WROAD 100 -weight 1

    #
    # Section 2: Node colors
    #
    set WNODE "$WNB.s2"
    ::ttk::frame $WNODE -pad 10
    $WNB add $WNODE -text "Node Display"

    ::ttk::label $WNODE.title -text "Node Color and Width" -font bigFont \
	-anchor c
    ::ttk::label $WNODE.a2 -text "Normal"
    ::ttk::label $WNODE.a4 -text "Size"

    ::ttk::label $WNODE.b1 -text "Node" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.b2 ::Config::cdata(n,0,color)
    ::ttk::entry $WNODE.b4 -width 6 -justify center \
	-textvariable ::Config::cdata(n,size) \
	-validate key -validatecommand {string is double %P}

    ::ttk::label $WNODE.bb1 -text "Selected Node" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.bb2 ::Config::cdata(n,1,color)

    ::ttk::label $WNODE.c1 -text "Point of Interest" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.c2 ::Config::cdata(p,color)
    ::ttk::entry $WNODE.c4 -width 6 -justify center \
	-textvariable ::Config::cdata(p,size) \
	-validate key -validatecommand {string is double %P}

    ::ttk::label $WNODE.d1 -text "Geocache" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.d2 ::Config::cdata(g,color)
    ::ttk::entry $WNODE.d4 -width 6 -justify center \
	-textvariable ::Config::cdata(g,size) \
	-validate key -validatecommand {string is double %P}

    ::ttk::label $WNODE.e1 -text "Mileposts" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.e2 ::Config::cdata(m,color)
    ::ttk::entry $WNODE.e4 -width 6 -justify center \
	-textvariable ::Config::cdata(m,size) \
	-validate key -validatecommand {string is double %P}
    ::ttk::label $WNODE.f1 -text "Annotation" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.f2 ::Config::cdata(a,color)
    ::ttk::label $WNODE.g1 -text "Arrows" -width 15 -anchor e
    ::Config::ColorWidget $WNODE.g2 ::Config::cdata(arrow,.c,color)
    ::ttk::entry $WNODE.g4 -width 6 -justify center \
	-textvariable ::Config::cdata(arrow,.c,width) \
	-validate key -validatecommand {string is double %P}

    ::ttk::button $WNODE.page -text "Page Default" -takefocus 0 \
	-command [list ::Config::PageDefaults $WNODE]

    grid $WNODE.title - - - -sticky ew
    grid x $WNODE.a2 $WNODE.a4 -sticky s
    grid $WNODE.b1 $WNODE.b2 $WNODE.b4 -sticky ns -padx 5
    grid $WNODE.bb1 $WNODE.bb2 -sticky ns -padx 5
    grid $WNODE.f1 $WNODE.f2 -sticky ns -padx 5
    grid $WNODE.c1 $WNODE.c2 $WNODE.c4 -sticky ns -padx 5
    grid $WNODE.d1 $WNODE.d2 $WNODE.d4 -sticky ns -padx 5
    grid $WNODE.e1 $WNODE.e2 $WNODE.e4 -sticky ns -padx 5
    grid $WNODE.g1 $WNODE.g2 $WNODE.g4 -sticky ns -padx 5
    grid $WNODE.page - - - -pady 20
    grid configure $WNODE.b1 -sticky e
    #grid columnconfigure $WNODE 4 -weight 1
    grid rowconfigure $WNODE 100 -weight 1

    #
    # Fonts
    #
    set WFONT "$WNB.s3"
    set ::WFONT $WFONT
    ::ttk::frame $WFONT -pad 10
    $WNB add $WFONT -text "Fonts"

    ::ttk::label $WFONT.title -text "Fonts" -font bigFont -anchor c
    grid $WFONT.title -

    ::ttk::label $WFONT.n1 -text "Node font" -anchor e
    ::Config::FontWidget $WFONT.n2 ::Config::cdata(n,font)
    ::ttk::checkbutton $WFONT.n3 -text "Hide text" \
	-variable ::Config::cdata(n,hide)
    ::ttk::label $WFONT.h1 -text "Help font" -anchor e
    ::Config::FontWidget $WFONT.h2 ::Config::cdata(help,font)
    ::ttk::label $WFONT.t1 -text "Tooltip font" -anchor e
    ::Config::FontWidget $WFONT.t2 ::Config::cdata(balloon,font)
    ::ttk::label $WFONT.m1 -text "Milepost font" -anchor e
    ::Config::FontWidget $WFONT.m2 ::Config::cdata(m,font)
    ::ttk::label $WFONT.a1 -text "Annotation font" -anchor e
    ::Config::FontWidget $WFONT.a2 ::Config::cdata(a,font)
    ::ttk::label $WFONT.d1 -text "Description font" -anchor e
    ::Config::FontWidget $WFONT.d2 ::Config::cdata(desc,font)
    ::ttk::label $WFONT.dd1 -text "Description Title font" -anchor e
    ::Config::FontWidget $WFONT.dd2 ::Config::cdata(desc,titleFont)

    ::ttk::button $WFONT.page -text "Page Default" -takefocus 0 \
	-command [list ::Config::PageDefaults $WFONT]
    grid $WFONT.n1 $WFONT.n2 $WFONT.n3 -sticky ew -row 2
    grid config $WFONT.n3 -padx {10 0}
    grid $WFONT.h1 $WFONT.h2 -sticky ew
    grid $WFONT.t1 $WFONT.t2 -sticky ew
    grid $WFONT.a1 $WFONT.a2 -sticky ew
    grid $WFONT.m1 $WFONT.m2 -sticky ew
    grid $WFONT.d1 $WFONT.d2 -sticky ew
    grid $WFONT.dd1 $WFONT.dd2 -sticky ew
    grid $WFONT.page - -pady 20

    grid rowconfigure $WFONT 1 -minsize 20
    grid rowconfigure $WFONT 100 -weight 1

    #
    # Description columns w/ swaplist
    #
    if {[::Data::CanDo swaplist]} {
	set WDESC "$WNB.s4"
	::ttk::frame $WDESC -pad 10
	$WNB add $WDESC -text "Description"

	::ttk::label $WDESC.title -text "Route Description Columns" \
	    -font bigFont -anchor c

	set all [::Description::GetColumns 1]
	set selected [::Description::GetColumns 0]
	::swaplist::swaplist $WDESC.swap ::Config::cdata(route,selected) \
	    $all $selected -embed -default $::Config::zone(route,selected)
	::ttk::button $W.routeDefault -text "Page Default" -takefocus 0 \
	    -command [list ::swaplist::Reset $WDESC.swap]

	grid $WDESC.title
	grid $WDESC.swap
	grid $W.routeDefault -in $WDESC -pady 20

	grid rowconfigure $WDESC 100 -weight 1
    }

    #
    # Route Profile
    #
    set WPRO "$WNB.s5"
    set ::WPRO $WPRO

    ::ttk::frame $WPRO -pad 10
    $WNB add $WPRO -text "Profile"

    ::ttk::label $WPRO.title -text "Route Profile" -font bigFont -anchor c
    ::ttk::labelframe $WPRO.3d -text "3D Graph Offset"
    set dialRedraw [::Display::RibbonWidget $WPRO.3d ::Config::cdata(pro,pp) \
			::Config::cdata(pro,len)]
    ::ttk::button $WPRO.page -text "Page Default" -takefocus 0 \
    	-command [list ::Config::PageDefaults $WPRO $dialRedraw]

    grid $WPRO.title  -sticky ew
    grid $WPRO.3d -row 2 -ipadx 5 -sticky ns
    grid $WPRO.page -pady 20
    grid rowconfigure $WPRO 1 -minsize 20
    grid rowconfigure $WPRO 100 -weight 1

    #
    # Startup
    #
    set WSTART "$WNB.s6"
    ::ttk::frame $WSTART -pad 10
    $WNB add $WSTART -text "Display"

    ::ttk::label $WSTART.title -text "Initial Display" -font bigFont -anchor c
    ::ttk::label $WSTART.a1 -text "Button Bar" -anchor e
    tk_optionMenu $WSTART.a2 ::Config::cdata(init,bbar) Images Text Both None
    $WSTART.a2 config -relief sunken -bg white -activebackground white \
	-highlightthickness 0
    ::ttk::label $WSTART.b1 -text "Status Bar" -anchor e
    tk_optionMenu $WSTART.b2 ::Config::cdata(init,sbar) Visible Hidden
    $WSTART.b2 config -relief sunken -bg white -activebackground white \
	-highlightthickness 0
    ::ttk::label $WSTART.c1 -text "Mileposts" -anchor e
    tk_optionMenu $WSTART.c2 ::Config::cdata(init,milepost) On Off
    $WSTART.c2 config -relief sunken -bg white -activebackground white \
	-highlightthickness 0
    ::ttk::label $WSTART.d1 -text "Arrows" -anchor e
    tk_optionMenu $WSTART.d2 ::Config::cdata(init,arrow) On Off
    $WSTART.d2 config -relief sunken -bg white -activebackground white \
	-highlightthickness 0
    #::ttk::label $WSTART.e1 -text "Go & End Arrows" -anchor e
    #tk_optionMenu $WSTART.e2 ::Config::cdata(arrow,stop&go) Both Go End None
    #$WSTART.e2 config -relief sunken -bg white -activebackground white \
    #	-highlightthickness 0

    ::ttk::button $WSTART.page -text "Page Default" -takefocus 0 \
	-command [list ::Config::PageDefaults $WSTART]

    grid $WSTART.title - -sticky ew -row 0
    grid $WSTART.a1 $WSTART.a2 -sticky news -padx 5 -row 2
    grid $WSTART.b1 $WSTART.b2 -sticky news -padx 5
    grid $WSTART.c1 $WSTART.c2 -sticky news -padx 5
    grid $WSTART.d1 $WSTART.d2 -sticky news -padx 5
    #grid $WSTART.e1 $WSTART.e2 -sticky news -padx 5
    grid $WSTART.page - -pady 20

    grid rowconfigure $WSTART 1 -minsize 20
    grid rowconfigure $WSTART 100 -weight 1

    #
    # Calorie Calculator
    #
    set WCAL "$WNB.s7"
    ::ttk::frame $WCAL -pad 10
    $WNB add $WCAL -text "Calories"

    ::ttk::label $WCAL.title -text "Calorie Calculator" -font bigFont -anchor c

    ::ttk::label $WCAL.a1 -text "Rider's Weight (lb)" -anchor e
    ::ttk::entry $WCAL.a2 -textvariable ::Config::cdata(calorie,human) \
	-width 5 -justify center \
	-validate key -validatecommand {string is integer %P}
    ::ttk::label $WCAL.b1 -text "Bike's Weight (lb)" -anchor e
    ::ttk::entry $WCAL.b2 -textvariable ::Config::cdata(calorie,bike) \
	-width 5 -justify center \
	-validate key -validatecommand {string is integer %P}
    ::ttk::label $WCAL.c1 -text "Bike Position" -anchor e
    eval tk_optionMenu $WCAL.c2 ::Config::cdata(calorie,position) \
	$::Power::FrontalArea(labels)

    ::ttk::button $WCAL.page -text "Page Default" -takefocus 0 \
	-command [list ::Config::PageDefaults $WCAL]

    grid $WCAL.title - -sticky ew -row 0
    grid $WCAL.a1 $WCAL.a2 -sticky news -padx 5 -row 2
    grid $WCAL.b1 $WCAL.b2 -sticky news -padx 5
    grid $WCAL.c1 $WCAL.c2 -sticky news -padx 5
    grid $WCAL.page - -pady 20

    grid rowconfigure $WCAL 1 -minsize 20
    grid rowconfigure $WCAL 100 -weight 1

    #
    # Miscellaneous stuff
    #
    set WMISC "$WNB.s8"
    ::ttk::frame $WMISC -pad 10
    $WNB add $WMISC -text "Miscellaneous"

    ::ttk::label $WMISC.title -text "Miscellaneous" -font bigFont -anchor c
    ::ttk::label $WMISC.a1 -text "Starting zone" -anchor e
    eval tk_optionMenu $WMISC.a2 ::Config::cdata(zone,default) $::state(zone,names)
    $WMISC.a2 config -relief sunken -bg white -activebackground white \
	-highlightthickness 0

    ::ttk::label $WMISC.b1 -text "Starting region" -anchor e
    set all [concat "(none)" $::region(names)]
    eval tk_optionMenu $WMISC.b2 ::Config::cdata(region,default) $all
    $WMISC.b2 config -relief sunken \
	-bg white -activebackground white -highlightthickness 0

    ::ttk::label $WMISC.bb1 -text "Milepost Interval" -anchor e
    tk_optionMenu $WMISC.bb2 ::Config::cdata(m,interval) "Auto" 1 5 10 20 25 50
    $WMISC.bb2 config -relief sunken \
	-bg white -activebackground white -highlightthickness 0

    ::ttk::label $WMISC.bbb1 -text "Scroll Speed" -anchor e
    tk_optionMenu $WMISC.bbb2 ::Config::cdata(dragGain) \
	"Very slow" Slow Medium Fast "Very Fast"
    $WMISC.bbb2 config -relief sunken \
	-bg white -activebackground white -highlightthickness 0

    ::ttk::label $WMISC.c1 -text "Starting size" -anchor e
    ::ttk::entry $WMISC.c2 -width 30 -justify center \
	-textvariable ::Config::cdata(start,size)
    ::ttk::button $WMISC.c3 -takefocus 0 -width 15 \
	-image ::img::star -command [list ::Config::SetStartSize $WMISC.c2]

    ::ttk::label $WMISC.f1 -text "Tooltip delay (ms)" -anchor e
    ::ttk::entry $WMISC.f2 -width 30 -justify center \
	-textvariable ::Config::cdata(balloon,delay) -validate key \
	-validatecommand {string is double %P}

    ::ttk::label $WMISC.g1 -text "Display Units" -anchor e
    ::ttk::frame $WMISC.g2 -borderwidth 2 -relief sunken
    ::ttk::radiobutton $WMISC.g2.d -text Default -value default \
	-variable ::Config::cdata(units,external)
    ::ttk::radiobutton $WMISC.g2.g -text English -value english \
	-variable ::Config::cdata(units,external)
    ::ttk::radiobutton $WMISC.g2.m -text Metric -value metric \
	-variable ::Config::cdata(units,external)

    ::ttk::label $WMISC.h1 -text "Go & End Signs" -anchor e
    ::ttk::frame $WMISC.h2 -borderwidth 2 -relief sunken
    set ::w $WMISC.h2.a
    ::ttk::radiobutton $WMISC.h2.a -text Both -value Both \
	-variable ::Config::cdata(arrow,stop&go)
    ::ttk::radiobutton $WMISC.h2.b -text Go -value Go \
	-variable ::Config::cdata(arrow,stop&go)
    ::ttk::radiobutton $WMISC.h2.c -text End -value End \
	-variable ::Config::cdata(arrow,stop&go)
    ::ttk::radiobutton $WMISC.h2.d -text None -value None \
	-variable ::Config::cdata(arrow,stop&go)

    ::ttk::button $WMISC.page -text "Page Default" -takefocus 0 \
	-command [list ::Config::PageDefaults $WMISC]

    grid $WMISC.title - -sticky ew -row 0
    grid $WMISC.a1 $WMISC.a2 -sticky news -padx 5 -row 2
    grid $WMISC.b1 $WMISC.b2 -sticky news -padx 5
    grid $WMISC.bb1 $WMISC.bb2 -sticky news -padx 5
    grid $WMISC.bbb1 $WMISC.bbb2 -sticky news -padx 5
    grid $WMISC.c1 $WMISC.c2 -sticky news -padx 5
    grid $WMISC.f1 $WMISC.f2 -sticky news -padx 5
    grid $WMISC.h1 $WMISC.h2 -sticky news -padx 5
    pack $WMISC.h2.a $WMISC.h2.b $WMISC.h2.c $WMISC.h2.d -side left -expand 1
    grid $WMISC.g1 $WMISC.g2 -sticky news -padx 5
    pack $WMISC.g2.d $WMISC.g2.g $WMISC.g2.m -side left -expand 1

    pack $WMISC.c3 -in $WMISC.c2 -side right -fill y
    grid $WMISC.page - -pady 20

    grid rowconfigure $WMISC 1 -minsize 20
    grid rowconfigure $WMISC 100 -weight 1

    ################################################################
    ################################################################

    if {[::Data::CanDo tcl8.5]} {		;# Tcl 8.5 has new "grid anchor"
	foreach w [winfo child $WNB] {
	    grid anchor $w c
	}
    }

    #
    # Done with tabs
    #
    if {$W ne ""} {
	::Display::CenterWindow $W
	wm deiconify $W
    }
    if {$tab ne ""} { set TAB $tab }
    $WNB select $TAB
    bind $W <Key> ::Config::Validate
}
proc ::Config::CleanupScale {idx val} {
    set ::Config::cdata($idx) [expr {round($val)}]
}
##+##########################################################################
#
# ::Config::Validate -- turns ok & apply buttons on when dialog is valid
#
proc ::Config::Validate {} {
    variable W
    variable cdata

    set dstate normal
    set anames [concat [array names cdata ?,size] [array names cdata r*,width] \
		   balloon,delay]
    foreach arr $anames {
	if {! [string is double -strict $cdata($arr)]} {
	    set dstate disabled
	    break
	}
    }
    $W.ok config -state $dstate
    $W.apply config -state $dstate
}
##+##########################################################################
#
# ::Config::DefaultRC -- initializes rc values to factory default.
#
proc ::Config::DefaultRC {} {
    variable factory
    global state

    # R|N "highlight level" "road type"
    set factory(r,0,0,color) blue		;# Road color
    set factory(r,0,1,color) red4		;# Dirt road color
    set factory(r,0,2,color) darkblue		;# Major road color
    set factory(r,0,3,color) red		;# Restricted road color
    set factory(r,0,4,color) cyan4		;# User defined road
    set factory(r,0,5,color) \#ff8040		;# Single track
    set factory(r,0,6,color) red		;# Fire break
    set factory(r,0,7,color) \#d65afa		;# Paved fire road
    set factory(r,0,8,color) \#0080ff		;# Bike path
    set factory(r,0,9,color) blue		;# Zoom
    set factory(r,0,10,color) \#d26946		;# Debug
    set factory(r,0,0,width) 5
    set factory(r,0,1,width) 5
    set factory(r,0,2,width) 5
    set factory(r,0,3,width) 5
    set factory(r,0,4,width) 5
    set factory(r,0,5,width) 5
    set factory(r,0,6,width) 5
    set factory(r,0,7,width) 5
    set factory(r,0,8,width) 5
    set factory(r,0,9,width) 6
    set factory(r,0,10,width) 6

    set factory(r,1,0,color) magenta
    set factory(r,1,1,color) orange
    set factory(r,1,2,color) magenta
    set factory(r,1,3,color) magenta ;# purple
    set factory(r,1,4,color) magenta
    set factory(r,1,5,color) magenta ;# \#ff9968
    set factory(r,1,6,color) magenta
    set factory(r,1,7,color) magenta
    set factory(r,1,8,color) purple
    set factory(r,1,9,color) magenta
    set factory(r,1,10,color) purple
    set factory(r,1,0,width) 6
    set factory(r,1,1,width) 6
    set factory(r,1,2,width) 7
    set factory(r,1,3,width) 6
    set factory(r,1,4,width) 6
    set factory(r,1,5,width) 6
    set factory(r,1,6,width) 6
    set factory(r,1,7,width) 6
    set factory(r,1,8,width) 6
    set factory(r,1,9,width) 6
    set factory(r,1,10,width) 6

    # Node configuration
    set factory(n,font) {Helvetica 6}		;# Node font
    set factory(n,size)  10			;# Size of a node
    set factory(n,0,color) yellow		;# Node color
    set factory(n,1,color) magenta		;# Part of the route
    set factory(n,start,color) red		;# Start of the route
    set factory(n,end,color) cyan		;# End of the route
    set factory(n,hide) 0			;# Hide text

    # Balloon highlighting values
    foreach arr [array names factory *,color] {
	foreach {. . which} [split $arr ","] break
	set factory(r,balloon,$which,color) red
	set factory(r,balloon,$which,width) 10
    }
    set factory(n,balloon,color) \#FF0080

    # Points of Interest stuff
    set factory(p,size) 10
    set factory(p,color) red

    # GPS geocache and waypoint stuff
    set factory(g,size) 7
    set factory(g,color) magenta
    set factory(g,fill) white
    set factory(w,size) 7
    set factory(w,color) cyan
    set factory(w,fill) black

    # GPS Track and hill stuff
    set factory(trk,color) yellow
    set factory(trk,climb) cyan
    set factory(trk,descent) purple

    # Annotation stuff
    set factory(a,color) lightyellow
    set factory(a,font) {Helvetica 8}

    # Description stuff
    set factory(desc,font) {Helvetica 8}
    set factory(desc,titleFont) {Helvetica 12 bold}

    # Milepost
    set factory(m,color) red ;# \#fc766c
    set factory(m,size) 8
    set factory(m,font) {Helvetica 6}
    set factory(m,interval) "Auto"

    # Printer stuff
    #set factory(printer,width,old) 2870
    #set factory(printer,height,old) 3840
    set factory(printer,width,user) ?
    set factory(printer,height,user) ?

    # Miscellaneous stuff
    set factory(start,size) "? x ?"
    set factory(help,font) {Helvetica 10}
    set factory(balloon,font) {Helvetica 8}
    set factory(balloon,delay) 500

    # 3D-Profile
    set factory(pro,len) 10
    set factory(pro,pp) 45
    set factory(grad,clr) cyan

    # Zone stuff
    set factory(zone,default) "San Francisco Bay Area"
    set factory(mag,default)    3
    set factory(region,default) "(none)"

    # Metric versus english, default == use internal units
    set factory(units,external) default

    # Route description columns
    set factory(route,all) [list Turn Arrow "Node ID" At "Distance To Next" \
				"Distance So Far" "Climb To Next" \
				"Climb So Far" "Descent To Next" \
				"Descent So Far" Altitude \
				"10 mph" "15 mph" "20 mph" "25 mph" "30 mph"]
    set factory(route,selected) [list Turn At "Distance To Next" \
				     "Distance So Far" "Climb To Next" \
				     "Climb So Far" Altitude \
				     "10 mph" "15 mph" "20 mph"]

    set factory(zoom,maxRendered) 200

    # Arrow stuff
    set factory(arrow,stop&go) Both
    set factory(arrow,.c,color) black
    set factory(arrow,.c,offset) 20
    set factory(arrow,.c,dist) 30
    set factory(arrow,.c,width) 5
    set factory(arrow,.c,shape) {20 25 10}
    set factory(arrow,.zoom.c,color) red
    set factory(arrow,.zoom.c,offset) 20
    set factory(arrow,.zoom.c,dist) 60
    set factory(arrow,.zoom.c,width) 7
    set factory(arrow,.zoom.c,shape) {20 25 10}

    # Init display stuff
    set factory(init,bbar) Both
    set factory(init,sbar) Visible
    set factory(init,arrow) On
    set factory(init,milepost) Off
    set factory(dragGain) Slow		;# 1 is pixel for pixel, 10 default

    # Calorie
    set factory(calorie,human) [expr {$state(me) ? 205 : 175}]
    set factory(calorie,bike) 25
    set factory(calorie,position) "Crouch"
    set factory(calorie,temp,centigrade) 20
    set factory(calorie,efficiency,human) 0.249 ;# Efficiency of human in cycling
    set factory(calorie,efficiency,drivetrain) 0.95 ;# Transmission efficiency of drivetrain
    set factory(calorie,rollingResistance) 0.0047 ;# Coefficient of rolling friction
    ;# coefficient of rolling friction
    ;#   narrow tubular tires range from      0.004 to 0.0055
    ;#   26 x 1.125 inch tires                   0.0047
    ;#   27 x 1.25 inch tires                    0.0051
    ;#   26 x 1.375                              0.0066
    ;#   for mountain bike tires                 0.0120

}
##+##########################################################################
#
# ::Config::PageDefaults -- does defaults for a single page
#
proc ::Config::PageDefaults {tab {drawCmd ""}} {
    set vars [::Config::_GetSlaveVars $tab]
    ::Config::Copy z2c $vars
    if {$drawCmd ne ""} {
	eval $drawCmd
    }
}
##+##########################################################################
#
# ::Config::_GetSlaveVars -- gets all linked variables on this page
#
proc ::Config::_GetSlaveVars {parent} {
    set q [winfo child $parent]

    set vars {}
    while {[llength $q] > 0} {
	set w [lindex $q 0]
	set q [lrange $q 1 end]

	set q [concat $q [winfo child $w]]
	set n [catch {set var [$w cget -variable]}]
	if {$n} {
	    set n [catch {set var [$w cget -textvariable]}]
	}
	if {! $n} {
	    if {! [regexp {\((.*)\)} $var => var2]} continue
	    if {[lsearch $vars $var2] == -1} {
		lappend vars $var2
	    }
	}
    }
    return $vars
}
##+##########################################################################
#
# ::Config::SetStartSize -- sets start size value
#
proc ::Config::SetStartSize {w} {
    $w delete 0 end
    $w insert end "[winfo width .c] x [winfo height .c]"
}
##+##########################################################################
#
# ::Config::ColorWidget
#
# Creates a megawidget combining an optionMenu and a button.
#
proc ::Config::ColorWidget {w tvar} {
    global state

    ::ttk::frame $w
    set colors {red red4 orange yellow lightyellow green blue darkblue \
		    dodgerblue cyan cyan4 purple violet magenta white black}
    eval tk_optionMenu $w.e $tvar $colors
    $w config -relief sunken -borderwidth 2
    $w.e config -width 10 -bg white -activebackground white \
	-bd 1 -relief sunken -highlightthickness 0

    ::ttk::button $w.b -takefocus 0 -image ::img::star -width 15
    $w.b configure -command [list ::Config::ChooseColor $tvar]
    pack $w.e -side left -fill both
    pack $w.b -side left -fill both
    return $w
}
##+##########################################################################
#
# ::Config::FontWidget -- font selection megawidget
#
proc ::Config::FontWidget {w tvar} {
    ::my::frame $w -relief sunken -borderwidth 2
    ::my::label $w.lbl -textvariable $tvar -width 15 -anchor c -background white
    ::ttk::button $w.b -takefocus 0 -image ::img::star -width 15 \
	-command [list ::Config::ChooseFont $tvar]
    pack $w.lbl $w.b -side left -fill both
    return $w
}
##+##########################################################################
#
# ::Config::ChooseFont -- handles selecting or cancelling a new font
#
proc ::Config::ChooseFont {varName} {
    upvar 1 $varName lvar
    set font [::ChooseFont::ChooseFont $lvar]
    if {$font ne ""} {
	set lvar $font
    }
}
##+##########################################################################
#
# ::Config::ChooseColor
#
# Puts the tk_chooseColor dialog and applies it to the text variable.
#
proc ::Config::ChooseColor {tvar} {
    set color [tk_chooseColor -initialcolor [set $tvar] \
		   -title "KLIMB Customize"]
    if {$color ne ""} {
	set $tvar $color
    }
    return $color
}
##+##########################################################################
#
# ::Config::Done -- Handles applying or closing the config dialog.
#      a => apply, c => cancel, o => ok, r => reset
#
proc ::Config::Done {how} {
    variable W
    variable TAB
    variable dialRedraw

    set TAB [$W.nb index current]
    set changed [::Config::IsChanged]

    if {$how eq "r"} {				;# Reset
	::Config::Copy z2c			;# Factory+zone into dialog
	$W.routeDefault invoke			;# Swaplist is special
	eval $dialRedraw			;# So is profile dial widget

	set how "a"				;# Pretend we're "apply"
	set changed [::Config::IsChanged]
	set changed [expr {$changed | 1}]
	# BUG: resetting node size won't be shown
    }

    if {$how ne "c"} {				;# NOT cancel
	if {$changed} {
	    ::Config::Copy s2b			;# Backup the state array
	    ::Config::Copy c2s			;# Copy into the state array

	    set n [::Display::Refresh $changed]
	    if {$n} {				;# Did an error occur???
		::Config::WriteRC		;# Nope, save to our config file
	    } else {
		::Config::Copy b2s		;# Yes, restore state array
		set how "a"			;# Don't allow exit for "ok"
	    }
	}
    }
    if {$how ne "a"} {				;# Close the window???
	destroy .config
    }
}
##+##########################################################################
#
# ::Config::IsChanged
#
# Returns
#  0 nothing is different
#  1 changes
#  2 node size change
#  4 poi size change
#  8 waypoint changed
# 16 unit change
# 32 annotation color
# 64 annotation font
# 128 stop&go change
# 256 description columns
#
proc ::Config::IsChanged {} {
    variable factory
    variable cdata
    global state

    set result 0
    if {$cdata(n,size) != $state(n,size)} { incr result 2 }
    if {$cdata(p,size) != $state(p,size)} { incr result 4 }
    if {$cdata(g,size) != $state(g,size)} { incr result 8 }
    if {$cdata(units,external) ne $state(units,external)} { incr result 16 }
    if {$cdata(a,color) ne $state(a,color)} { incr result 32 }
    if {$cdata(a,font) ne $state(a,font)} { incr result 64 }
    if {$cdata(arrow,stop&go) ne $state(arrow,stop&go)} { incr result 128 }
    if {$cdata(route,selected) ne $state(route,selected)} { incr result 256 }
    if {$cdata(n,hide) != $state(n,hide)} {incr result 512 }

    if {$result > 0} {return $result}

    foreach arr [array names factory] {
	if {[info exists state($arr)]} {
	    if {$cdata($arr) != $state($arr)} { return 1}
	}
    }
    return 0
}
##+##########################################################################
#
# ::Config::ReadRC -- Reads in several config files.
#  1. reset to factory settings
#  2. read zone/klimb.rc
#  3. read ./klimb.rc
#
proc ::Config::ReadRC {} {
    variable factory
    variable zone
    variable user
    variable cdata

    ::Config::DefaultRC				;# Reload factory settings
    array set ::Config::zone [array get ::Config::factory]
    array set ::Config::user [array get ::Config::factory]

    set rcFiles {}
    if {$::state(zdir) ne ""} {
	lappend rcFiles [file join $::state(zdir) "klimb.rc"] zone
    }
    lappend rcFiles [file join $::state(wdir) "klimb.rc"] who

    interp create -safe newInterp
    newInterp eval namespace eval ::Config { variable cdata }
    foreach {fname who} $rcFiles {
	if {! [file readable $fname]} continue

	newInterp eval array unset ::Config::cdata
	set n [catch {newInterp invokehidden source $fname} err]
	if {$n} {
	    WARN "ERROR: problem reading klimb.rc file: $err"
	    continue
	}
	if {$who eq "zone"} {
	    array set zone [newInterp eval array get ::Config::cdata]
	    array set user [array get zone]
	} else {
	    array set user [newInterp eval array get ::Config::cdata]
	}
    }

    ::Config::Copy u2s				;# Copy user values into state
    interp delete newInterp
}
##+##########################################################################
#
# ::Config::WriteRC -- Writes out the customizable data to an config file
#
proc ::Config::WriteRC {} {
    variable factory
    variable zone
    global state


    set fname [file join $::state(wdir) "klimb.rc"]
    set n [catch { set FOUT [open $fname w]} err]
    if {$n} {
	WARN "ERROR: problem writing klimb.rc file: $err"
	return
    }

    puts $FOUT "array set ::Config::cdata {"
    set cnt 0
    foreach {key} [lsort -dictionary [array names ::Config::factory]] {
	set value $state($key)

	# On Windows, reverse "Helvetica" translation into "Arial"
	if {$state(windows) && [string match "Arial *" $value]} {
	    regsub {^Arial } $value {Helvetica } value
	}
	if {$value != $zone($key)} {
	    puts $FOUT "	$key \x22$value\x22"
	    incr cnt
	}
    }
    puts $FOUT "}"
    close $FOUT
    if {$cnt == 0} {				;# Empty, so delete it
	file delete $fname
    }
}
##+##########################################################################
#
# ::Config::Dump -- debugging routine
#
proc ::Config::Dump {} {

    if {! [winfo exists .cdump]} {
	toplevel .cdump
	::Display::TileBGFix .cdump
	wm title .cdump "KLIMB Configuration Tables"
    }
    eval destroy [winfo child .cdump]

    set col 0
    set who [list state factory zone user cdata backup]
    foreach var $who {
	::my::label .cdump.l$var -text $var -font bigFont
	listbox .cdump.$var -height 28 -width 35 \
	    -font {Courier 7 bold} -exportselection 0 -bg white
	grid .cdump.l$var -row 0 -column $col
	grid .cdump.$var -row 1 -column $col -sticky ns
	incr col
    }
    ::ttk::button .cdump.refresh -text Refresh -command ::Config::Dump
    grid .cdump.refresh -row 2 -pady 10 -columnspan [llength $who]
    grid rowconfigure .cdump 1 -weight 1

    set ns "::"					;# State => :: ...
    foreach var $who {
	upvar 0 ${ns}$var lvar
	set ns ::Config::			;# ...all others => ::Config::

	foreach arr [lsort -dictionary [array names ::Config::factory]] {
	    if {[string match "r,*" $arr]} continue
	    set line "$arr: "
	    append line [string repeat " " [expr {26 - [string length $line]}]]
	    if {[info exists lvar($arr)]} {
		append line $lvar($arr)
	    } else {
		append line "?"
	    }
	    .cdump.$var insert end $line
	}
    }
}
## EON CONFIG
## BON HELP
##+##########################################################################
#
# Help Section
#
# Based on http://mini.net/tcl/1194.html
#
#  AddPage title text  -- register a hypertext page's title and text body
#  Help ?title?        -- bring up a toplevel showing the specified page
#			  or a index of titles, if not specified
#
# Hypertext pages are in a subset of Wiki format:
#   indented lines come in fixed font without evaluation;
#   blank lines break paragraphs
#   a line starting with "   * " gets a bullet
#   a line starting with "   - " gets a dash
#   a line starting with "   1. " will be a numbered list
#   text enclosed by '''<text>''' is embolden
#   text enclosed by ''<text>'' is embolden
#   all lines without leading blanks are displayed without explicit
#      linebreak (but possibly word-wrapped)
#   a link is the title of another page in brackets (see examples at
#      end). Links are displayed underlined and blue (or purple if they
#      have been visited before), and change the cursor to a pointing
#      hand. Clicking on a link of course brings up that page.
#
# In addition, you get "Index", "Search" (case-insensitive regexp in
# titles and full text), "History", and "Back" links at the bottom of
# pages.
##+##########################################################################
#
# ::Help::Help -- initializes and creates the help dialog
#
proc ::Help::Help {{title overview}} {
    ::Help::Init

    set w .help
    if {![winfo exists $w]} {
	::Help::DoDisplay $w
    }

    raise $w
    ::Help::show $title
    ::Help::SyncTOC $title
}
##+##########################################################################
#
# ::Help::Reset -- (for testing), resets all help info
#
proc ::Help::Reset {} {
    variable history {} seen {} current {} all {}
    variable pages
    variable alias
    array unset pages
    array unset alias

    foreach title {Back History Next Previous Index Search} {
	set alias([string tolower $title]) $title
    }

    destroy .help
}
##+##########################################################################
#
# ::Help::Init -- Sets up the help system
#
proc ::Help::Init {} {
    variable all
    variable alias

    if {$all ne {}} return
    array unset alias
    foreach title {Back History Next Previous Index Search} {
	set alias([string tolower $title]) $title
    }

    ::Help::ReadHelpFiles $::state(pdir)
}
##+##########################################################################
#
# ::Help::ReadHelpFiles -- reads "help.txt" in the packages directory
# and creates all the help pages.
#
proc ::Help::ReadHelpFiles {dir} {
    set fname [file join $dir help.txt]
    set fin [open $fname r]
    set data [read $fin] ; list
    close $fin

    regsub -all -line {^-+$} $data \x01 data
    regsub -all -line {^\#.*$\n} $data {} data
    foreach section [split $data \x01] {
	set n [regexp -line {^title:\s*(.*)$} $section => title]
	if {! $n} {
	    WARN "Bad help section\n'[string range $section 0 400]'"
	    continue
	}
	set aliases {}
	foreach {. alias} [regexp -all -line -inline {^alias:\s*(.*)$} $section] {
	    lappend aliases $alias
	}

	regsub -all -line {^(title:|alias:).*$\n} $section {} section
	::Help::AddPage $title $section $aliases
    }
    ::Help::BuildTOC
}
##+##########################################################################
#
# ::Help::AddPage -- Adds another page to the help system
#
proc ::Help::AddPage {title body {aliases {}}} {
    variable pages
    variable all
    variable alias

    set title [string trim $title]
    set body [string trim $body "\n"]
    regsub -all {\\\n} $body {} body		;# Remove escaped lines
    regsub -all {[ \t]+\n} $body "\n" body	;# Remove trailing spaces
    regsub -all {([^\n])\n([^\s])} $body {\1 \2} body	;# Unwrap paragraphs

    set pages($title) $body

    lappend aliases [string tolower $title]
    foreach name $aliases { set alias([string tolower $name]) $title }

    if {[lsearch $all $title] == -1} {
	set all [lsort [lappend all $title]]
    }
}
##+##########################################################################
#
# ::Help::DoDisplay -- Creates our help display. If we have tile 0.7.8 then
# we will also have a TOC pane.
#
proc ::Help::DoDisplay {TOP} {
    variable H

    destroy $TOP
    toplevel $TOP
    ::Display::TileBGFix $TOP
    wm title $TOP "$::state(progname) Help"
    wm transient $TOP .

    ::my::frame $TOP.bottom -borderwidth 2 -relief ridge
    ::ttk::button $TOP.b -text "Dismiss" -command [list destroy $TOP]
    pack $TOP.bottom -side bottom -fill both
    pack $TOP.b -side bottom -expand 1 -pady 10 -in $TOP.bottom

    set P $TOP.p
    ::ttk::panedwindow $P -orient horizontal

    pack $P -side top -fill both -expand 1
    ::my::frame $P.toc -relief ridge
    ::tk::frame $P.help -borderwidth 2 -relief ridge -bg white

    $P add $P.toc
    $P add $P.help
    ::Help::CreateTOC $P.toc
    ::Help::CreateHelp $P.help

    ::Display::CenterWindow $TOP
}
##+##########################################################################
#
# ::Help::CreateTOC -- Creates a TOC display from tile's treeview widget
#
proc ::Help::CreateTOC {TOC} {
    variable TREE

    set TREE $TOC.tree
    ::ttk::scrollbar $TOC.sby -orient vert -command "$TREE yview"
    ::ttk::scrollbar $TOC.sbx -orient hori -command "$TREE xview"

    ::ttk::treeview $TREE -padding {0 0 0 0} -selectmode browse \
	-yscrollcommand "$TOC.sby set" ;#$ -xscrollcommand "$TOC.sbx set"

    grid $TREE $TOC.sby -sticky news
    #grid $TOC.sbx -sticky ew
    grid rowconfigure $TOC 0 -weight 1
    grid columnconfigure $TOC 0 -weight 1

    $TREE heading #0 -text "Table of Contents"
    $TREE tag configure link -foreground blue
    # NB. binding to buttonpress sometimes "misses" clicks
    #$TREE tag bind link <ButtonPress> ::Help::ButtonPress
    bind $TREE <<TreeviewSelect>> ::Help::TreeviewSelection
    ::Help::BuildTOC
}
##+##########################################################################
#
# ::Help::CreateHelp -- Creates our main help widget
#
proc ::Help::CreateHelp {w} {
    variable HELP $w.t

    text $w.t -border 5 -relief flat -wrap word -state disabled -width 60 \
	-yscrollcommand "$w.s set" -padx 5 -font $::state(help,font)
    #::Display::TileBGFix $w.t
    ::ttk::scrollbar $w.s -orient vert -command "$w.t yview"
    pack $w.s -fill y -side right
    pack $w.t -fill both -expand 1 -side left

    $w.t tag config link -foreground blue -underline 1
    $w.t tag config seen -foreground purple4 -underline 1
    $w.t tag bind link <Enter> "$w.t config -cursor hand2"
    $w.t tag bind link <Leave> "$w.t config -cursor {}"
    $w.t tag bind link <1> "::Help::click $w.t %x %y"
    $w.t tag config hdr -font {Times 18 bold}
    $w.t tag config fix -font \
	"[font actual [$w.t cget -font]] -family Courier"
    $w.t tag config bold -font \
	"[font actual [$w.t cget -font]] -weight bold"
    $w.t tag config italic -font \
	"[font actual [$w.t cget -font]] -slant italic"

    set l1 [font measure $::state(help,font) "   "]
    set l2 [font measure $::state(help,font) "   \u2022   "]
    set l3 [font measure $::state(help,font) "       \u2013   "]
    set l3 [expr {$l2 + ($l2 - $l1)}]
    $w.t tag config bullet -lmargin1 $l1 -lmargin2 $l2
    $w.t tag config dash -lmargin1 $l2 -lmargin2 $l3

    bind $w.t <n> [list ::Help::next $w.t 1 sync]
    bind $w.t <p> [list ::Help::next $w.t -1 sync]
    bind $w.t <b> [list ::Help::back $w.t sync]
    bind $w.t <Key-space> [bind Text <Key-Next>]

    # Create the bitmap for our bullet
    if {0 && [lsearch [image names] ::img::bullet] == -1} {
	image create bitmap ::img::bullet -data {
	    #define bullet_width  11
	    #define bullet_height 9
	    static char bullet_bits[] = {
		0x00,0x00, 0x00,0x00, 0x70,0x00, 0xf8,0x00, 0xf8,0x00,
		0xf8,0x00, 0x70,0x00, 0x00,0x00, 0x00,0x00
	    };
	}
    }
}
##+##########################################################################
#
# ::Help::click -- Handles clicking a link on the help page
#
proc ::Help::click {w x y} {
    variable current

    set range [$w tag prevrange link "[$w index @$x,$y] + 1 char"]
    if {[llength $range]} {
	set txt [eval $w get $range]
	::Help::show $txt
	::Help::SyncTOC $current		;# Use current to get Next, Back
    }
}
##+##########################################################################
#
# ::Help::back -- Goes back in help history
#
proc ::Help::back {w {sync ""}} {
    variable current
    variable history

    set l [llength $history]
    if {$l <= 1} return
    set last [lindex $history [expr {$l-2}]]
    set history [lrange $history 0 [expr {$l-3}]]
    ::Help::show $last
    if {$sync ne ""} { ::Help::SyncTOC $current}
}
##+##########################################################################
#
# ::Help::next -- Goes to next help page
#
proc ::Help::next {w dir {sync ""}} {
    variable current
    variable all
    variable allTOC

    set what $all
    if {$allTOC ne {}} {set what $allTOC}	;# Use order in TOC if possible

    set n [lsearch -exact $what $current]
    set n [expr {($n + $dir) % [llength $what]}]
    set next [lindex $what $n]
    ::Help::show $next
    if {$sync ne ""} { ::Help::SyncTOC $current}
}
##+##########################################################################
#
# ::Help::listpage -- Puts up a help page with a bunch of links (all or history)
#
proc ::Help::listpage {w plist} {
    foreach i $plist {$w insert end \n; ::Help::showlink $w $i}
}
##+##########################################################################
#
# ::Help::search -- Creates search help page
#
proc ::Help::search {w} {
    $w insert end "\nSearch phrase:	 "
    ::tk::entry $w.e -textvar [namespace current]::search
    $w window create end -window $w.e
    focus $w.e
    $w.e select range 0 end
    bind $w.e <Return> "::Help::dosearch $w"
    ::ttk::button $w.b -text Search! -command "::Help::dosearch $w"
    $w window create end -window $w.b
}
##+##########################################################################
#
# ::Help::dosearch -- Does actual help search
#
proc ::Help::dosearch {w} {
    variable search
    variable pages
    variable all

    $w config -state normal
    $w insert end "\n\nSearch results for '$search':\n"
    foreach i $all {
	if {[regexp -nocase $search $i]} {	;# found in title
	    $w insert end \n
	    ::Help::showlink $w $i
	} elseif {[regexp -nocase -indices -- $search $pages($i) pos]} {
	    set p1 [expr {[lindex $pos 0]-20}]
	    set p2 [expr {[lindex $pos 1]+20}]
	    regsub -all \n [string range $pages($i) $p1 $p2] " " context
	    $w insert end \n
	    ::Help::showlink $w $i
	    $w insert end " - ...$context..."
	}
    }
    $w config -state disabled
}
##+##########################################################################
#
# ::Help::showlink -- Displays link specially
#
proc ::Help::showlink {w link {tag {}}} {
    variable seen
    set tag [concat $tag link]
    if {[lsearch -exact $seen $link]>-1} {
	lappend tag seen
    }
    $w insert end $link $tag
}
##+##########################################################################
#
# ::Help::FindPage -- Finds actual pages given a possible alias
#
proc ::Help::FindPage {title} {
    variable pages
    variable alias

    if {[info exists pages($title)]} { return $title }
    set title2 [string tolower $title]
    if {[info exists alias($title2)]} { return $alias($title2) }
    return "ERROR!"
}
##+##########################################################################
#
# ::Help::show -- Shows help or meta-help page
#
proc ::Help::show {which} {
    variable H
    variable pages
    variable alias
    variable history
    variable seen
    variable current
    variable all
    variable HELP

    set w $HELP
    set title [::Help::FindPage $which]

    if {[lsearch -exact $seen $title]==-1} {lappend seen $title}
    $w config -state normal
    $w delete 1.0 end
    $w insert end $title hdr "\n"
    set next 0					;# Some pages have no next page
    switch -- $title {
	Back    { ::Help::back $w; return}
	History { ::Help::listpage $w $history}
	Next    { ::Help::next $w 1; return}
	Previous { ::Help::next $w -1; return}
	Index   { ::Help::listpage $w $all}
	Search  { ::Help::search $w}
	default { ::Help::showpage $w $title $which; set next 1 }
    }

    # Add bottom of the page links
    $w insert end \n------\n {}
    $w insert end Index link " - " {} Search link
    if {$next} {
	$w insert end " - " {} Previous link " - " {} Next link
    }
    if {[llength $history]} {
	$w insert end " - " {} History link " - " {} Back link
    }

    $w insert end \n
    if {[lindex $history end] ne $title} {
	lappend history $title
    }
    $w config -state disabled

   set current $title
}
##+##########################################################################
#
# ::Help::showpage -- Shows a text help page, doing wiki type transforms
#
proc ::Help::showpage {w title which} {
    variable pages
    variable history
    variable seen
    variable current
    variable all

    set endash \u2013
    set emdash \u2014
    set bullet \u2022

    $w insert end \n				;# Space down from the title
    set number 0
    if {! [info exists pages($title)]} {
	set lines [list "The help page for ''\"$which\"'' is missing."]
    } else {
	set lines [split $pages($title) \n]
    }

    foreach line $lines {
	set tag {}
	set op1 ""
	if {[regexp {^( +)([1*-]+)\s*(.*)} $line -> indent op txt]} {
	    set op1 [string index $op 0]
	    set indent2 [string repeat "     " [expr {[string length $op] - 1}]]
	    if {$op1 eq "1"} {			;# Number
		incr number
		$w insert end "$indent$number"
	    } elseif {$op1 eq "*"} {		;# Bullet
		set tag bullet
		$w insert end "$indent2 $bullet " $tag
	    } elseif {$op1 eq "-"} {		;# Dash
		set tag dash
		$w insert end "$indent2 $endash " $tag
	    }
	    set line $txt
	} elseif {[string match " *" $line]} {	;# Line beginning w/ a space
	    $w insert end $line\n fix
	    set number 0
	    continue
	}
	if {$op1 ne "1"} { set number 0}

	while {1} {				;# Look for markups
	    set blink [set bbold [set bital $line]]
	    set n1 [regexp {^(.*?)[[](.*?)[]](.*$)} $line -> blink link plink]
	    set n2 [regexp {^(.*?)'''(.*?)'''(\s*.*$)} $line -> bbold bold pbold]
	    set n3 [regexp {^(.*?)''(.*?)''(\s*.*$)} $line -> bital ital pital]
	    if {$n1 == 0 && $n2 == 0 && $n3 == 0} break

	    set len1 [expr {$n1 ? [string length $blink] : 9999}]
	    set len2 [expr {$n2 ? [string length $bbold] : 9999}]
	    set len3 [expr {$n3 ? [string length $bital] : 9999}]

	    if {$len1 < $len3} {
		$w insert end $blink $tag
		::Help::showlink $w $link $tag
		set line $plink
	    } elseif {$len2 <= $len3} {
		$w insert end $bbold $tag $bold [concat $tag bold]
		set line $pbold
	    } else {
		$w insert end $bital $tag $ital [concat $tag italic]
		set line $pital
	    }
	}
	$w insert end "$line\n" $tag
    }
}
##+##########################################################################
#
# ::Help::Sanity -- Checks for missing help links
#
proc ::Help::Sanity {} {
    variable all

    set missing {}
    foreach page $all {
	set m [::Help::CheckLinks $page]
	if {$m ne {}} {
	    puts "$page: $m"
	    set missing [concat $missing $m]
	}
    }
    return $missing
}
##+##########################################################################
#
# ::Help::CheckLinks -- Checks one page for missing help links
#
proc ::Help::CheckLinks {title} {
    variable pages
    variable alias

    set missing {}
    set title [::Help::FindPage $title]
    foreach {. link} [regexp -all -inline {\[(.*?)\]} $pages($title)] {
	if {! [info exists alias([string tolower $link])]} {
	    lappend missing $link
	}
    }
    return $missing
}
##+##########################################################################
#
# ::Help::BuildTOC -- Fills in our TOC widget based on a TOC page
#
proc ::Help::BuildTOC {} {
    variable TREE
    variable pages
    variable allTOC {}
    variable title2TOC

    if {! [winfo exists $TREE]} return
    set tocData $pages([::Help::FindPage toc])

    $TREE delete [$TREE child {}]
    unset -nocomplain parent
    set parent() {}
    unset -nocomplain title2TOC

    regsub -all {'{2,}} $tocData {} tocData	;# Remove bold, italics
    foreach line [split $tocData \n] {
	set n [regexp {^\s*(-+)\s*(.*)} $line => dashes txt]
	if {! $n} continue

	set isLink [regexp {^\[(.*)\]$} $txt => txt]
	set pDashes [string range $dashes 1 end]
	set id [$TREE insert $parent($pDashes) end -text $txt]
	set parent($dashes) $id

	set ptitle [::Help::FindPage $txt]
	set title2TOC($ptitle) $id

	if {$isLink} {
	    $TREE item $id -tag link
	    if {[lsearch $allTOC $ptitle] == -1} {
		lappend allTOC $ptitle
	    }
	}
    }
}
##+##########################################################################
#
# ::Help::ButtonPress -- Handles clicking on a TOC link
# !!! Sometimes misses clicks, so we're using TreeviewSelection instead
#
proc ::Help::ButtonPress {} {
    variable TREE

    set id [$TREE selection]
    set title [$TREE item $id -text]
    ::Help::show $title
}
##+##########################################################################
#
# ::Help::TreeviewSelection -- Handles clicking on any item in the TOC
#
proc ::Help::TreeviewSelection {} {
    variable TREE

    set id [$TREE selection]
    set title [$TREE item $id -text]
    set tag [$TREE item $id -tag]
    if {$tag eq "link"} {
	::Help::show $title
    } else {					;# Make all children visible
	set last [lindex [$TREE children $id] end]
	if {$last ne {} && [$TREE item $id -open]} {
	    $TREE see $last
	}
    }
}
##+##########################################################################
#
# ::Help::SyncTOC -- Given text, highlights entry in TOC
#
proc ::Help::SyncTOC {txt} {
    variable TREE
    variable title2TOC

    if {! [winfo exists $TREE]} return
    set title [::Help::FindPage $txt]
    if {! [info exists title2TOC($title)]} return
    set id $title2TOC($title)
    $TREE see $id

    bind $TREE <<TreeviewSelect>> {}
    $TREE selection set $id
    bind $TREE <<TreeviewSelect>> ::Help::TreeviewSelection
}
## EON HELP
## BON RIDELOG
##+##########################################################################
#
# ::RideLog::Dialog -- puts up the dialog with the RideLog table
#
proc ::RideLog::Dialog {} {
    variable RideData
    variable Widget
    variable RideCount
    variable W

    if {! [::Data::CanDo tktable]} {
	return [WARN "This feature requires the Tktable extension"]
    }
    set RideData(who) {}
    ::RideLog::Data2Table
    ::RideLog::MakeDialog

    set pbar [::Display::MakeProgressBar $W "Reading Ride Log File" 0]
    update
    after 10 ::RideLog::ReadLog
    DoGrab $pbar $pbar
}
##+##########################################################################
#
# ::RideLog::MakeDialog -- draws the actual Ridelog dialog
#
proc ::RideLog::MakeDialog {} {
    variable RideData
    variable TableData
    variable Widget
    variable RideCount
    variable W
    variable filter 0

    ::RideLog::Exit				;# Clean up from last time

    set WB $W.body
    set WBTN $W.buttons
    set title "$::state(progname) Ride Log"
    ::Display::MakeDialogBox $W $title $title [list ::img::icon klimb.gif] 0
    destroy $W.icon
    wm geom $W +10+10
    wm protocol $W WM_DELETE_WINDOW ::RideLog::Exit
    wm deiconify $W
    #wm transient $W {}
    wm resizable $W 1 1

    # First do all the buttons
    ::ttk::button $WBTN.display -text Display -command ::RideLog::Display
    #button $WBTN.edit -text Edit -command ::RideLog::GoEdit -state disabled
    ::ttk::button $WBTN.stats -text "Statistics" -command ::RideLog::ShowStats
    ::ttk::checkbutton $WBTN.filter -text "Filter" -variable ::RideLog::filter \
	-command ::Filter::DialogToggle
    ::ttk::checkbutton $WBTN.showall -text "Show All" \
	-variable ::RideLog::ShowAll -command ::RideLog::ShowAll
    ::ttk::button $WBTN.dismiss -text Dismiss -command ::RideLog::Exit
    ::Display::GridChildren $WBTN

    $WB config -borderwidth 2 -relief ridge
    set Widget $WB.t

    set rows [expr {3 + $RideCount}]
    if {$rows < 10} {set rows 10}
    set height [expr {$rows > 20 ? 20 : $rows}]
    set cols [llength [array names TableData 0,*]]

    table $Widget \
	-cols $cols \
	-rows $rows \
	-titlerows 2 \
	-height $height \
	-yscrollcommand [list $WB.sy set] \
	-xscrollcommand [list $WB.sx set] \
	-colstretchmode last \
	-rowstretchmode last \
	-selectmode single \
	-sparsearray 0 \
	-variable ::RideLog::TableData \
	-coltagcommand ::RideLog::colTagProc \
	-rowtagcommand ::RideLog::rowTagProc \
	-colwidth 8 \
	-state disabled \
	-ipadx 2 \
	-highlightthickness 0 \
	-bd 2 \
	-exportselection 0
    $Widget spans 0,9 0,1 0,7 0,1
    $Widget width 0 16	1 20  2 14 11 50
    $Widget tag configure col_0 -anchor w
    $Widget tag configure col_11 -anchor w
    $Widget tag configure title -anchor c
    $Widget tag configure sel -fg {} -bg {}

    proc ::RideLog::colTagProc {col} { return "col_$col" }
    proc ::RideLog::rowTagProc {row} { return "row_$row" }

    bind $Widget <Button-1> [list ::RideLog::ButtonClick 1 %x %y]
    bind $Widget <Double-1> [list ::RideLog::ButtonClick 2 %x %y]
    bind $Widget <Key-Return> [list ::RideLog::Display]
    bind $Widget <Key-Up> [list ::RideLog::MoveRow -1]
    bind $Widget <Key-Down> [list ::RideLog::MoveRow 1]
    bind $Widget <MouseWheel> {::RideLog::MoveRow [expr {-(%D/120) * 1}];break}

    ::ttk::scrollbar $WB.sy -command [list $Widget yview]
    ::ttk::scrollbar $WB.sx -command [list $Widget xview] -orient horizontal

    grid $Widget $WB.sy -sticky news
    grid $WB.sx	-sticky ew
    grid columnconfig $WB 0 -weight 1
    grid rowconfig    $WB 0 -weight 1

    focus $Widget
}
##+##########################################################################
#
# ::RideLog::Data2Table
#
# Puts ride log data into the array used by TKtable
#
proc ::RideLog::Data2Table {} {
    variable RideData
    variable TableData
    variable Widget
    variable filter

    # Put in the column headers
    unset -nocomplain TableData
    array set TableData {
	0,0 ""	     1,0 Date
	0,1 ""	     1,1 Title
	0,2 ""	     1,2 Region
	0,3 ""	     1,3 Distance
	0,4 ""	     1,4 Climbing
	0,5 Climbing 1,5 Density
	0,6 ""	     1,6 Time
	0,7 Speed    1,7 Avg
	0,8 ""	     1,8 Max
	0,9 KLIMB    1,9 Distance
	0,10 ""	     1,10 Climbing
	0,11 ""	     1,11 "  Comments"
    }

    set row 1					;# Don't forget to skip header
    set RideData(who2) {}
    set okFilters [expr {$filter && [::Filter::ValidateFilters]}]
    foreach num $RideData(who) {
	if {$okFilters} {
	    set b [::Filter::ApplyFilters $num]
	    if {! $b} continue
	}

	incr row				;# Row in the table
	lappend RideData(who2) $num
	set RideData(table2data,$row) $num
	set RideData(data2table,$num) $row

	set TableData($row,0) $RideData($num,date)
	catch {set TableData($row,0) \
		   [clock format [clock scan $TableData($row,0)] \
			-format "%a %b %d, %Y"]}
	set TableData($row,1) $RideData($num,title)
	set TableData($row,2) ""
	foreach r $RideData($num,kregion) {append TableData($row,2) $r ", "}
	set TableData($row,2) [string range $TableData($row,2) 0 end-2]
	set TableData($row,3) $RideData($num,distance)
	set TableData($row,4) [comma $RideData($num,climbing)]
	set TableData($row,5) $RideData($num,density)
	set TableData($row,6) $RideData($num,time)
	set TableData($row,7) $RideData($num,avg)
	set TableData($row,8) $RideData($num,max)
	set TableData($row,9) $RideData($num,kdistance)
	set TableData($row,10) [comma $RideData($num,kclimbing)]
	set TableData($row,11) $RideData($num,comments)
    }
    if {[winfo exists $Widget]} {
	$Widget config -rows [expr {$row + 2}]
    }
}
##+##########################################################################
#
# ::RideLog::Exit -- cleans up on exiting Ridelog dialog
#
proc ::RideLog::Exit {} {
    if {$::RideLog::ShowAll} {
	::RideLog::ShowAll 0
    }
    destroy $::RideLog::W
    destroy .rstats
    ::Filter::Exit
    array unset ::RideLog::RoadLog
    array unset ::RideLog::RideData
    #array unset ::RideLog::TableData
}
##+##########################################################################
#
# ::RideLog::ShowAll -- highlights ridden roads (-1 for unridden)
#
proc ::RideLog::ShowAll {{how {}}} {
    variable RoadLog
    variable ShowAll
    global state

    if {$how ne {}} {set ShowAll $how}
    set lvl [expr {$ShowAll ? 9 : 0}]
    set lvl [expr {$ShowAll ? "rlog" : 0}]

    ::Route::ClearRoute
    set who [array names RoadLog]		;# All ridden roads
    if {$ShowAll == 0} {
	set who $::region(road,visible)		;# Just erase everything
    } elseif {$ShowAll < 0} {			;# All unridden roads
	set who2 {}
	foreach rid $::region(road,visible) {
	    if {[lsearch $who $rid] == -1} {
		lappend who2 $rid
	    }
	}
	set who $who2
    }

    ::Display::HighlightManyRoads $lvl cyan $who
}
##+##########################################################################
#
# ::RideLog::ReadLog -- reads in all data from the log file
#
proc ::RideLog::ReadLog {} {
    variable RideData
    variable Names
    variable Sort
    variable Select
    variable RoadLog
    variable RideCount -1
    global state

    array unset RoadLog
    array unset RideData
    set RideData(who) {}
    array set Select {table 0 data -1}		;# Clear selection data
    set Sort(column) ""				;# Use default sort

    if {! [file readable $state(logfile)]} {
	::Display::DoProgressBar 0 0
	return 0
    }
    set FIN [open $state(logfile) r]
    set data [read $FIN]; close $FIN
    regsub -all {\n\s+} $data { } data		;# Handle continuation lines
    set lines [split $data "\n"] ;  list
    set len [llength $lines]
    if {$len > 200 && [winfo exists .pbar]} {
	wm deiconify .pbar; raise .pbar $::RideLog::W}

    set when ""
    set idx 0					;# Data row id
    set lcnt -1
    foreach line $lines {
	incr lcnt
	if {[regexp -nocase {KLIMB Ride Log Entry} $line]} {
	    ::Display::DoProgressBar $lcnt $len
	    incr idx
	    lappend RideData(who) $idx		;# All entries

	    foreach key [array names Names col,*] { ;# Default values for all
		set RideData($idx,$Names($key)) ""
	    }
	    set RideData($idx,kversion) 2
	    set when ""
	}

	set n [regexp {^(.*):\s+(.*)} $line => name value] ;# Get name/value
	if {! $n} continue

	set name [string tolower $name]
	if {! [info exists Names(col,$name)]} continue ;# Unknown entry
	set value [::Data::CleanUserData $value]
	set RideData($idx,$Names(col,$name)) $value
	if {$name eq "date"} { set when [clock scan $value] }

	# Get dates ridden for every road
	if {$Names(col,$name) eq "kroads"} {
	    if {$when eq ""} continue		;# Oops, no date yet
	    foreach rid $value {
		if {! [string match "X*" $rid]} {
		    lappend RoadLog($rid) $when
		}
	    }
	}
    }

    set RideCount $idx
    # Post process some of the data
    foreach idx $RideData(who) {
	set climb $RideData($idx,climbing)
	set dist $RideData($idx,distance)
	if {[string is double -strict $dist] \
		&& [string is double -strict $climb]} {
	    set RideData($idx,density) [Round1 [expr {double($climb) / $dist}]]
	}

	set rtime $RideData($idx,time)
	catch {set rtime [clock format [clock scan $rtime] -format %H:%M]}
	if {$rtime eq "00:00"} {set rtime ""}
	set RideData($idx,time) $rtime
    }
    ::RideLog::SortColumn date 0

    foreach rid [array names RoadLog] {
	set RoadLog($rid) [lsort -integer $RoadLog($rid)]
    }
    ::Display::DoProgressBar 0 0
    return 1
}
proc old_CleanUserData { str } {
    # See ::Data::CleanUserData
    set val $str
    regsub -all {,} $val {} val			;# First remove commas
    if {! [string is double -strict $val]} { return $str }

    if {[string first "." $str] != -1} { return $str } ;# Floating point
    scan $val %d val				;# Handle octal
    return $val
}
##+##########################################################################
#
# ::RideLog::ButtonClick
#
# Handles button clicks on the table. If in the title area then we
# sort by that column; if in the data area, we select that row.
#
proc ::RideLog::ButtonClick {type x y} {
    variable Names
    variable Widget
    variable Sort
    variable TableData
    variable Arrows

    set index [$Widget index @$x,$y]
    scan $index "%d,%d" row col

    if {$row < 2} {				;# Click in title => sort
	;# Unhighlight old sort column
	$Widget tag configure col_$Sort(colnum) -bg {}
	$Widget tag delete sortcol

	set dir [::RideLog::SortColumn $Names(sort,$col) $col]
	append TableData(1,$col) " " $Arrows($Sort(dir))
	set colors(1) darkblue	; set colors(1,x) lightblue
	set colors(0) darkgreen ; set colors(0,x) lightgreen

	$Widget tag cell sortcol 1,$col
	$Widget tag configure sortcol -bg $colors($dir)
	$Widget tag raise sortcol
	$Widget tag configure col_$col -bg $colors($dir,x)
    } else {					;# Click in data area => select
	if {$type == 1} {
	    ::RideLog::SelectRow 1 $row
	} else {
	    ::RideLog::Display			;# Double click on a row
	}
	return
    }
}
##+##########################################################################
#
# ::RideLog::MoveRow -- handle key up/down and mousewheel to move selection
#
proc ::RideLog::MoveRow {dir} {
    variable Select
    variable Widget
    variable TableData

    if {! [winfo exists $Widget]} return	;# No table yet

    set row $Select(table)
    if {$row < 3 && $dir < 0} return
    if {$row < 2 && $dir > 0} { set row 1 }

    incr row $dir
    if {[info exists TableData($row,0)]} {
	::RideLog::SelectRow 1 $row
    }
}
##+##########################################################################
#
# ::RideLog::SelectRow
#
# Highlights a row of the table
#
proc ::RideLog::SelectRow {onoff row} {
    variable RideData
    variable Select
    variable Widget
    variable W

    if {! [winfo exists $Widget]} return	;# No table yet

    # Always turn off old one
    $Widget tag configure row_$Select(table) -bg {}
    $W.buttons.display config -state disabled
    if {! $onoff} return

    if {$row eq ""} {				;# Unknown row
	if {$Select(data) < 0} return		;# Nothing selected yet
	set row $RideData(data2table,$Select(data))
    }

    if {! [info exists RideData(table2data,$row)]} return ;# Off the table
    if {$row > 1} {
	$Widget tag configure row_$row -bg $::state(r,1,0,color)
	$Widget tag raise row_$row
	set Select(table) $row
	set Select(data) $RideData(table2data,$row)
	$Widget see $row,0
	$W.buttons.display config -state normal
    } else {
	set Select(table) 0
	set Select(data) -1
	puts "weird row selection: $row"
    }
}
##+##########################################################################
#
# ::RideLog::SortColumn
#
# Sorts the table by a given column.
#
proc ::RideLog::SortColumn {column colnum} {
    variable RideData
    variable Sort
    variable Select

    ::RideLog::SelectRow 0 0			;# Turn selection off
    set ascending 1
    if {[string equal $Sort(column) $column]} { ;# If repeating the same column
	set ascending [expr {! $Sort(dir)}]	;# ...then sort in opposite dir
    }
    set Sort(column) $column
    set Sort(dir) $ascending
    set Sort(colnum) $colnum

    set RideData(who) [lsort -command [list ::RideLog::Compare \
					   $column $ascending] $RideData(who)]
    ::RideLog::Data2Table			;# Put into the table variable
    ::RideLog::SelectRow 1 ""			;# Turn selection back on

    return $ascending
}
##+##########################################################################
#
# ::RideLog::Compare
#
# Used by lsort to compare to ride entries.
#
proc ::RideLog::Compare {column ascending A B} {
    set AA $::RideLog::RideData($A,$column)
    set BB $::RideLog::RideData($B,$column)

    if {[string equal $column "date"]} {
	set AA [clock scan $AA]
	set BB [clock scan $BB]
	set result [expr {$AA - $BB}]
    } elseif {[string equal $column "title"] || \
		  [string equal $column "comments"]} {
	set result [string compare $AA $BB]
    } else {
	regsub -all {[ +?]} $AA {} AA
	regsub -all {[ +?]} $BB {} BB
	if {$AA < $BB} {
	    set result -1
	} elseif {$AA > $BB} {
	    set result 1
	} else {
	    set result 0
	}
    }
    if {! $ascending} {
	set result [expr {-1 * $result}]
    }
    return $result
}
##+##########################################################################
#
# ::RideLog::Display
#
# Displays the selected route on the map.
#
proc ::RideLog::Display {} {
    variable RideData
    variable Select
    variable Widget

    if {$Select(data) < 0} return		;# Nothing selected yet
    set row $Select(data)

    unset -nocomplain R
    set R(Rzone)    $::state(zone)
    set R(Rversion) $RideData($row,kversion)
    set R(Rregion)  $RideData($row,kregion)
    set R(Rmag)	    $RideData($row,kmag)
    set R(Rnnodes)  $RideData($row,knnodes)
    set R(Rnroads)  $RideData($row,knroads)
    set R(Rnphotos) {}
    set R(Rnsplits) {}
    set R(Rnsplits) $RideData($row,knsplits)
    set R(Rtitle)   {}

    set R(Rroute)   [list \
			 turns $RideData($row,kturns) \
			 nodes $RideData($row,knodes) \
			 roads $RideData($row,kroads) \
			 start [lindex $RideData($row,knodes) 0] \
			 tail  [lindex $RideData($row,knodes) end]]

    if {$R(Rregion) eq {} || $R(Rmag) eq {}} {
	set txt "ERROR: this entry is missing region and "
	append txt "magnification information\nand cannot be displayed."
	if {$R(Rversion) <= 1} {
	    append txt "\n\nThis may be a version incompatibility, see help "
	    append txt "for details"
	}
	WARN $txt
	return
    }
    ::Region::Revert				;# Always blow away temp stuff
    foreach {err emsg} [::Route::LoadX R 0] break
    if {$emsg ne ""} {
	WARN "Error displaying route\n\n$emsg"
    }

    if {! [winfo exists $Widget]} return
    # Now flash the widget to indicate we're done
    set bg [$Widget cget -bg]
    $Widget config -bg white
    $Widget config -bg red
    update idletasks
    after 200
    $Widget config -bg $bg
    update idletasks
}
##+##########################################################################
#
# ::RideLog::GoEdit
#
# Brings up the ridelog edit dialog w/ this route data.
#
proc ::RideLog::GoEdit {} {
    variable RideData
    variable Select
    tk_messageBox -message "Feature not yet implemented." -type ok
    if {$Select(data) < 0} return		;# Nothing selected yet
}
##+##########################################################################
#
# ::RideLog::Edit
#
# Puts up a dialog for filling in ride information which then can be
# added to a ride log.
#
proc ::RideLog::Edit {} {
    variable Log
    global state msg

    unset -nocomplain Log
    set Log(na) N/A

    set W .log
    set WB $W.body
    set WBTN $W.buttons
    set title "$state(progname) Ride Log Form"
    ::Display::MakeDialogBox $W $title $title [list ::img::icon klimb.gif]

    ::ttk::button $WBTN.logit -text "Add to Log" -command ::RideLog::Save
    ::ttk::button $WBTN.dismiss -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    # Body stuff
    ::my::label $WB.r0a -text "Title" -anchor e
    ::my::entry $WB.r0b -textvariable ::RideLog::Log(title)
    set ::RideLog::Log(title) $::route(title)
    foreach who {dist climb avg max} { set ::RideLog::Log($who) "" }

    ::my::label $WB.r1a -text "Date" -anchor e
    ::my::frame $WB.r1b
    set ::RideLog::Log(date) "pre"
    ::Datefield::datefield $WB.r1b1 -textvariable ::RideLog::Log(date)
    ::my::label $WB.r1b2 -textvariable ::RideLog::Log(wday)
    ::Data::UniqueTrace ::RideLog::Log(date) ::RideLog::WeekDay
    ::RideLog::WeekDay

    ::my::label $WB.r2b -text Distance
    ::my::label $WB.r2c -text Climbing
    ::my::label $WB.r2d -text Avg
    ::my::label $WB.r2e -text Max
    ::my::label $WB.r2f -text Time

    ::my::label $WB.r3a -text $state(progname) -anchor e
    ::my::entry $WB.r3b -textvariable msg(dist2) -state disabled \
	-justify center -background grey80 -width 5
    ::my::entry $WB.r3c -textvariable msg(climb2) -state disabled \
	-justify center -background grey80 -width 5
    ::my::entry $WB.r3d -textvariable ::RideLog::Log(na) -state disabled \
	-justify center -background grey80 -width 5
    ::my::entry $WB.r3e -textvariable ::RideLog::Log(na) -state disabled \
	-justify center -background grey80 -width 5
    ::my::entry $WB.r3f -textvariable ::RideLog::Log(na) -state disabled \
	-justify center -background grey80 -width 5

    ::my::label $WB.r4a -text Bicycle -anchor e
    ::my::entry $WB.r4b -textvariable ::RideLog::Log(dist)  -justify center -width 5
    ::my::entry $WB.r4c -textvariable ::RideLog::Log(climb) -justify center -width 5
    ::my::entry $WB.r4d -textvariable ::RideLog::Log(avg)   -justify center -width 5
    ::my::entry $WB.r4e -textvariable ::RideLog::Log(max)   -justify center -width 5
    ::Datefield::timefield $WB.r4f -textvariable ::RideLog::Log(time)

    ::my::label $WB.r5a -text Comments -anchor e
    text $WB.r5b  -height 10 -width 50 -wrap word -font {Helvetica 8}
    #::Display::TileBGFix $WB.r5b

    grid $WB.r0a $WB.r0b - - - - -sticky we -padx 5 -pady 3
    grid $WB.r1a $WB.r1b - - - - -sticky w -padx 5 -pady 2
    pack $WB.r1b1 $WB.r1b2 -side left -in $WB.r1b
    grid    x	  $WB.r2b $WB.r2c $WB.r2d $WB.r2e $WB.r2f
    grid $WB.r3a $WB.r3b $WB.r3c $WB.r3d $WB.r3e $WB.r3f  -sticky ew -padx 5
    grid $WB.r4a $WB.r4b $WB.r4c $WB.r4d $WB.r4e $WB.r4f -sticky ew -padx 5
    grid $WB.r5a $WB.r5b - - - - -padx 5 -pady 5 -sticky news

    grid configure $WB.r1a -sticky we
    grid rowconfigure $WB 5 -weight 1

    ::Display::CenterWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::RideLog::WeekDay
#
# Computes the day of the week based on month, day and year. Puts
# the result into Log(wday).
#
proc ::RideLog::WeekDay {args} {
    set ::RideLog::Log(wday) ""
    catch {
	set when [clock scan $::RideLog::Log(date)]
	set ::RideLog::Log(wday) [clock format $when -format "%A"]
    }
}
##+##########################################################################
#
# ::RideLog::Save
#
# Takes the data from the log dialog and appends it to the log file.
#
proc ::RideLog::Save {} {
    global msg route state nodes roads
    variable Log

    if {$route(title) eq ""} {set route(title) $Log(title)}
    set Log(comments) [.log.body.r5b get 0.0 {end -1 char}]
    set Log(klimb,dist) $msg(dist2)
    set Log(klimb,climb) $msg(climb2)
    set date [clock format [clock scan $Log(date)] -format "%b %e, %Y"]

    # Get all user defined stuff for this route
    ::Route::GetNewStuff nnodes nroads nsplits nphotos

    set turns $route(turns)
    if {[regexp {^B( N)*( E)?$} $turns]} {set turns ""}

    set data "############################################################\n"
    append data "## $state(progname) Ride Log Entry\n"
    append data "Date: $date\n"
    append data "Title: $Log(title)\n"
    append data "Distance: $Log(dist)\n"
    append data "Climbing: $Log(climb)\n"
    append data "Avg: $Log(avg)\n"
    append data "Max: $Log(max)\n"
    append data "Time: $Log(time)\n"
    append data "$state(progname) Distance: $Log(klimb,dist)\n"
    append data "$state(progname) Climbing: $Log(klimb,climb)\n"
    append data "$state(progname) Nodes: $route(nodes)\n"
    append data "$state(progname) Roads: $route(roads)\n"
    if {$turns ne ""} {
	append data "$state(progname) Turns: $turns\n"
    }
    append data "$state(progname) NewNodes:\n"
    append data [::RideLog::ArrayWrap nnodes]
    append data "$state(progname) NewRoads:\n"
    append data [::RideLog::ArrayWrap nroads]
    append data "$state(progname) Splits:\n"
    append data [::RideLog::ArrayWrap nsplits]
    append data "$state(progname) Zone: $state(zone)\n"
    append data "$state(progname) Region: $state(region,multi)\n"
    append data "$state(progname) Mag: $state(mag)\n"
    append data "$state(progname) Version: $state(version)\n"
    append data "Comments: $Log(comments)\n"
    append data "############################################################"

    set logfile $state(logfile)
    set n [catch {set fout [open $logfile a]} err]
    if {$n} {
	WARN "ERROR: cannot open log file: $err"
	return
    }
    puts $fout $data
    close $fout
    DoInfo "This ride information has been added\nto the ride log in $logfile" \
	"KLIMB Ride Log"
    destroy .log

    ::RideLog::QuickRead			;# Reread all the road stats
    return $data
}
##+##########################################################################
#
# ::RideLog::ArrayWrap -- pretty prints an array--sorted and one per line
#
proc ::RideLog::ArrayWrap {n_arr} {
    upvar 1 $n_arr arr				;# Get at array to print

    set result ""
    foreach a [lsort -dictionary [array names arr]] {
	append result "      $a \{$arr($a)\}\n"
    }
    return $result
}
##+##########################################################################
#
# ::RideLog::QuickRead -- quick parse to get date when each rode ridden
#
proc ::RideLog::QuickRead {} {
    global state
    variable RoadLog
    variable RideData
    variable RideCount

    ::RideLog::Exit
    set RideData(who) {}
    set RideCount -1

    if {[catch {set FIN [open $state(logfile) r]} err]} return
    set data [read $FIN]; close $FIN

    regsub -all {\n\s+} $data { } data		;# Handle continuation lines
    set lines [split $data "\n"] ; set len [llength $lines]

    lappend lines {KLIMB Ride Log Entry}	;# Sentinel to flush last entry
    set when [set rroads [set zzone ""]]

    foreach line $lines {
	# Start of a new section, save the values from the last one
	if {[regexp -nocase {KLIMB Ride Log Entry} $line]} {
	    incr RideCount

	    if {$when ne "" && $rroads ne {}} {	;# Put in road info
		if {$zzone eq ""} {set zzone SFBay}
		if {$zzone == $state(zone)} {
		    foreach rid $rroads {
			if {! [string match "X*" $rid]} {
			    lappend RoadLog($rid) $when
			}
		    }
		}
	    }
	    set when [set rroads [set zzone ""]]
	    continue
	}

	# Is it the date?
	if {[regexp -nocase {^Date:\s+(.*)$} $line {} date]} {
	    set n [catch {set when [clock scan $date]} err]
	    if {$n} { set when "" }
	    continue
	}

	# Is it the road info?
	if {[regexp -nocase {^KLIMB Roads:\s(.*)$} $line {} rroads2]} {
	    append rroads " " $rroads2
	    set ltype "road"
	    continue
	}
	if {[regexp -nocase {^KLIMB Zone:\s(.*)$} $line {} zzone]} {
	    continue
	}
    }

    # Now sort each roads log info by date
    foreach rid [array names RoadLog] {
	set RoadLog($rid) [lsort -integer $RoadLog($rid)]
    }
}
##+##########################################################################
#
# ::RideLog::Info
#
# Returns some string versions of the data in RoadLog()
#
proc ::RideLog::Info {what who} {
    variable RoadLog

    if {! [info exists RoadLog($who)]} { return "" }
    if {$what eq "last"} {
	set when [lindex $RoadLog($who) end]
	set txt "\nLast ridden on [clock format $when -format {%m/%d/%y}]"
	return $txt
    }
    if {$what eq "range"} {
	set first [clock format [lindex $RoadLog($who) 0]   -format {%m/%d/%y}]
	set last  [clock format [lindex $RoadLog($who) end] -format {%m/%d/%y}]
	set n [llength $RoadLog($who)]
	if {$n == 1} {
	    set txt "\nRidden once on $first"
	} elseif {$n == 2} {
	    set txt "\nRidden twice between $first and $last"
	} else {
	    set txt "\nRidden $n times between $first and $last"
	}
	return $txt
    }
    return ""
}
##+##########################################################################
#
# ::RideLog::ShowStats -- dialog displaying stats about the log
#
proc ::RideLog::ShowStats {} {
    if {! [::Data::CanDo tktable]} return	;# Shouldn't happen
    if {! [::Data::CanDo statistics]} return

    ::RideLog::GetStats

    set W .rstats
    set WB $W.body
    set WBTN $W.buttons
    if {[winfo exists $W]} return

    set wtitle "$::state(progname) Ride Log Statistics"
    set title "Ride Log Statistics"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::icon klimb.gif] 0
    wm transient $W ${::RideLog::W}

    # First handle buttons
    ::ttk::button $WBTN.refresh -text Refresh -command ::RideLog::GetStats
    ::ttk::button $WBTN.dismiss -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN

    $WB config -borderwidth 4 -relief groove ;#T -pady 0
    set Widget $WB.t

    set rows 8
    set height 8
    set cols 7

    table $Widget -rows $rows -cols $cols -titlerows 2 -titlecols 1 \
	-colstretchmode all -rowstretchmode all \
	-selectmode single -sparsearray 0 \
	-variable ::RideLog::StatTable \
	-coltagcommand ::RideLog::colTagProc \
	-rowtagcommand ::RideLog::rowTagProc \
	-colwidth 8 -state disabled \
	-exportselection 0 -height $height
    $Widget spans 0,5 0,6
    pack $Widget -side top -fill both -expand 1

    ::Display::CenterWindow $W ${::RideLog::W}
    wm deiconify $W
}
proc ::RideLog::GetStats {} {
    variable RideData ; variable StatTable

    # Put in the column headers
    unset -nocomplain StatTable
    array set StatTable {
	0,0 ""       1,0 ""
	0,1 ""	     1,1 Distance
	0,2 ""	     1,2 Climbing
	0,3 Climbing 1,3 Density
	0,4 ""	     1,4 Time
	0,5 Speed    1,5 Avg
	0,6 ""	     1,6 Max

	2,0 Count
	3,0 Sum
	4,0 Mean
	5,0 Max
	6,0 Min
	7,0 StDev
    }

    set col 0
    foreach cname [list distance climbing density "time" avg max] {
	incr col
	set data {}

	foreach who $RideData(who2) {
	    set num $RideData($who,$cname)

	    regsub -all {,} $num {} num
	    if {$cname eq "time"} {
		if {[regexp {^(\d?\d):(\d\d)$} $num => hour min]} {
		    if {[scan "$hour $min" {%d %d} hour min] == 2} {
			set num [expr {$hour * 60 + $min}]
		    } else {
			set num ""
		    }
		} else { set num ""}
	    }
	    if {[string is double -strict $num]} {
		lappend data $num
	    }
	}

	set StatTable(2,$col) [llength $data]
	if {$data eq {}} continue

	set stats [::math::statistics::basic-stats $data]
	foreach {mean min max cnt stdev var} $stats break
	if {$cname eq "time"} {
	    set StatTable(3,$col) [::Data::TimeFormat [expr {$cnt * $mean}]]
	    set StatTable(4,$col) [::Data::TimeFormat $mean]
	    set StatTable(5,$col) [::Data::TimeFormat $max]
	    set StatTable(6,$col) [::Data::TimeFormat $min]
	    set StatTable(7,$col) [Round1 $stdev]
	} else {
	    if {$col < 3} {			;# Skip sum on avg, max, density
		set StatTable(3,$col) [comma [Round1 [expr {$cnt * $mean}]]]
	    }
	    set StatTable(4,$col) [comma [Round1 $mean]]
	    set StatTable(5,$col) [comma [Round1 $max]]
	    set StatTable(6,$col) [Round1 $min]
	    set StatTable(7,$col) [Round1 $stdev]
	}
    }
}
## EON RIDELOG
## BON FILTER
##+##########################################################################
#
# ::Filter::Dialog -- creates the RideLog filter dialog
#
proc ::Filter::Dialog {} {
    variable F
    variable ROWS
    variable W

    if {! [winfo exists $::RideLog::W]} return
    if {! [info exists F(2,val)]} ::Filter::Reset
    set W .filter
    set WB $W.body
    set WBTN $W.buttons
    set title "$::state(progname) Ride Log Filter"
    ::Display::MakeDialogBox $W $title $title [list ::img::icon klimb.gif]
    wm transient $W $::RideLog::W
    wm protocol $W WM_DELETE_WINDOW ::Filter::Exit

    ::ttk::button $WBTN.filter -text "Apply Filter" -command ::Filter::RunFilter
    ::ttk::button $WBTN.reset -text "Reset" -command ::Filter::Reset
    ::ttk::button $WBTN.dismiss -text Dismiss -command ::Filter::Exit
    ::Display::GridChildren $WBTN

    set columns {
	<none> Date Time Title Region Distance Climbing "Climbing Density" \
	"Avg Speed" "Max Speed" "KLIMB Distance" "KLIMB Climbing" Node Road
    }

    for {set row 0} {$row < $ROWS} {incr row} {
	eval tk_optionMenu $WB.opt$row ::Filter::F($row,col) $columns
	$WB.opt$row config -width 13
	tk_optionMenu $WB.op$row ::Filter::F($row,op) "=" "!=" "<" "<=" ">" ">="
	$WB.op$row config -width 2
	::my::entry $WB.e$row -textvariable ::Filter::F($row,val)

	tk_optionMenu $WB.bool$row ::Filter::F($row,bool) "and" "or"
	$WB.bool$row config -width 3

	grid $WB.opt$row $WB.op$row $WB.e$row $WB.bool$row -sticky news
    }
    ::ttk::checkbutton $WB.ignore -text "Skip blank entries" \
	-variable ::Filter::IgnoreNulls
    grid $WB.ignore -sticky w -columnspan 4 -pady {5 0}

    grid forget $WB.bool[expr {$ROWS - 1}]
    grid columnconfigure $WB 0 -minsize 130

    ::Data::UniqueTrace ::Filter::F ::Filter::Tracer
    set F(0,col) $F(0,col)			;# Fire off trace

    ::Display::RightWindow $W $::RideLog::W
    wm deiconify $W
}
##+##########################################################################
#
# ::Filter::DialogToggle -- toggles visibility of Filter dialog
#
proc ::Filter::DialogToggle {} {
    if {$::RideLog::filter} {
	::Filter::Dialog
    } {
	::Filter::Exit
    }
}
##+##########################################################################
#
# ::Filter::Tracer -- trace var to enable/disable widgets
#
proc ::Filter::Tracer {var1 var2 op} {
    variable F
    variable ROWS
    variable W
    variable valid
    set WB $W.body
    set WBTN $W.buttons

    if {! [winfo exists $W]} return
    if {! [string match "*,col" $var2] \
	    && ! [string match "*,val" $var2] \
	    && ! [string match "*,op" $var2]} return
    ::Data::UniqueTrace ::Filter::F

    # Find first non-blank row
    for {set valid 0} {$valid < $ROWS} {incr valid} {
	if {$F($valid,col) eq "<none>" || $F($valid,val) eq ""} break
    }

    for {set row 0} {$row < $ROWS} {incr row} {
	if {($F($row,col) eq "Node" || $F($row,col) eq "Road")
	    && $F($row,op) ne "="} {
	    set F($row,op) "="
	}
	set how [expr {$row <= $valid ? "normal" : "disabled"}]
	$WB.opt$row config -state $how
	$WB.op$row config -state $how
	$WB.e$row config -state $how
	$WB.bool$row config -state $how
    }
    if {$valid < $ROWS} {
	$WB.bool$valid config -state disabled
    }
    if {$valid > 0} {
	$WB.bool[expr {$valid - 1}] config -state disabled
    }
    $WBTN.filter config -state [expr {$valid > 0 ? "normal" : "disabled"}]
    ::Data::UniqueTrace ::Filter::F ::Filter::Tracer
}
##+##########################################################################
#
# ::Filter::Exit -- cleans up on filter exit
#
proc ::Filter::Exit {} {
    set ::RideLog::filter 0
    set ::Filter::valid -1
    destroy $::Filter::W
    ::Filter::RunFilter
}
##+##########################################################################
#
# ::Filter::RunFilter -- applies our filter to the ride log
#
proc ::Filter::RunFilter {} {
    if {! [winfo exists $::RideLog::W]} return
    ::RideLog::Data2Table
}
##+##########################################################################
#
# ::Filter::ApplyFilters -- applies all valid filters to one ridelog entry
#
proc ::Filter::ApplyFilters {lid} {
    variable F
    variable valid

    if {$valid <= 0} {return 1}

    set bool [::Filter::OneFilter $lid 0]
    set op $F(0,bool)
    for {set i 1} {$i < $valid} {incr i} {
	set b [::Filter::OneFilter $lid $i]
	if {$op eq "and"} {
	    set bool [expr {$bool && $b}]
	} else {
	    set bool [expr {$bool || $b}]
	}
	set op $F($i,bool)
    }
    return $bool
}
##+##########################################################################
#
# ::Filter::OneFilter -- applies one filter to a ridelog entry
#
proc ::Filter::OneFilter {lid fid} {
    variable LABELS2COLUMNS
    variable IgnoreNulls
    variable F

    set col $F($fid,col)
    if {$col eq "<none>"} {return 1}

    set val [string trim $::RideLog::RideData($lid,$LABELS2COLUMNS($col))]
    if {$val eq ""} {return [expr {! $IgnoreNulls}]}
    set op $F($fid,op); if {$op eq "="} {set op "=="}
    set val2 $F($fid,val2)

    if {$col eq "Region"} {			;# This is a list
	if {[llength $val] > 1} {
	    if {$op eq "=="} { return 0}	;# Can't exact match
	    if {$op eq ">=" || $op eq "<="} {set op "in"}
	    foreach v $val {
		if {$v eq $val2} { return [expr {$op eq "in"}]}
	    }
	    return [expr {$op ne "in"}]
	}
	set val [lindex $val 0]			;# Just use first entry
    }

    if {$col eq "Title" || $col eq "Region"} {
	switch -exact -- $op {
	    >  {set result [expr {$val >  $val2}]}
	    >= {set result [expr {$val >= $val2}]}
	    == {set result [expr {$val == $val2}]}
	    eq {set result [expr {$val == $val2}]}
	    != {set result [expr {$val != $val2}]}
	    <= {set result [expr {$val <= $val2}]}
	    <  {set result [expr {$val <  $val2}]}
	}
	return $result
    } elseif {$col eq "Node" || $col eq "Road"} {
	set n [lsearch $val $val2]
	return [expr {$n == -1 ? 0 : 1}]
    } elseif {$col eq "Time"} {
	set n [regexp {^(\d\d):(\d\d)$} $val => hours minutes]
	if {! $n} {return [expr {! $IgnoreNulls}] } ;# Bad time
	set val [expr {$hours * 60 + $minutes}]
    } elseif {$col eq "Date"} {
	set n [catch {set val [clock scan $val]}]
	if {$n} {return [expr {! $IgnoreNulls}] } ;# Bad date
    } elseif {$col eq "KLIMB Distance" || $col eq "KLIMB Climbing"} {
	set val [::BadMath::Real $val]
    } else {
	set val [string map {, ""} $val]
    }
    if {! [string is double -strict $val]} {return [expr {! $IgnoreNulls}]}

    set result [expr $val $op $val2]
    #puts "$val $op $F($fid,val) => $result"
    return $result
}
##+##########################################################################
#
# ::Filter::ValidateFilters -- make sure filters are valid
#
proc ::Filter::ValidateFilters {} {
    variable F
    variable valid

    set hdr "Ride Log Filter Error:"
    for {set i 0} {$i < $valid} {incr i} {
	set col $F($i,col)
	set val [string trim $F($i,val)]

	if {$col eq "Date"} {
	    if {[string is integer -strict $val] &&
		[string length $val] eq 4} {	;# Looks like a bare year
		set val "1/1/$val"
	    }
	    set n [catch {set date [clock scan $val]}]
	    if {$n} {
		WARN "$hdr\nDon't understand date '$val'"
		return 0
	    }
	    set F($i,val2) $date
	} elseif {$col eq "Time"} {
	    set n [regexp {^(\d\d):(\d\d)$} $val => hours minutes]
	    if {! $n} {
		WARN "$hdr\nDon't understand time '$val'"
		return 0
	    }
	    set F($i,val2) [expr {$hours * 60 + $minutes}]
	} elseif {$col eq "Region" || $col eq "Title"} {
	    set F($i,val2) $val
	} elseif {$col eq "Node"} {
	    set val2 [::Edit::FindNode $val]
	    if {$val2 eq ""} {
		WARN "$hdr\nUnknown node '$val'"
		return 0
	    }
	    set F($i,val2) $val2
	} elseif {$col eq "Road"} {
	    if {[info exists ::roads($val)]} {
		set val2 $val
	    } elseif {[info exists ::roads(r$val)]} {
		set val2 "r$val"
	    } else {
		WARN "$hdr\nUnknown road '$val'"
		return 0
	    }
	    set F($i,val2) $val2
	} else {
	    set val [string map {, ""} $val]	;# Un-commafy
	    if {! [string is double -strict $val]} {
		WARN "$hdr\nBad number '$val'"
		return 0
	    }
	    set F($i,val2) $val
	}
    }
    return 1
}
##+##########################################################################
#
# ::Filter::Reset -- resets all filters to start state
#
proc ::Filter::Reset {} {
    variable F
    variable ROWS

    unset -nocomplain F
    ::Data::UniqueTrace ::Filter::F

    array set F {0,col "Distance" 0,op ">" 0,val 30}
    for {set row 1} {$row < $ROWS} {incr row} {
	set F($row,col) "<none>"
	set F($row,op) "="
	set F($row,val) ""
	set F($row,bool) "and"
    }
    ::Data::UniqueTrace ::Filter::F ::Filter::Tracer
}
## EON FILTER
## BON DATEFIELD
##+##########################################################################
#
# ::Datefield::datefield
#
# Entry widget coerced into only handling dates
#
proc ::Datefield::datefield {w args} {
    eval ::my::entry $w -width 10 -justify center $args
    $w delete 0 end				;# Clear any linked var junk
    $w insert end [clock format [clock seconds] -format "%m/%d/%Y"]
    $w icursor 0

    bind $w <KeyPress> [list ::Datefield::dfKeyPress $w %A %K %s]
    bind $w <FocusIn> "$w selection clear; $w icursor 0"
    bind $w <Button1-Motion> break
    bind $w <Shift-Button-1> break
    bind $w <Button2-Motion> break
    bind $w <Double-Button>  break
    bind $w <Triple-Button>  break
    bind $w <2>              break

    return $w
}
proc ::Datefield::timefield {w args} {
    eval ::my::entry $w -width 5 -justify center $args
    $w delete 0 end				;# Clear any linked var junk
    $w insert end "00:00"
    $w icursor 0

    bind $w <KeyPress> [list ::Datefield::tfKeyPress $w %A %K %s]
    bind $w <FocusIn> "$w selection clear; $w icursor 0"
    bind $w <Button1-Motion> break
    bind $w <Shift-Button-1> break
    bind $w <Button2-Motion> break
    bind $w <Double-Button>  break
    bind $w <Triple-Button>  break
    bind $w <2>              break

    return $w
}
##+##########################################################################
#
# ::Datefield::dfKeyPress
#
# Handles keypress in a datefield entry widget.
#
proc ::Datefield::dfKeyPress {w char sym state} {

    variable pos
    variable cformat
    set icursor [$w index insert]

    # Handle some non-number characters first
    if {$sym eq "plus" || $sym eq "Up" || \
	    $sym eq "minus" || $sym eq "Down"} {
	set dir "1 day"
	if {$sym eq "minus" || $sym eq "Down"} {
	    set dir "-1 day"
	}
	set base [clock scan [::Datefield::Normalize [$w get]]]
	if {[catch {set new [clock scan $dir -base $base]}] != 0} {
	    bell
	    return -code break
	}
	set xdate [clock format $new -format "%m/%d/%Y"]
	if {[catch {clock scan $xdate}]} {
	    bell
	    return -code break
	}
	$w delete 0 end
	$w insert end [clock format $new -format $cformat]
	$w icursor $icursor
	return -code break
    } elseif {$sym eq "Right" || $sym eq "Left" || $sym eq "BackSpace" || \
		  $sym eq "Delete"} {
	set dir -1
	if {$sym eq "Right"} {set dir 1}

	set icursor [expr {($icursor + $pos(len) + $dir) % $pos(len)}]
	;# Don't land on a slash
	if {$icursor == $pos(m2) || $icursor == $pos(d2) \
		|| $icursor == $pos(y2)} {
	    set icursor [expr {($icursor + $pos(len) + $dir) % $pos(len)}]
	}
	$w icursor $icursor
	return -code break
    } elseif {($sym eq "Control_L") || ($sym eq "Shift_L") || \
		  ($sym eq "Control_R") || ($sym eq "Shift_R")} {
	return -code break
    } elseif {$sym eq "Home"} {
	$w icursor 0
	return -code break
    } elseif {$sym eq "End"} {
	$w icursor end
	return -code break
    } elseif {$sym eq "Tab" || $sym eq "ISO_Left_Tab"} {;# Tab key
	return -code continue			;# Just leave the widget
    } elseif {$sym eq "Tab" && ($state & (0x01 + 0x04)) == 0} {;# Tab key
	if {$icursor == $pos(len)} {return -code continue}

	if {$icursor >= $pos(m1) && $icursor < $pos(m2)} {
	    set cursor $pos(m2)
	} elseif {$icursor >= $pos(d1) && $icursor < $pos(d2)} {
	    set cursor $pos(d2)
	} else {
	    set cursor $pos(y2)
	}
	if {[incr cursor] >= $pos(len)} {
	    return -code continue           ;# Tabbed out of the widget
	}
	$w icursor $cursor
	return -code break
    } elseif {$sym eq "Tab" && ($state && (0x01 + 0x04)) != 0} {
	return -code continue               ;# Just leave the widget
	set cursor -1
	if {$icursor > $pos(m2) && $pos(m1) > $cursor} {set cursor $pos(m1)}
	if {$icursor > $pos(d2) && $pos(d1) > $cursor} {set cursor $pos(d1)}
	if {$icursor > $pos(y2) && $pos(y1) > $cursor} {set cursor $pos(y1)}
	if {$cursor < 0} {
	    return -code continue           ;# Tabbed out of the widget
	}
	$w icursor $cursor
	return -code break
    }

    if {! [regexp {[0-9]} $char]} {         ;# Unknown character
	bell
	return -code break
    }

    if {$icursor >= $pos(len)} {             ;# Can't add beyond end
	bell
	return -code break
    }
    foreach {month day year} [split [::Datefield::Normalize [$w get]] "/"] break
    #puts "[$w get] => [Normalize [$w get]] = $month/$day/$year"
    # MONTH SECTION
    if {$icursor >= $pos(m1) && $icursor < $pos(m2)} {
	#puts "in month"
	foreach {m1 m2} [split $month ""] break
	set cursor [expr {$pos(m2) + 1}]    ;# Where to leave the cursor

	if {$icursor == $pos(m1)} {         ;# 1st digit of month
	    if {$char < 2} {
		set month "$char$m2"
		set cursor [expr {$pos(m1) + 1}]
	    } else {
		set month "0$char"
	    }
	    if {$month > 12} {set month 10}
	    if {$month eq "00"} {set month "01"}
	} else {                            ;# 2nd digit of month
	    set month "$m1$char"
	    if {$month > 12} {set month "0$char"}
	    if {$month eq "00"} {
		bell
		return -code break
	    }
	}
	$w delete $pos(m1) $pos(m2)
	$w insert $pos(m1) $month

	# Validate the day of the month
	if {$day > [set endday [::Datefield::lastDay $month $year]]} {
	    $w delete $pos(d1) $pos(d2)
	    $w insert $pos(d1) $endday
	}
	$w icursor $cursor

	return -code break
    }
    # DAY SECTION
    if {$icursor >= $pos(d1) && $icursor < $pos(d2)} {
	#puts "in day"
	set endday [::Datefield::lastDay $month $year]
	foreach {d1 d2} [split $day ""] break
	set cursor [expr {$pos(d2) + 1}]    ;# Where to leave the cursor

	if {$icursor <= $pos(d1)} {         ;# 1st digit of day
	    if {$char < 3 || ($char == 3 && $month ne "02")} {
		set day "$char$d2"
		if {$day eq "00"} { set day "01" }
		if {$day > $endday} {set day $endday}
		set cursor [expr {$pos(d1) + 1}]
	    } else {
		set day "0$char"
	    }
	} else {                            ;# 2nd digit of day
	    set day "$d1$char"
	    if {$day > $endday || $day eq "00"} {
		bell
		return -code break
	    }
	}
	$w delete $pos(d1) $pos(d2)
	$w insert $pos(d1) $day
	$w icursor $cursor
	return -code break
    }

    # YEAR SECTION
    set y1 [string index $year 0]
    if {$icursor == $pos(y1)} {             ;# 1st digit of year
	if {$char ne "1" && $char ne "2"} {
	    bell
	    return -code break
	}
	if {$char != $y1} {                 ;# Different century
	    set y 1999
	    if {$char eq "2"} {set y 2000 }
	    $w delete $pos(y1) $pos(y2)
	    $w insert $pos(y1) $y
	}
	$w icursor [expr {$pos(y1) + 1}]
	return -code break
    }
    $w delete $icursor
    $w insert $icursor $char
    if {[catch {clock scan [::Datefield::Normalize [$w get]]}] != 0} {;# Validate year
	$w delete $pos(y1) $pos(y2)
	$w insert $pos(y1) $year             ;# Put back in the old year
	$w icursor $icursor
	bell
	return -code break
    }
    if {$icursor == $pos(y2)-1} {
	$w icursor [expr {$icursor + 2}]
    }
    return -code break
}
##+##########################################################################
#
# ::Datefield::Normalize -- converts date to canonical form
#
proc ::Datefield::Normalize {date} {
    variable pos
    set m [string range $date $pos(m1) [expr {$pos(m2) - 1}]]
    set d [string range $date $pos(d1) [expr {$pos(d2) - 1}]]
    set y [string range $date $pos(y1) [expr {$pos(y2) - 1}]]
    return "$m/$d/$y"
}
##+##########################################################################
#
# ::Datefield::lastDay -- Returns the last valid day in a given month and year.
#
proc ::Datefield::lastDay {month year} {
    return [clock format [clock scan "$month/1/$year + 1 month - 1 day"] \
		-format %d]
}
##+##########################################################################
#
# ::Datefield::tfKeyPress
#
# Handles keypress in a timefield entry widget.
#
proc ::Datefield::tfKeyPress {w char sym state} {
    if {[$w selection present]} {
	$w selection clear
	$w icursor 0
    }
    set icursor [$w index insert]
    scan [$w get] "%d:%d" hour minute

    # Handle some non-number characters first
    if {$sym eq "plus" || $sym eq "Up" || $sym eq "minus" || $sym eq "Down"} {
	set dir 1
	if {$sym eq "minus" || $sym eq "Down"} {
	    set dir -1
	}
	if {$icursor < 2} {
	    incr hour $dir
	    if {$hour < 0} {set hour 0}
	} else {
	    incr minute $dir
	    if {$minute >= 60} {
		incr minute -60
		incr hour 1
	    } elseif {$minute < 0} {
		incr minute 60
		incr hour -1
	    }
	}
	if {$hour < 0} { set hour 0;  set minute 0}
	if {$hour > 99} { set hour 0 }
	$w delete 0 end
	$w insert end [format "%02d:%02d" $hour $minute]
	$w icursor $icursor
	return -code break
    } elseif {$sym eq "Right" || $sym eq "Left" || $sym eq "BackSpace" || \
		  $sym eq "Delete"} {
	set dir -1
	if {$sym eq "Right"} {set dir 1}

	set icursor [expr {($icursor + 5 + $dir) % 5}]
	if {$icursor == 2} {			;# Don't land on a colon
	    set icursor [expr {($icursor + 5 + $dir) % 5}]
	}
	$w icursor $icursor
	return -code break
    } elseif {($sym eq "Control_L") || ($sym eq "Shift_L") || \
		  ($sym eq "Control_R") || ($sym eq "Shift_R")} {
	return -code break
    } elseif {$sym eq "Tab" && $state == 0} {	;# Tab key
	return -code continue			;# Always skip to next widget
	if {$icursor < 3} {
	    $w icursor 3
	} else {
	    return -code continue
	}
	return -code break
    } elseif {$sym eq "Tab" && ($state == 1 || $state == 4)} { ;# Shift/ctrl tab
	return -code continue			;# Always skip to next widget
	if {$icursor > 1} {
	    $w icursor 0
	} else {
	    return -code continue
	}
	return -code break
    }

    if {! [regexp {[0-9]} $char]} {		;# Unknown character
	bell
	return -code break
    }

    if {$icursor == 5} {set icursor 4}
    if {$icursor >= 5} {		      ;# Can't add beyond end
	bell
	return -code break
    }

    # HOUR SECTION
    if {$icursor < 2} {
	$w delete $icursor
	$w insert $icursor $char
	if {[$w index insert] == 2} {
	    $w icursor 3
	}
	return -code break
    }
    # MINUTE SECTION
    if {$icursor < 5} {				;# DAY
	$w delete $icursor
	$w insert $icursor $char
	scan [$w get] "%d:%d" hour minute
	if {$minute >= 60} {
	    incr minute -60
	    incr hour 1
	    $w delete 0 end
	    $w insert end [format "%02d:%02d" $hour $minute]
	    $w icursor [incr icursor 1]
	}
	return -code break
    }
}
## EON DATEFIELD
## BON POI
##+##########################################################################
#
# ::POI::Type2Text
#
# Converts the one-letter POI types into a human readable format.
#
proc ::POI::Type2Text {type name} {
    array set types {W water B bathrooms F food H "historical marker"}
    set types(X) $name
    if {$name eq {}} { set types(X) "Point of Interest" }

    set txt ""
    foreach letter [split [string toupper $type] ""] {
	if {[info exists types($letter)]} {
	    append txt ", $types($letter)"
	}
    }
    if {$txt eq {}} { set txt ", point of interest" }
    set txt [string range $txt 2 end]		;# Remove leading comma
    regsub {(.*), } $txt {\1 and } txt		;# Trailing comma => and
    if {! [regexp {[A-Z]} $txt]} {
	set txt [string totitle $txt]
    }

    return $txt
}
##+##########################################################################
#
# ::POI::ShowInfo -- POI info dialog
#
proc ::POI::ShowInfo {p} {
    global poi

    set W .poi
    set WB $W.body
    set WBTN $W.buttons

    foreach {type name lat lon location ldesc xy url} $poi($p) break
    set title [::POI::Type2Text $type $name]
    set wtitle "$::state(progname) Point of Interest"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::poi poi.gif] 0

    set txt $ldesc
    if {$location ne {}} { set txt "At $location\n\n$ldesc" }
    #if {[string length $title] < 20} { $W.title config -width 20 }
    set width [winfo reqwidth $W.title]
    if {[string length $ldesc] > 100} {set width 300}
    message $WB.txt -text $txt -anchor w -width $width
    ::Display::TileBGFix $WB.txt
    ::ttk::button $WB.web -text "View Web Page" \
	-command [list ::POI::GoWeb $url]
    ::ttk::button $WBTN.zoom -text "Zoom" \
	-command "destroy $W ; ::Zoom::Go poi $p"
    ::ttk::button $WBTN.view -text "Google Maps" \
	-command "destroy $W ; ::Zoom::Google poi $p"

    ::ttk::button $WBTN.dismiss -text "Dismiss" -command [list destroy $W]

    pack $WB.txt -side top -fill both -expand 1
    if {$url ne ""} {
	pack $WB.web -side top -pady 10
    }
    ::Display::GridChildren $WBTN 0

    ::Display::CenterWindow $W
    wm deiconify $W
}
proc ::POI::GoWeb {url} {
    destroy .poi
    WebPage $url
}
## EON POI
## BON PRINT
##+##########################################################################
#
# ::Print::Dialog -- Front end to printing (via the printer and gdi packages)
#  what: map profile zoom
#
proc ::Print::Dialog {{what map}} {
    variable WhyNot
    variable postit 0
    global state

    if {! [::Print::CanPrint]} {
	WARN $WhyNot
	.m.file entryconfig "Print..." -state disabled
	return
    }

    foreach img {printer portrait landscape qHigh qMedium qDraft} {
	::Display::MakeImage ::img::$img $img.gif
    }

    set W .print
    set WB $W.body
    set WBTN $W.buttons
    set title "$::state(progname) Print"
    ::Display::MakeDialogBox $W $title $title [list ::img::printer printer.gif] 0
    wm protocol $W WM_DELETE_WINDOW ::Print::Done

    ::ttk::button $WBTN.print -command [list ::Print::PrintIt $what]
    ::ttk::button $WBTN.dismiss -text "Dismiss" -command ::Print::Done
    ::Display::GridChildren $WBTN 1

    if {$what eq "map"} {
	set txt "Adjust the display what match what you want printed\n"
	append txt "then press the \"Print\" button."
	$W.buttons.print config -text "Print Map"
    } elseif {$what eq "profile"} {
	set txt "This will print the current Route Profile Chart."
	$W.buttons.print config -text "Print Profile"
    } elseif {$what eq "zoom"} {
	set txt "This will print the current zoomed map."
	$W.buttons.print config -text "Print Zoom Map"
    }
    ::my::label $W.msg -text $txt -anchor w -justify left

    ::my::labelframe $W.orient -text "Orientation"
    ::my::labelframe $W.quality -text "Quality"
    ::my::labelframe $W.hide -text "What to Print"
    ::my::labelframe $W.ann -text "Annotations"

    ::my::label $W.lland -image ::img::landscape
    ::ttk::radiobutton $W.land -variable ::Print::orientation -value landscape \
	-text "Landscape"
    ::my::label $W.lport -image ::img::portrait
    ::ttk::radiobutton $W.port -variable ::Print::orientation -value portrait \
	-text "Portrait"
    ::ttk::radiobutton $W.auto -variable ::Print::orientation -value automatic \
	-text "Automatic"

    ::my::label $W.iquality -image ::img::q$::Print::quality
    foreach w {q0 q1 q2} v {High Medium Draft} t {High Standard Draft} {
	::ttk::radiobutton $W.$w -var ::Print::quality -value $v \
	    -text $t -command [list $W.iquality config -image ::img::q$v]
    }

    ::ttk::radiobutton $W.cbmaps -variable ::Print::PrintScreen \
	-text "Print whole screen" -command ::Print::Select -value 1
    ::ttk::radiobutton $W.cbselect -variable ::Print::PrintScreen \
	-text "Print selected region\n(single screen only)" \
	-command ::Print::Select -value 0
    if {$what eq "map"} ::Print::Select
    ::ttk::checkbutton $W.cbhide -variable ::Print::hide \
	-text "Hide other roads" -command ::Print::Hide
    if {$::route(start) == -1} {
	$W.cbhide config -state disabled
    } elseif {$what eq "map"} ::Print::Hide

    # Annotations
    ::ttk::checkbutton $W.postit -variable ::Postit::Details(onoff) \
	-text "Add Annotations" -command [list ::RInfo::Postit $W.ann]
    grid $W.postit -in $W.ann -sticky w
    set buttons {rnames "Road Names" rdist "Road distances"
	rclimb "Road climbing"	nnames "Node names" nelev "Node Altitudes"}
    set s [expr {$::Postit::Details(onoff) ? "normal" : "disabled"}]
    foreach {var lbl} $buttons {
	::ttk::checkbutton $W.ann.$var -text $lbl \
	    -variable ::Postit::Details($var) \
	    -command ::Postit::DoRoute -state $s
	grid $W.ann.$var -padx 20 -sticky w
    }

    grid $W.msg - -sticky news -in $W.body -row 0
    grid $W.orient $W.quality -sticky news -pady 10 -in $W.body -padx 5
    grid config $W.orient -padx {0 5}
    if {$what eq "map"} {
	grid $W.hide $W.ann -sticky news -in $W.body -padx 5
	grid config $W.hide -padx {0 5}
    }

    grid x $W.lport $W.port -in $W.orient -row 1 -sticky nw
    grid x $W.lland $W.land -in $W.orient -sticky nw
    grid x x $W.auto -in $W.orient -sticky nw
    grid rowconfigure $W.orient 100 -weight 1
    grid columnconfigure $W.orient 0 -pad 10
    grid columnconfigure $W.orient 100 -weight 1

    grid x $W.iquality $W.q0 -in $W.quality -row 1 -sticky nw
    grid x ^ $W.q1 -in $W.quality -sticky w
    grid x ^ $W.q2 -in $W.quality -sticky w
    grid columnconfigure $W.quality 0 -pad 10
    grid columnconfigure $W.quality 100 -weight 1

    grid $W.cbselect -in $W.hide -sticky w -padx 10
    grid $W.cbmaps -in $W.hide -sticky w -padx 10
    grid $W.cbhide -in $W.hide -sticky w -padx 10
    grid columnconfigure $W.hide 0 -pad 10
    grid columnconfigure $W.hide 100 -weight 1
    grid rowconfigure $W.hide 100 -weight 1

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Print::GuessPageSize -- Extracts page info from the printer attributes
# NB. units are 1,000 of an inch
#
proc ::Print::GuessPageSize {} {
    global state

    while {1} {
	if {! [::Data::CanDo printMaps]} break

	# Allow user to override computed values
	if {[string is integer -strict $state(printer,width,user)] &&
	    [string is integer -strict $state(printer,height,user)]} {

	    set state(printer,width) $state(printer,width,user)
	    set state(printer,height) $state(printer,height,user)
	    break
	}

	# Put in some sane values
	foreach pw 8500 ph 11000 lm 0 tm 0 rm 250 bm 250 ppiW 300 ppiH 300 break

	foreach datum [printer attr] {
	    foreach {key val} $datum break
	    if {$key eq "pixels per inch"} {
		foreach {ppiW ppiH} $val break
	    } elseif {$key eq "page minimum margins"} {
		foreach {lm tm rm bm} $val break
	    } elseif {$key eq "page dimensions"} {
		foreach {pw ph} $val break
	    }
	}
	set state(printer,width) [expr {($pw - $lm - $rm) * $ppiW / 1000}]
	set state(printer,height) [expr {($ph - $tm - $bm) * $ppiH / 1000}]
	break
    }
    return [list $state(printer,width) $state(printer,height) $ppiH]
}
##+##########################################################################
#
# ::Print::GetOrientation -- returns orientation for printing, if
# "automatic" then we use whichover produces the larger map.
#
proc ::Print::GetOrientation {} {
    variable orientation
    variable margins
    variable sxy

    if {$orientation ne "automatic"} {return $orientation }

    set margin [expr {$margins(top) + $margins(bottom)}]
    set wx $sxy(w)				;# Image to print dimensions
    set wy $sxy(h)

    set px $::state(printer,width)		;# Portrait dimensions
    set py $::state(printer,height)
    set sx [expr {double($px) / $wx}]		;# Scale in both directions
    set sy [expr {double($py - $margin) / $wy}]
    set Pscaler [expr {$sx < $sy ? $sx : $sy}]	;# Use minimum scale factor

    set ly $::state(printer,width)		;# Landscape dimensions
    set lx $::state(printer,height)
    set sx [expr {double($lx) / $wx}]		;# Scale in both directions
    set sy [expr {double($ly - $margin) / $wy}]
    set Lscaler [expr {$sx < $sy ? $sx : $sy}]	;# Use minimum scale factor

    return [expr {$Pscaler > $Lscaler ? "portrait" : "landscape"}]
}
##+##########################################################################
#
# ::Print::PrintIt -- Prints the current window using Michael Schwart's
# extensions GDI/HDC/Printer http://www.du.edu/~mschwart/tclextensions.html
# http://www.schwartzcomputer.com/tcl-tk/tcl-tk.html
#
proc ::Print::PrintIt {what} {
    global state msg
    variable orientation; variable quality; variable PrintScreen; variable sxy
    variable margins

    if {$what eq "map"} {
	set who .c
	set title $state(title)
    } elseif {$what eq "profile"} {
	set who .pro.c
	set title "$state(progname) Route Profile"
    } elseif {$what eq "zoom"} {
	set who .zoom.c
	set title "$state(progname) : $::Zoom::DS(title)"
    }
    set copyright "Map created with KLIMB "
    append copyright "\u00A9[clock format [clock seconds] -format %Y] "
    append copyright "http://www.klimb.org"

    if {$what eq "map" && ! $PrintScreen} {
	set xy [::pBox::Done $who]		;# Screen coords to print
	set doSelection 1
    } else {
	set xy [list 0 0 [winfo width $who] [winfo height $who]] ;# What to print
	set doSelection 0
    }

    foreach {sxy(x0) sxy(y0) sxy(x1) sxy(y1)} $xy break
    set sxy(w) [expr {$sxy(x1) - $sxy(x0)}]
    set sxy(h) [expr {$sxy(y1) - $sxy(y0)}]
    set sxy(Y) [expr {[winfo height $who] - $sxy(y1)}] ;# Bottom-coords

    destroy .print ; update			;# Avoid printing our dialog
    foreach {hdc status} [printer dialog select] break ;# Pick printer to use
    if {! $status} { return [::Print::Done] }

    foreach {px py ppiH} [::Print::GuessPageSize] break
    set orient [::Print::GetOrientation]
    printer attr -set [list [list "page orientation" $orient]]
    printer attr -set [list [list "resolution" $quality]]
    printer job start -name $title
    printer page start
    update					;# Make sure dialog disappears

    if {$orient eq "landscape"} {
	foreach {px py} [list $py $px] break
    }
    set px2 [expr {$px/2}]
    set pHeight $py

    gdi text $hdc $px $py -text $copyright -anchor se -font {Times 8}
    set tm [gdi text $hdc $px2 0 -text $title -anchor n -font {Times 18}]
    set bm [expr {$tm*2 + $ppiH/16}]		;# Force room at the bottom
    incr py -$tm				;# Subtract top margin
    incr py -$bm				;# Subtract bottom margin

    set sx [expr {double($px) / $sxy(w)}]	;# Scale in both directions
    set sy [expr {double($py) / $sxy(h)}]
    set xyscale [Min $sx $sy]			;# Use minimum scale factor
    set rm [expr {($px - ($xyscale *$sxy(w))) / 2}] ;# Center left and right

    if {$doSelection} {
	gdi copybits $hdc -window $who -scale $xyscale -destination "$rm $tm" \
		     -client -source [list $sxy(x0) $sxy(Y) $sxy(w) $sxy(h)]
    } else {
	gdi copybits $hdc -window $who -scale $xyscale -destination "$rm $tm" \
		     -client
    }
    # Draw a bounding box on the map
    set y [expr {$tm + $sxy(h) * $xyscale}]
    gdi rectangle $hdc $rm $tm [expr {$rm + $sxy(w) * $xyscale}] $y -width 3
    set space [expr {$pHeight - $y}]

    # Give route info if there is room
    if {$what eq "map" && $::route(start) != -1} {
	set t "Distance: $msg(dist)\nClimbing: $msg(climb)\nDescent: $msg(desc)"
	if {$space >= 68} {			;# Room for at least 1 line
	    if {$space < 136} {			;# Only 1 line
		regsub -all {\n} $t " " t
	    } elseif {$space < 204} {		;# Only 2 lines (204=3*68)
		regsub {(.*)\n} $t "\\1  " t
	    }
	    gdi text $hdc 0 $y -anchor nw -text $t -font {Times 12}
	}
    }

    # Draw a scale with width 1/2 of the page width
    if {$what eq "map"} {			;# Draw a scale
	destroy .__print_scale
	canvas .__print_scale
	::Display::DoScale .__print_scale [expr {$sxy(w) * .5}]

	set x [expr {$px / 2.0}]
	::Print::PrintCanvas .__print_scale $x $y $xyscale $hdc
	destroy .__print_scale
    }
    printer page end
    printer job end
    printer close
    ::Print::Done
}
##+##########################################################################
#
# ::Print::PrintCanvas -- prints the contents of a canvas (line and text only)
#
proc ::Print::PrintCanvas {w NX NY scaler hdc} {
    set width [$w cget -width]
    set height [$w cget -height]

    set nx [expr {$width / 2.0}]		;# North anchor coords
    set ny 0

    foreach id [$w find all] {			;# Look at every item
	set type [$w type $id]
	set nxy {}
	foreach {x y} [$w coords $id] {		;# Translate/scale everything
	    set x [expr {$scaler * ($x - $nx) + $NX}]
	    set y [expr {$scaler * ($y - $ny) + $NY}]
	    lappend nxy $x $y
	}
	if {$type eq "line"} {
	    eval gdi line $hdc $nxy -width 3
	} elseif {$type eq "text"} {
	    eval gdi text $hdc $nxy -anchor [$w itemcget $id -anchor] \
		-text [list [$w itemcget $id -text]] -font {{Times 8}}
	}
    }
    return [expr {$height * $scaler}]
}
##+##########################################################################
#
# ::Print::CanPrint -- determines if we can print. Currently only for Windows
#
proc ::Print::CanPrint {{quick 0}} {
    global state
    variable WhyNot

    if {[info exists state(can,printMaps)]} { return $state(can,printMaps)}

    if {! $state(windows)} {
	set state(can,printMaps) 0
	set WhyNot "Printing is not available for this operating system"
	return 0
    }
    if {$quick} {return 1}

    if {! [catch {package require printer}] \
		  && ! [catch {package require gdi}]} {
	if {[::Data::IsPriviledged "printing"]} {
	    set state(can,printMaps) 1
	    set WhyNot ""
	} else {
	    set state(can,printMaps) 0
	    set WhyNot "Printing is not enabled in this version."
	    append WhyNot "\n\nFor information about enabling printing,\n"
	    append WhyNot "see the \"Printing Maps\" help section."
	}
    } else {
	set state(can,printMaps) 0
	set WhyNot "You are missing the printer extensions\nto enable printing."
	append WhyNot "\n\nFor information about enabling printing,\n"
	append WhyNot "see the \"Printing Maps\" help section."
    }
    return $state(can,printMaps)
}
##+##########################################################################
#
# ::Print::Hide -- hides all roads and nodes not on the current route
#
proc ::Print::Hide {{how {}}} {
    global nodes roads route

    if {$how eq {}} {set how $::Print::hide}

    if {$how} {
	.c lower roads
	.c lower nodes

	foreach rid $route(roads) {
	    .c raise road_$rid
	}
	foreach nid $route(nodes) {
	    .c raise node_$nid
	    .c raise text_$nid
	}
    } else {
	::Display::Raise
    }
}
;# ##+##########################################################################
;# #
;# # ::Print::Postit -- toggles route annotations
;# #
;# proc ::Print::Postit {W} {
;#     ::Postit::DoRoute
;#     set s [expr {$::Postit::Details(onoff) ? "normal" : "disabled"}]
;#     foreach w [winfo child $W] {
;# 	$w config -state $s
;#     }
;# }
##+##########################################################################
#
# ::Print::Done -- cleans up from the print dialog
#
proc ::Print::Done {} {
    ::Print::Hide 0
    destroy .print
    ::pBox::Done .c
}
##+##########################################################################
#
# ::Print::Select -- toggles the print selection display
#
proc ::Print::Select {} {
    variable PrintScreen

    if {$PrintScreen} {
	::pBox::Done .c
    } else {
	::pBox::Create .c
    }
}
## EON PRINT
## BON PBOX
##+##########################################################################
#
# ::pBox::Create -- creates the print box on top of canvas W
#
proc ::pBox::Create {W} {
    variable xy
    variable CURSORS
    variable bdown 0

    # Get initial location
    set w [winfo width $W]
    set h [winfo height $W]

    set x0 [$W canvasx 0]
    set y0 [$W canvasy 0]
    set x1 [expr {int($x0 + $w - $w / 8)}]
    set y1 [expr {int($y0 + $h - $h / 8)}]
    set x0 [expr {int($x0 + $w / 8)}]
    set y0 [expr {int($y0 + $h / 8)}]
    set xy [list $x0 $y0 $x1 $y1]

    # Create stubs items that ::pBox::Resize will size correctly
    #$W create line 0 0 1 1 -tag {pBox diag1} -width 2 -fill red
    #$W create line 0 1 1 $y0 -tag {pBox diag2} -width 2 -fill red
    $W create rect 0 0 1 1 -tag {pBox pBoxx} -width 2 -outline red \
	-fill red -stipple gray25
    $W bind pBoxx <Enter> [list $W config -cursor hand2]
    $W bind pBoxx <ButtonPress-1> [list ::pBox::PBDown $W box %x %y]
    $W bind pBoxx <B1-Motion> [list ::pBox::PBMotion $W box %x %y]

    foreach {color1 color2} {{} {}} break
    if {$::pBox::debug} {
	foreach {color1 color2} {yellow blue} break
    }

    # Hidden rectangles that we bind to for resizing
    $W create rect 0 0 0 1 -fill $color1 -stipple gray25 -width 0 -tag {pBox L}
    $W create rect 1 0 1 1 -fill $color1 -stipple gray25 -width 0 -tag {pBox R}
    $W create rect 0 0 1 0 -fill $color1 -stipple gray25 -width 0 -tag {pBox T}
    $W create rect 0 1 1 1 -fill $color1 -stipple gray25 -width 0 -tag {pBox B}
    $W create rect 0 0 0 0 -fill $color2 -stipple gray25 -width 0 -tag {pBox TL}
    $W create rect 1 0 1 0 -fill $color2 -stipple gray25 -width 0 -tag {pBox TR}
    $W create rect 0 1 0 1 -fill $color2 -stipple gray25 -width 0 -tag {pBox BL}
    $W create rect 1 1 1 1 -fill $color2 -stipple gray25 -width 0 -tag {pBox BR}

    foreach tag [array names CURSORS] {
	$W bind $tag <Enter> [list ::pBox::PBEnter $W $tag]
	$W bind $tag <Leave> [list ::pBox::PBLeave $W $tag]
	$W bind $tag <B1-Motion> [list ::pBox::PBMotion $W $tag %x %y]
	$W bind $tag <ButtonRelease-1> [list ::pBox::PBUp $W $tag]
	$W bind $tag <ButtonPress-1> [list ::pBox::PBDown $W $tag %x %y]
    }

    ::pBox::Resize $W
}
##+##########################################################################
#
# ::pBox::Done -- kills the print box and returns its coordinates
#
proc ::pBox::Done {W} {
    variable xy
    $W delete pBox

    foreach {x0 y0 x1 y1} $xy break
    set sxy [concat [::Display::Canvas2Screen $x0 $y0] \
		 [::Display::Canvas2Screen $x1 $y1]]
    return $sxy
}
##+##########################################################################
#
# ::pBox::Resize -- resizes the print box to ::pBox::xy size
#
proc ::pBox::Resize {W} {
    variable xy
    variable grabSize

    foreach {x0 y0 x1 y1} $xy break
    $W coords pBoxx $x0 $y0 $x1 $y1
    $W coords diag1 $x0 $y0 $x1 $y1
    $W coords diag2 $x1 $y0 $x0 $y1

    set w1 [$W itemcget pBoxx -width]		;# NB. width extends outward
    set w2 [expr {-1 * ($w1 + $grabSize)}]

    foreach {x0 y0 x1 y1} [::pBox::GrowBox $x0 $y0 $x1 $y1 $w1] break
    foreach {x0_ y0_ x1_ y1_} [::pBox::GrowBox $x0 $y0 $x1 $y1 $w2] break
    $W coords L $x0 $y0_ $x0_ $y1_
    $W coords R $x1 $y0_ $x1_ $y1_
    $W coords T $x0_ $y0 $x1_ $y0_
    $W coords B $x0_ $y1 $x1_ $y1_
    $W coords TL $x0 $y0 $x0_ $y0_
    $W coords TR $x1 $y0 $x1_ $y0_
    $W coords BL $x0 $y1 $x0_ $y1_
    $W coords BR $x1 $y1 $x1_ $y1_
}
##+##########################################################################
#
# ::pBox::GrowBox -- grows (or shrinks) rectangle coordinates
#
proc ::pBox::GrowBox {x0 y0 x1 y1 d} {
    list [expr {$x0-$d}] [expr {$y0-$d}] [expr {$x1+$d}] [expr {$y1+$d}]
}
##+##########################################################################
#
# ::pBox::PBDown -- handles button down in a print box
#
proc ::pBox::PBDown {W tag x y} {
    variable bxy [list $x $y]
    variable bdown 1
}
##+##########################################################################
#
# ::pBox::PBUp -- handles button up in a print box
#
proc ::pBox::PBUp {W tag} {
    variable bdown 0
}
##+##########################################################################
#
# ::pBox::PBEnter -- handles <Enter> in a print box
#
proc ::pBox::PBEnter {W tag} {
    $W config -cursor $::pBox::CURSORS($tag)
}
##+##########################################################################
#
# ::pBox::PBLeave -- handles <Leave> in a print box
#
proc ::pBox::PBLeave {W tag} {
    variable bdown
    if {! $bdown} {
	$W config -cursor {}
    }
}
##+##########################################################################
#
# ::pBox::PBMotion -- handles button motion in a print box, resizing as needed
#
proc ::pBox::PBMotion {W tag x y} {
    variable bxy
    variable xy
    variable minSize

    foreach {x0 y0 x1 y1} $xy break
    foreach {dx dy} $bxy break
    set dx [expr {$x - $dx}]
    set dy [expr {$y - $dy}]

    set w [winfo width $W]
    set h [winfo height $W]
    set wx0 [$W canvasx 0]
    set wy0 [$W canvasy 0]
    set wx1 [$W canvasx $w]
    set wy1 [$W canvasy $h]

    if {$tag eq "box"} {			;# Move the print box
	if {$x0 + $dx < $wx0} {set dx [expr {$wx0 - $x0}]}
	if {$x1 + $dx > $wx1} {set dx [expr {$wx1 - $x1}]}
	if {$y0 + $dy < $wy0} {set dy [expr {$wy0 - $y0}]}
	if {$y1 + $dy > $wy1} {set dy [expr {$wy1 - $y1}]}

	set x0 [expr {$x0 + $dx}]
	set x1 [expr {$x1 + $dx}]
	set y0 [expr {$y0 + $dy}]
	set y1 [expr {$y1 + $dy}]

	set xy [list $x0 $y0 $x1 $y1]
	set bxy [list $x $y]
    } else {					;# Resize the print box
	if {$tag eq "L" || $tag eq "TL" || $tag eq "BL"} {
	    set x0_ [expr {$x0 + $dx}]
	    if {$x0_ < $wx0} {
		lset xy 0 $wx0
		lset bxy 0 0
	    } elseif {$x1 - $x0_ >= $minSize} {
		lset xy 0 $x0_
		lset bxy 0 $x
	    }
	}
	if {$tag eq "R" || $tag eq "TR" || $tag eq "BR"} {
	    set x1_ [expr {$x1 + $dx}]
	    if {$x1_ > $wx1} {
		lset xy 2 $wx1
		lset bxy 0 $w
	    } elseif {$x1_ - $x0 >= $minSize} {
		lset xy 2 $x1_
		lset bxy 0 $x
	    }
	}
	if {$tag eq "T" || $tag eq "TR" || $tag eq "TL"} {
	    set y0_ [expr {$y0 + $dy}]
	    if {$y0_ < $wy0} {
		lset xy 1 $wy0
		lset bxy 1 0
	    } elseif {$y1 - $y0_ >= $minSize} {
		lset xy 1 $y0_
		lset bxy 1 $y
	    }
	}
	if {$tag eq "B" || $tag eq "BR" || $tag eq "BL"} {
	    set y1_ [expr {$y1 + $dy}]
	    if {$y1_ > $wy1} {
		lset xy 3 $wy1
		lset bxy 1 $h
	    } elseif {$y1_ - $y0 > $minSize} {
		lset xy 3 $y1_
		lset bxy 1 $y
	    }
	}
    }
    ::pBox::Resize $W
}
## EON PBOX
## BON PRINTPS
##+##########################################################################
#
# ::PrintPS::Dialog
#
# Draws the dialog that controls the printing process, and the
# dialog to tell the user we're busy printing.
#
proc ::PrintPS::Dialog {} {
    ::PrintPS::_Config
    ::PrintPS::DrawBox
    ::Display::MakeImage ::img::print printer.gif

    destroy .print
    toplevel .print -bd 2 -relief ridge
    wm title .print "$::state(progname) Print"
    wm transient .print .
    wm resizable .print 0 0
    wm withdraw .print
    wm protocol .print WM_DELETE_WINDOW ::PrintPS::Dismiss

    set msgs "\nSelect the area you want to print as postscript.\n\n"
    set  warning "WARNING: this may take a minute or more and requires "
    append warning "up to 40 meg of disk space."
    ::tk::frame .print.spacer
    ::tk::label .print.l -width 100 -height 100 -image ::img::print -anchor n
    ::tk::label .print.h -text "Print KLIMB Area" -bd 2 -relief sunken

    text .print.msg -width 40 -heigh 6 -wrap word -bg [.print.l cget -bg] \
	-bd 0 -font {Helvetica 8}
    .print.msg insert end $msgs
    .print.msg insert end $warning WARN
    .print.msg tag configure WARN -foreground red
    .print.msg config -state disabled

    set font [::Display::Embolden .print.l]
    ::tk::labelframe .print.orient -bd 2 -text "Orientation"
    ::tk::labelframe .print.zoom -bd 2 -text "Zoom"

    ::tk::radiobutton .print.land -variable ::PrintPS::orientation \
	-value landscape \
	-text "Landscape" -command {::PrintPS::_Config -orientation landscape} \
	;# -anchor w
    ::tk::radiobutton .print.port -variable ::PrintPS::orientation \
	-value portrait \
	-text "Portrait" -command {::PrintPS::_Config -orientation portrait} \
	;# -anchor w

    ::tk::radiobutton .print.z0 -var ::PrintPS::zoom -value 1 -text "None" \
	-command ::PrintPS::_Config ;# -anchor w
    ::tk::radiobutton .print.z1 -var ::PrintPS::zoom -value 1.5 -text "150%" \
	-command ::PrintPS::_Config ;# -anchor w
    ::tk::radiobutton .print.z2 -var ::PrintPS::zoom -value 2 -text "200%" \
	-command ::PrintPS::_Config ;# -anchor w
    ::tk::radiobutton .print.z3 -var ::PrintPS::zoom -value 2.5 -text "250%" \
	-command ::PrintPS::_Config ;# -anchor w

    ::my::frame .print.bot -borderwidth 2 -relief ridge
    ::ttk::button .print.dismiss -text "Dismiss" -command ::PrintPS::Dismiss
    ::ttk::button .print.ps -text "Save as Postscript" -command ::PrintPS::_PrintIt
    ::ttk::button .print.print -text "Print" -state disabled

    grid x x x .print.spacer -row 0 -ipady 5 -ipadx 5 -sticky news
    grid .print.l .print.h - -sticky new -ipadx 2
    grid ^ .print.msg - -sticky news
    grid ^ .print.orient .print.zoom -sticky ew

    grid .print.land -in .print.orient -row 1
    grid .print.port -in .print.orient -sticky w
    grid .print.z0 .print.z2 -in .print.zoom -row 1
    grid .print.z1 .print.z3 -in .print.zoom
    grid .print.bot - - -   -sticky news
    pack .print.print .print.ps .print.dismiss -in .print.bot \
	-side left -expand 1 -pady 10

    ::Display::RightWindow .print
    wm deiconify .print
}
##+##########################################################################
#
# ::PrintPS::WaitDialog
#
# Dialog box informing user that we're busy printing.
#
proc ::PrintPS::WaitDialog {fname} {
    ::Display::MakeImage ::img::print printer.gif

    destroy .print
    toplevel .print -bd 2 -relief ridge
    wm title .print "$::state(progname) Printing"
    wm transient .print .
    wm resizable .print 0 0
    wm withdraw .print
    wm protocol .print WM_DELETE_WINDOW {#}	;# You can't close it

    set msg "\nSaving print area as postscript into $fname.\n\n"
    set warning "WARNING: this may take a minute or more and requires "
    append warning "up to 40 meg of disk space."
    ::tk::frame .print.spacer
    ::tk::label .print.l -width 100 -height 100 -image ::img::print -anchor n
    ::tk::label .print.h -text "Printing KLIMB Area" -bd 2 -relief sunken

    text .print.msg -width 40 -heigh 7 -wrap word -bg [.print.l cget -bg] \
	-bd 0 -font {Helvetica 8}
    .print.msg insert end $msg
    .print.msg insert end $warning WARN
    .print.msg tag configure WARN -foreground red
    .print.msg config -state disabled

    grid x x x .print.spacer -row 0 -ipady 5 -ipadx 5 -sticky news
    grid .print.l .print.h - -sticky new -ipadx 2
    grid ^ .print.msg - -sticky news

    ::Display::CenterWindow .print
    wm deiconify .print
}
##+##########################################################################
#
# ::PrintPS::Dismiss
#
# Dismisses the print dialog box and cleans up the display.
#
proc ::PrintPS::Dismiss {} {
    variable inDialog

    if {$inDialog} return
    .c delete printBox
    ::PrintPS::_Overview
    destroy .print
}
##+##########################################################################
#
# ::PrintPS::_Config
#
# Configures the postscript capture.
#
proc ::PrintPS::_Config {args} {
    variable orientation
    variable colormode
    variable height
    variable width
    variable xheight
    variable xwidth
    variable zoom
    variable pageheight
    variable pagewidth
    variable rotate

    foreach {arg value} $args {
	if {$arg eq "-orientation"} {
	    if {$value eq "landscape"} {
		set xwidth 1350
		set xheight 975
		set pageheight 6.5i
		set pagewidth 9.0i
		set rotate true
	    } else {
		set xheight 1350
		set xwidth 975
		set pageheight 9.0i
		set pagewidth 6.5i
		set rotate false
	    }
	    continue
	}
	if {$arg eq "-colormode"} {
	    set colormode $value
	    continue
	}
    }
    set width  [expr {$xwidth  / $zoom}]
    set height [expr {$xheight / $zoom}]
    ::PrintPS::DrawBox
}
##+##########################################################################
#
# ::Print::_PSArea
#
# Converts the current area into postscript
#
proc ::PrintPS::_PSArea {fname w x y} {
    variable colormode
    variable height
    variable width
    variable pageheight
    variable pagewidth
    variable rotate

    set x2 [expr {$x + $width}]
    set y2 [expr {$y + $height}]

    INFO "creating postscript $fname: this may take over a minute to complete"
    $w postscript \
	-file $fname \
	-colormode $colormode \
	-x $x -y $y -width $width -height $height \
	-pageheight $pageheight -pagewidth $pagewidth \
	-rotate $rotate
    return $fname
}
##+##########################################################################
#
# ::PrintPS::_PrintIt
#
# Turns the area w/i the printbox into postscript
#
proc ::PrintPS::_PrintIt {} {
    variable inDialog

    set types {{{Postscript Files} {.ps}} {{All Files} *}}
    set inDialog 1
    set fname [tk_getSaveFile -defaultextension ".ps" \
		   -title "$::state(progname) Save Map" -filetypes $types]
    set inDialog 0
    if {$fname eq ""} return

    set xy [.c coords printBox]
    if {$xy eq {}} return
    foreach {x1 y1 x2 y2} $xy break
    ::PrintPS::Dismiss				;# Kill dialog and printbox
    ::PrintPS::_Overview			;# Kill printbox in overview
    ::PrintPS::WaitDialog $fname		;# Put up warning dialog
    Busy 1
    ::PrintPS::_PSArea $fname .c $x1 $y1
    Busy 0
    destroy .print				;# Kill print wait dialog
    DoInfo "Area saved as $fname" "$::state(progname) Print Status"
}
##+##########################################################################
#
# ::PrintPS::DrawBox
#
# Figures out where to center the print box--either center
# of the screen or current printBox.
#
proc ::PrintPS::DrawBox {} {
    set xy [.c coords printBox]
    if {[llength $xy] == 0} { set xy [::Display::GetScreenRect] }
    foreach {x0 y0 x1 y1} $xy break
    set cx [expr {($x0 + $x1) / 2}]
    set cy [expr {($y0 + $y1) / 2}]
    ::PrintPS::_DrawBox $cx $cy
    return [list $cx $cy]
}
##+##########################################################################
#
# ::PrintPS::_DrawBox
#
# Draws the actual printBox.
#
proc ::PrintPS::_DrawBox {cx cy} {
    variable height
    variable width

    .c delete printBox

    set x1 [expr {$cx - $width / 2}]
    set y1 [expr {$cy - $height / 2}]
    set x2 [expr {$cx + $width / 2}]
    set y2 [expr {$cy + $height / 2}]

    .c create rectangle $x1 $y1 $x2 $y2 -tag {printBox} -outline red -width 2 \
	-fill red -stipple gray25
    .c create rectangle $x1 $y1 $x2 $y2 -tag {pBox printBox} -outline red -wid 2
    .c create line $x1 $y1 $x2 $y2 -tag {pBox printBox} -width 2 -fill red
	.c create line $x2 $y1 $x1 $y2 -tag {pBox printBox} -width 2 -fill red

    .c bind pBox <Button-1>        [list ::PrintPS::_Mouser %W %x %y down]
    .c bind pBox <Shift-Button-1>  [list ::PrintPS::_Mouser %W %x %y sdown]
    .c bind pBox <B1-Motion>       [list ::PrintPS::_Mouser %W %x %y move]
    .c bind pBox <ButtonRelease-1> [list ::PrintPS::_Mouser %W %x %y done]

    .c bind pBox <Enter> [list .c config -cursor hand2]
    .c bind pBox <Leave> [list .c config -cursor {}]

    return [list $x1 $y1 $x2 $y2]
}
##+##########################################################################
#
# ::PrintPS::_Mouser
#
# Handles mouse events for the printBox
#
proc ::PrintPS::_Mouser {w x y what} {
    variable org_x
    variable org_y
    variable shift

    if {$what eq "down"} {
	set org_x $x
	set org_y $y
	set shift 0
	return
    }
    if {$what eq "sdown"} {
	set org_x $x
	set org_y $y
	set shift 1
	return
    }
    if {$what eq "move"} {
	set dx [expr {$x - $org_x}]
	set dy [expr {$y - $org_y}]
	if {$shift == 1} { if {$dx > $dy} { set shift 2 } { set shift 3 }}
	if {$shift == 2} { set dy 0}
	if {$shift == 3} { set dx 0}
	.c move printBox $dx $dy
	set org_x $x
	set org_y $y
	::PrintPS::_Overview
   }
}
##+##########################################################################
#
# ::PrintPS::_Overview
#
# Draws the printBox in the overview window.
#
proc ::PrintPS::_Overview {} {
    # This code doesn't work w/ SFBay region for some reason. Instead of
    # fixing the bug, I'm removing the feature until later.
    return
    if {! [winfo exists .over.c1]} return
    .over.c1 delete printBox

    set xy [.c bbox printBox]
    if {$xy eq ""} return

    foreach {x1 y1 x2 y2} $xy break
    foreach {a a b b top left} [::Display::canvas2pos $x1 $y1] break
    foreach {a a b b bottom right} [::Display::canvas2pos $x2 $y2] break

    foreach {x1 y1} [::Display::pos2canvas overview1 $top $left] break
    foreach {x2 y2} [::Display::pos2canvas overview1 $bottom $right] break
    set tag [list box printBox]
    .over.c1 create rect $x1 $y1 $x2 $y2 -outline red -width 2 -tag $tag
    .over.c1 create line $x1 $y1 $x2 $y2 -fill red -width 2 -tag $tag
    .over.c1 create line $x2 $y1 $x1 $y2 -fill red -width 2 -tag $tag
}
## EON PRINTPS
## BON WITHIN
##+##########################################################################
#
# ::Within::Dlg -- puts up dialog for the Within functionality
#
proc ::Within::Dlg {nid} {
    variable radius 0
    variable destination ""
    variable W

    if {$nid eq "popup"} {set nid $::state(popup,who)} ;# Called from popup menu
    set pnid [::Edit::PrettyNode $nid]

    ::Route::ClearRoute
    ::Within::Clear

    set WC $W.c
    set WB $W.body
    set wtitle "$::state(progname) Node Neighborhood"
    set title [string trim "Node $pnid Neighborhood\n[lindex $::nodes($nid) 0]"]
    ::Display::MakeDialogBox $W $wtitle $title ""
    wm protocol $W WM_DELETE_WINDOW ::Within::Quit

    # Canvas display
    array set pts {1 {15 15} 2 {85 15} 3 {35 45} 4 {65 45} 5 {15 75} 6 {85 75}}
    foreach {p1 p2} {1 3  2 4  3 4  3 5  4 6} {
	$WC create line [concat $pts($p1) $pts($p2)] \
	    -fill blue -width 5 -tag [list r "r$p1,$p2" "r$p2,$p1"]
    }
    foreach pt [array names pts] {
	$WC create oval [::Display::MakeBox $pts($pt) 10] -fill yellow \
	    -tag [list p$pt p]
    }
    ::Within::Dlg_After

    ::ttk::button $W.buttons.dismiss -text Dismiss -command ::Within::Quit
    pack $W.buttons.dismiss -side left -expand 1 -pady 10


    # Neighbor section
    set WN $WB.neighbor
    ::my::labelframe $WN -text "Neighbors"
    ::my::label $WN.l1 -text "Show all neighbors\nwithin a certain\ndistance" \
	-justify left -anchor nw
    ::my::frame $WN.f
    ::my::label $WN.l2 -text "0 miles"
    ::ttk::scale $WN.s -orient hor -from 0 -to 100 -length 70 \
	-command ::Within::Show -variable ::Within::radius
    catch {$WN.s config -showvalue 0}

    grid $WN -row 0 -sticky ew
    grid $WN.l1 $WN.f -sticky news
    pack $WN.l2 $WN.s -in $WN.f -side top
    grid columnconfigure $WN 0 -weight 1

    # Shortest path section
    set WS $WB.short
    ::my::labelframe $WS -text "Shortest Path"
    ::my::label $WS.l1 -justify left -anchor nw \
	-text "Find the shortest\npath from node $pnid\nto any node"
    ::my::frame $WS.f
    ::my::label $WS.f.l -text "Destination"
    ::my::entry $WS.f.e -width 5 -justify center \
	-textvariable ::Within::destination
    ::ttk::button $WS.f.b -text "Show" \
	-command [list ::Within::ShowShortestPath $nid ?]

    grid $WS -sticky ew -pady {10 0}
    grid $WS.l1 $WS.f -sticky news
    grid configure $WS.f -padx 5 -pady {0 5}
    grid $WS.f.l -sticky ew
    grid $WS.f.e -sticky ew
    grid $WS.f.b -sticky ew
    grid columnconfigure $WS 0 -weight 1

    ::Display::LeftWindow $W
    wm deiconify $W
    Busy 1
    update
    ::Within::Dijkstra $nid
    Busy 0
}
##+##########################################################################
#
# ::Within::Dlg_After -- animates the within dialog icon
#
proc ::Within::Dlg_After {} {
    set WC ${::Within::W}.c
    if {! [winfo exists $WC]} return
    set rts {{1 3 4} {1 3 4 2} {1 3 4 6} {1 3 5} {5 3 4} {5 3 4 2} {5 3 4 6}
	{2 4 6}}
    set rt [lindex $rts [expr {int(rand() * [llength $rts])}]]
    $WC itemconfig p -fill yellow
    $WC itemconfig r -fill blue -width 5

    set last -1
    foreach pt $rt {
	if {$last == -1} {
	    $WC itemconfig p$pt -fill red
	} else {
	    $WC itemconfig p$pt -fill magenta
	    $WC itemconfig r$last,$pt -fill magenta -width 8
	}
	set last $pt
    }
    $WC itemconfig p$pt -fill cyan		;# Last node
    after 2000 ::Within::Dlg_After		;# Reschedule ourselves
}
##+##########################################################################
#
# ::Within::Clear -- unhighlights all within roads
#
proc ::Within::Clear {} {
    variable on

    foreach rid $on {
	::Display::HighlightRoad 0 $rid
    }
    set on {}
}
##+##########################################################################
#
# ::Within::Quit -- destroys our dialog and cleans up the display
#
proc ::Within::Quit {} {
    ::Within::Clear
    destroy $::Within::W
}
##+##########################################################################
#
# ::Within::Dijkstra -- implements Dijkstra's shortest path algorithm
#
proc ::Within::Dijkstra {nid} {
    variable queue
    variable d					;# Distance to each node
    variable pi					;# Predecessor node
    variable visited
    variable last
    variable center
    global nodes state roads

    set this "$state(zone)/$state(region)/$nid"
    if {[string equal $this $last]} return	;# Already did this search
    set last $this
    set center $nid

    # Initialize-single-source
    array unset queue
    array unset d
    array unset pi
    array unset visited

    # Sentinels
    set queue(head,prev) {}
    set queue(tail,next) {}
    set d(tail) 9999999

    set qprev head
    foreach who [array names nodes] {
	set queue($who,prev) $qprev
	set queue($who,next) tail
	set queue($qprev,next) $who

	set d($who) 999999
	set pi($who) -1
	set visited($who) 0

	set qprev $who
    }
    set queue(tail,prev) $who
    ::Within::DecreaseKey $nid 0

    foreach rid [array names roads] {		;# Faster access
	foreach {id1 id2} $roads($rid) break
	lappend xroads($id1) $rid $id2
	lappend xroads($id2) $rid $id1
    }

    while {1} {
	set here [::Within::ExtractMin]
	if {$here eq {}} break
	if {! [info exists xroads($here)]} break

	if {$d($here) == 999999} break ;# Unconnected component
	set visited($here) 1

	foreach {rid to} $xroads($here) {
	    if {$visited($to)} continue

	    set dist [::BadMath::Real [lindex $roads($rid) 3]]
	    set toDist [expr {$dist + $d($here)}]
	    if {$d($to) > $toDist} {
		::Within::DecreaseKey $to $toDist
		set pi($to) [list $rid $here]
	    }
	}
    }
    ::Within::RoadDistances
}
##+##########################################################################
#
# ::Within::ExtractMin -- returns minimum element from the queue
#
proc ::Within::ExtractMin {} {
    variable queue

    set who $queue(head,next)
    if {$who eq "tail"} { return {} }
    set queue(head,next) $queue($who,next)
    set queue($queue(head,next),prev) head
    return $who
}
##+##########################################################################
#
# ::Within::DecreaseKey -- reduces the value of a element in the queue which
# will change its position in the queue.
#
proc ::Within::DecreaseKey {nid value} {
    variable d
    variable queue

    if {$d($nid) == $value} return		;# Nothing to do
    set d($nid) $value

    # Unhook from linked list
    set queue($queue($nid,prev),next) $queue($nid,next)
    set queue($queue($nid,next),prev) $queue($nid,prev)

    # Walk from head of queue to find where it should go
    set who head
    while {1} {
	set next $queue($who,next)
	if {$value <= $d($next)} break
	set who $next
    }
    set queue($nid,prev) $who
    set queue($nid,next) $queue($who,next)
    set queue($who,next) $nid
    set queue($queue($nid,next),prev) $nid
}
##+##########################################################################
#
# ::Within::DumpQueue -- debugging routine
#
proc ::Within::DumpQueue {{cnt -1}} {
    variable queue
    variable d
    variable visited
    variable pi

    for {set who head} {1} {set who $queue($who,next)} {
	set txt [format "%-5s / %-5s / %-5s " \
		     $who $queue($who,prev) $queue($who,next)]
	if {$who ne "head" && $who ne "tail"} {
	    append txt "=> " [format "%d : %6g : %s" \
				  $visited($who) $d($who) $pi($who)]
	}
	puts $txt
	if {$who eq "tail"} break
	if {[incr cnt -1] == 0} break
    }
}
##+##########################################################################
#
# ::Within::RoadDistances -- using Dijkstra's data, find the distance to
# the further end point of all the roads.
#
proc ::Within::RoadDistances {} {
    global roads
    variable d
    variable r

    array unset r
    foreach rid [array names roads] {
	foreach {id1 id2 . dist} $roads($rid) break
	set m [expr {$d($id1) <= $d($id2) ? $d($id1) : $d($id2)}]
	set r($rid) [expr {$m + [::BadMath::Real $dist]}]
    }
}
##+##########################################################################
#
# ::Within::Show -- highlights all roads w/i value of center
#
proc ::Within::Show {value} {
    variable r
    variable on
    variable W

    set value [Round0 $value]
    set txt [::Data::Label $value dist 0]	;# Label w/ external units...
    catch {$W.body.neighbor.l2 config -text $txt}
    set value [::Data::RConvert $value dist]	;# but work in internal units

    ::Within::Clear
    ::Route::ClearRoute
    if {$value <= 0} return
    foreach rid [array names r] {
	if {$r($rid) <= $value} {
	    ::Display::HighlightRoad 1 $rid
	    lappend on $rid
	}
    }
}
##+##########################################################################
#
# ::Within::ShowShortestPath -- turns into a route the shortest path
# between to and from
#
proc ::Within::ShowShortestPath {from to} {
    variable destination

    ::Within::Show 0
    ::Within::Dijkstra $from

    if {$to eq "?"} {				;# Called via the dialog
	if {$destination eq ""} return		;# Read the entry
	set to [::Edit::FindNode $destination]
	if {$to eq ""} {
	    return [WARN "Unknown destination '$destination'"]
	}
    }
    set rpath [::Within::GetShortestPath $from $to]
    if {$rpath eq {}} {
	set to [::Edit::PrettyNode $to]
	set from [::Edit::PrettyNode $from]
	return [WARN "Node $to is unreachable\nfrom $from"]
    }

    ::Route::ClearRoute
    ::Display::PickRoad node $from
    foreach rid $rpath {
	::Display::PickRoad road $rid
    }
}
##+##########################################################################
#
# ::Within::GetShortestPath -- Computes shortest path from/to
#
proc ::Within::GetShortestPath {from to} {
    variable pi

    ::Within::Dijkstra $from
    if {$pi($to) == -1} { return {} }
    set rpath {}
    while {1} {
	foreach {rid to} $pi($to) break
	if {$rid == -1} break
	set rpath [concat $rid $rpath]
    }
    return $rpath
}
##+##########################################################################
#
# ::Within::HowFar -- used by balloon help, returns distance to center as text
#  ONLY when within window is up
#
proc ::Within::HowFar {nid} {
    variable d
    variable pi
    variable center

    if {! [winfo exists $::Within::W]} {return ""}
    if {$pi($nid) == -1} {return ""}		;# Not reachable

    set dist [lindex $d($nid) 0]
    set txt "\nDistance from $center: [::Data::Units $dist dist 3]"
    return $txt
}
## EON WITHIN
## BON COORDS
##+##########################################################################
#
# ::Coords::Dialog -- puts up Coordinate Locator dialog
#
proc ::Coords::Dialog {whence} {
    variable C
    variable latlon
    variable msg ""

    ::Coords::Quit				;# Clean up any previous windows
    array unset latlon
    array set latlon {lat,d "" lat,s 0 lat,m 0 lon,d "" lon,s 0 lon,m 0}

    bind .c <Motion> [list ::Coords::MotionHandler %W %x %y]
    bind .c <Shift-Motion> [list ::Coords::MotionHandler %W %x %y 1]

    set W .coords
    set WB $W.body
    set WBTN $W.buttons
    set title "Coordinate Locator"
    set wtitle "$::state(progname) $title"
    ::Display::MakeDialogBox $W $wtitle $title ""
    wm protocol $W WM_DELETE_WINDOW ::Coords::Quit
    grid config $W.c -padx 5

    $W.c config -bd 2 -relief solid
    $W.c create image 0 0 -anchor nw -tag img
    $W.c create line 50 0 50 200 -width 2 -tag axis
    $W.c create line 0 50 200 50 -width 2 -tag axis
    $W.c create oval [::Display::MakeBox {50 50} 5] -fill yellow -width 2 \
	-tag node
    ::Coords::Dlg_After

    ::ttk::button $WBTN.zoom -text Zoom -command [list ::Zoom::Go coords x]
    ::ttk::button $WBTN.view -text "Google Maps" -command [list ::Zoom::Google coords]
    ::ttk::button $WBTN.quit -text Dismiss -command ::Coords::Quit
    ::Display::GridChildren $WBTN 0

    ::ttk::combobox $WB.cb -values $C(values) -takefocus 0 -width 25 \
	-state readonly -textvariable ::Coords::C(ll) -exportselection 0
    ::Data::UniqueTrace ::Coords::C(ll) ::Coords::LatLonTrace
    ::ttk::frame $WB.c
    pack $WB.cb $WB.c -side top -fill both -expand 1

    set row -1
    foreach {a b} {lat Latitude lon Longitude} {
	::my::label $WB.c.l$a -text $b -font boldFont -anchor e
	grid $WB.c.l$a -sticky w -columnspan 6 -row [incr row]
	incr row
	set col 0
	foreach {v vv} {d "\xB0" m "'" s "\x22"} {
	    ::tk::entry $WB.c.e$a,$v -textvariable "::Coords::latlon($a,$v\)" \
		-width 5 -justify right -exportselection 0
	    ::my::label $WB.c.l$a,$v -text $vv -width 1
	    grid $WB.c.e$a,$v -sticky w -row $row -column [incr col]
	    grid $WB.c.l$a,$v -sticky w -row $row -column [incr col]
	}
    }
    grid columnconfigure $WB.c 0 -minsize .125i
    ::ttk::button $WB.go -text Locate -command ::Coords::Go
    pack $WB.go -side bottom -expand 1 -pady {10 0}

    # Fill in lat/lon entries
    if {$whence eq "popup"} {
	foreach {x y} $::state(popup) break
    } else {
	set x [expr {[winfo width .c] / 2}]
	set y [expr {[winfo height .c] / 2}]
    }
    foreach {. . . . lat lon} [::Display::canvas2pos $x $y] break
    foreach {latlon(lat,d) latlon(lat,m) latlon(lat,s)} [int2lat $lat] break
    foreach {latlon(lon,d) latlon(lon,m) latlon(lon,s)} [int2lat $lon] break
    ::Data::UniqueTrace ::Coords::latlon ::Coords::Trace
    ::Coords::LatLonTrace . . .

    focus -force $WB.c.elat,d
    $WB.c.elat,d selection range 0 end
    $WB.c.elat,d icursor end

    ::Display::LeftWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Coords::LatLonTrace -- Morphs the dialog display based on how user
# selects to enter the coordinates
#
proc ::Coords::LatLonTrace {var1 var2 op} {
    variable C
    variable latlon

    foreach {lat lon} [::Coords::_ToDecimal] break

    set n [lsearch $C(values) $C(ll)]
    if {$n == 0} {
	.coords.body.c.elat,d config -width 10
	.coords.body.c.elon,d config -width 10
	grid forget .coords.body.c.elat,m
	grid forget .coords.body.c.elon,m
	grid forget .coords.body.c.elat,s
	grid forget .coords.body.c.elon,s
	grid forget .coords.body.c.llat,m
	grid forget .coords.body.c.llon,m
	grid forget .coords.body.c.llat,s
	grid forget .coords.body.c.llon,s
	set latlon(lat,d) $lat
	set latlon(lat,m) ""
	set latlon(lat,s) ""
	set latlon(lon,d) $lon
	set latlon(lon,m) ""
	set latlon(lon,s) ""
    } elseif {$n == 1} {
	.coords.body.c.elat,d config -width 5
	.coords.body.c.elon,d config -width 5
	.coords.body.c.elat,m config -width 10
	.coords.body.c.elon,m config -width 10
	grid forget .coords.body.c.elat,s
	grid forget .coords.body.c.elon,s
	grid forget .coords.body.c.llat,s
	grid forget .coords.body.c.llon,s
	grid .coords.body.c.elat,m -row 1 -column 3
	grid .coords.body.c.elon,m -row 3 -column 3
	grid .coords.body.c.llat,m -row 1 -column 4
	grid .coords.body.c.llon,m -row 3 -column 4
	set latlon(lat,d) [expr {int($lat)}]
	set latlon(lat,m) [format %.6f [expr {60*($lat - $latlon(lat,d))}]]
	set latlon(lat,s) ""
	set latlon(lon,d) [expr {int($lon)}]
	set latlon(lon,m) [format %.6f [expr {60*($lon - $latlon(lon,d))}]]
	set latlon(lon,s) ""
    } else {
	.coords.body.c.elat,d config -width 5
	.coords.body.c.elon,d config -width 5
	.coords.body.c.elat,m config -width 5
	.coords.body.c.elon,m config -width 5
	grid .coords.body.c.elat,m -row 1 -column 3
	grid .coords.body.c.elon,m -row 3 -column 3
	grid .coords.body.c.elat,s -row 1 -column 5
	grid .coords.body.c.elon,s -row 3 -column 5
	grid .coords.body.c.llat,m -row 1 -column 4
	grid .coords.body.c.llon,m -row 3 -column 4
	grid .coords.body.c.llat,s -row 1 -column 6
	grid .coords.body.c.llon,s -row 3 -column 6
	foreach {latlon(lat,d) latlon(lat,m) latlon(lat,s)} [int2lat $lat] break
	foreach {latlon(lon,d) latlon(lon,m) latlon(lon,s)} [int2lat $lon] break
    }
}
##+##########################################################################
#
# ::Coords::Dlg_After -- animates the coords dialog icon
#
proc ::Coords::Dlg_After {} {
    variable aid
    if {! [winfo exists .coords.c]} return

    after cancel $aid
    set maps [info commands ::map::*]
    set n [lsearch -glob $maps "*slippy*"] ;# Oops, not all ::maps::* are images
    if {$n != -1} { set maps [lreplace $maps $n $n] }
    set mymap [lindex $maps [expr {int(rand() * [llength $maps])}]]
    .coords.c itemconfig img -image $mymap
    set aid [after 5000 ::Coords::Dlg_After] ;# Reschedule ourselves
}
##+##########################################################################
#
# ::Coords::Quit -- cleans up toplevel, after and main map window
#
proc ::Coords::Quit {} {
    bind .c <Motion> {}
    bind .c <Shift-Motion> {}
    destroy .coords
    .c delete coords
    after cancel $::Coords::aid
    ::Data::UniqueTrace ::Coords::C(ll)
    ::Data::UniqueTrace ::Coords::latlon
}
##+##########################################################################
#
# ::Coords::Go -- puts up cross-hair at the specified location
#
proc ::Coords::Go {} {
    variable latlon
    variable msg

    .c delete coords
    set msg ""
    foreach {lat lon} [::Coords::_ToDecimal] break
    ::Coords::_Go $lat $lon
}
##+##########################################################################
#
# ::Coords::_ToDecimal -- Turns user lat/lon into decimal format
#
proc ::Coords::_ToDecimal {} {
    variable latlon

    foreach a {d m s} {
	set X(lat,$a) $latlon(lat,$a)
	if {! [string is double -strict $X(lat,$a)]} { set X(lat,$a) 0}
	set X(lon,$a) $latlon(lon,$a)
	if {! [string is double -strict $X(lon,$a)]} { set X(lon,$a) 0}
    }
    set lat [lat2int $X(lat,d) $X(lat,m) $X(lat,s)]
    set lon [lat2int $X(lon,d) $X(lon,m) $X(lon,s)]
    set lat [format %.6f $lat]
    set lon [format %.6f $lon]
    return [list $lat $lon]
}
proc ::Coords::_Go {lat lon} {
    if {! [::Display::ClipNode $lat $lon]} {
	set msg "The point is off the map"
	return
    }

    foreach {x y} [::Display::pos2canvas root $lat $lon] break

    foreach {t l b r} [.c bbox all] break
    .c create line $t $y $b $y -width 2 -tag coords
    .c create line $x $l $x $r -width 2 -tag coords
    set xy [::Display::MakeBox [list $x $y] 5]
    .c create oval [::Display::MakeBox [list $x $y] 5] -fill yellow -width 2 \
	-tag coords
    ::Display::ToCenter2 $x $y
}
##+##########################################################################
#
# ::Coords::Where -- used by Zoom, returns current lat/lon value
#
proc ::Coords::Where {} {
    variable latlon

    set lat [list $latlon(lat,d) $latlon(lat,m) $latlon(lat,s)]
    set lon [list $latlon(lon,d) $latlon(lon,m) $latlon(lon,s)]
    return [list $lat $lon]
}
##+##########################################################################
#
# ::Coords::Trace -- checks for valid lat/lon numbers
#
proc ::Coords::Trace {var1 var2 op} {
    variable latlon

    set bad 0
    .coords.body.go config -state normal
    set bg [lindex [.coords.body.c.elat,d config -background] 3]
    foreach a [array names latlon] {
	.coords.body.c.e$a config -background $bg
	if {$latlon($a) eq ""} {		;# Empty, just disable
	    ;# incr bad  -- treat as being 0
	} elseif {! [string is double -strict $latlon($a)]} {
	    .coords.body.c.e$a config -background red	;# Also highlight bad
	    incr bad
	}
    }
    if {$bad} {
	.coords.body.go config -state disabled
    }
}
##+##########################################################################
#
# ::Coords::MotionHandler -- tracks the mouse as it moves, displaying lat/lon
#
proc ::Coords::MotionHandler {W x y {dlg 0}} {
    variable latlon
    foreach {lat lon} [::Display::canvas2pos $x $y] break
    if {$dlg} {
	foreach who {lat,d lat,m lat,s lon,d lon,m lon,s} v [concat $lat $lon] {
	    set latlon($who) $v
	}
    }

    foreach {lat lon} [::Display::PrettyLat $lat $lon] break
    INFO "$lat $lon"
}
## EON COORDS
## BON ZONE
##+##########################################################################
#
# ::Zone::FindZones -- finds all KLIMB zones, these are directories
# with the name <zonename>.zone in which resides a "zone.data" file.
#
proc ::Zone::FindZones {} {
    global zone state

    set state(zone,names) {}
    set znames [concat [glob -nocomplain [file join $::state(kdir) *.zone]] \
		    [glob -nocomplain [file join $::state(hdir) *.zone]]]

    foreach dir $znames {
	set zname [file join $dir zone.data]
	if {! [file isfile $zname]} continue

	set name [::Zone::GetZoneName $zname]
	if {[lsearch $state(zone,names) $name] == -1} {
	    lappend state(zone,names) $name
	    set state(zone,$name,zdir) [file dirname $zname]
	}
    }
    if {[llength $state(zone,names)] > 0} return

    set msg "$state(progname) could not find any zone information.\n\n"
    append msg "This probably means that you installed\n"
    append msg "the zones incorrectly."
    DIE $msg
}
##+##########################################################################
#
# ::Zone::GetZoneName -- dig zone name out of zone.data file
#
proc ::Zone::GetZoneName {zname} {
    set FIN [open $zname r]			;# Slurp up the zone.data file
    set data [read $FIN]
    close $FIN

    set name [file rootname [file tail [file dirname $zname]]] ;# Default value
    regexp -line ^name=(.*)$ $data => name	;# Overridden in zone.data

    return $name
}
##+##########################################################################
#
# ::Zone::NewZone -- called on changing to a new zone
#
proc ::Zone::NewZone {name} {
    global zone state

    ::Zone::GoZone $name
    ::Init::StartingRegion $zone(region,default) ""
    ::Region::GoRegion $state(region) $state(mag)
}
##+##########################################################################
#
# ::Zone::GoZone -- erases then fills in zone and region arrays from
# the zone data file and all exising .KLR files. Also handles the
# overview window.
#
proc ::Zone::GoZone {name} {
    variable defaults
    global state zone region map

    if {$name eq {}} {set name $state(zone,default)} ;# Use default zone
    set name [::Data::lsearchX $name $state(zone,names)] ;# Check valid name
    if {$name eq ""} {
	set name [lindex $state(zone,names) 0]
	if {$name eq "Eastbay Parks"} {
	    set name [lindex $state(zone,names) end]
	}
    }

    # Close all popup windows
    ::Display::KillChildren

    # Save some zone data but delete the rest
    set state(zone) $name
    #set saveZone [array get zone *,zdir]
    #lappend saveZone names $state(zone,names)
    unset -nocomplain zone
    #array set zone $saveZone
    array set zone [array get defaults]

    set state(zdir) $state(zone,$state(zone),zdir)
    ::Config::ReadRC

    set fname [::Init::LocateZoneFile "zone.data" 1 0]
    if {[file isfile $fname]} {
	set state(logfile) [::Init::LocateZoneFile klimb.log 0]
	::Zone::ReadZoneFile $fname
    } else {
	DIE "ERROR: no zone data for '$state(zone)' zone"
    }

    # Region data:
    # region($mag) {region1 region2...}
    # region(names) {region1 region2...}
    #
    # region(region1,mag)	 { 2 3 }	 ;# Available magnifications
    # region(region1,2,maps)	 { region12a.gif }
    # region(region1,3,maps)	 { region13a.gif region13b.gif }
    # region(region1,nodes)	 { region1.nodes }
    #   top, left, width, height set elsewhere

    # Read in region data from any *.klr file in exe directory
    unset -nocomplain region
    unset -nocomplain map
    set state(zoomout) 0

    set flist [glob -nocomplain [file join $state(zdir) *.klr]]
    ::Region::LoadRegions $flist

    if {! [info exists region(names)]} {
	set txt "ERROR: no region files found.\n\n"
	append txt "This usually means that the installation was faulty.\n"
	DIE $txt
    }

    # Overview window. For now just close it, erase the images and let
    # the user reopen it if he wants
    if {$state(overview)} ::Overview::Toggle	;# Close overview window
    if {$state(legend)} ::Legend::Toggle	;# Close legend window
    destroy .over				;# Force it to be recreated
    foreach img [info commands ::img::overview*] {
	image delete $img
    }
    ::Tracks::NewZone
}
##+##########################################################################
#
# Zone::ReadZoneFile -- reads in a zone file which consists of overview map
# info, zone map info and default region.
#
proc ::Zone::ReadZoneFile {fname} {
    global zone

    set n [catch {set FIN [open $fname r]}]
    if {$n} {DIE "Can't open zone file $fname"}

    set zone(zone,map) ""
    while {[gets $FIN line] != -1} {
	if {[string match "\#*" $line]} continue
	set n [regexp {^(.*)\s*=\s*(.*)\s*$} $line => name value]
	if {$n} {
	    set zone($name) $value
	}
    }
    close $FIN
}
##+##########################################################################
#
# ::Zone::InstallNewNodes -- Updates the node file with data from the web
#
proc ::Zone::InstallNewNodes {data} {
    if {$data eq ""} return

    set nfile $::region($::state(region),nodes)
    set nfile [::Init::LocateZoneFile $nfile 1 0]
    if {[file exists $nfile] && [file size $nfile] == [string length $data]} {
	DoInfo "Node file is already up to date" "KLIMB Node Update"
	return
    }
    ::Data::BackupFile $nfile

    set n [catch {set fout [open $nfile w]} emsg]
    if {$n} { WARN "ERROR: $emsg"; return }
    fconfigure $fout -translation binary
    puts -nonewline $fout $data
    close $fout

    set txt "Node file updated.\n\n"
    append txt "New data will be used next\ntime you load this zone."
    DoInfo $txt "KLIMB Node Update"
}
## EON ZONE
## BON GPX
##+##########################################################################
#
# ::GPX::GetRoute -- returns the route in GPX (the GPS eXchange) format
# for validation: SaxCount.exe -v=always -n -s -f my_gpx_file.gpx
#  see http://www.topografix.com/gpx.asp
#      http://www.topografix.com/gpx_validation.asp
#
proc ::GPX::GetRoute {} {
    variable indent
    global nodes route state

    set result [::GPX::Header]
    foreach {minlat maxlon maxlat minlon} [::Route::GetBounds] break
    append result "$indent<bounds"
    append result " minlat=\"$minlat\""
    append result " minlon=\"-$minlon\""
    append result " maxlat=\"$maxlat\""
    append result " maxlon=\"-$maxlon\""
    append result "/>\n"

    foreach {wpt rte} [::GPX::GetRoutePoints] break
    append result $wpt $rte
    append result "</gpx>"
    return $result
}
##+##########################################################################
#
# ::GPX::Header -- returns XML header for GPX files, version 1.0
#
proc ::GPX::Header {} {
    variable indent

    set t [clock format [clock seconds] -gmt 1 -format "%Y-%m-%dT%H:%M:%SZ"]

    set result {<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>}
    append result "\n<gpx\n"
    append result "${indent}version=\"1.0\"\n"
    append result "${indent}creator=\"$::state(progname) $::state(version) "
    append result "$::state(homepage)\"\n" $indent
    append result {xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"} \n
    append result $indent {xmlns="http://www.topografix.com/GPX/1/0"} \n
    append result $indent {xsi:schemaLocation=}
    append result "\"http://www.topografix.com/GPX/1/0 "
    append result "http://www.topografix.com/GPX/1/0/gpx.xsd\">\n"
    append result "$indent<url>$::state(homepage)</url>\n"
    append result "$indent<urlname>$::state(progname) Home Page</urlname>\n"
    append result "$indent<time>$t</time>\n"

    return $result
}
##+##########################################################################
#
# ::GPX::GetRoutePoints -- returns XML data w/ waypoints for each node
# and routepoints at each bend and node
#
proc ::GPX::GetRoutePoints {{name ""} {desc ""} {rteNumber 1}} {
    variable indent

    if {$name eq ""} {set name $::state(progname)}
    if {$desc eq ""} {set desc $::state(progname)}

    array set seen {}				;# Avoid doing wpt twice
    set wpt ""

    set rte "$indent<rte>\n"
    append rte "$indent$indent<name>$name</name>\n"
    append rte "$indent$indent<desc>$desc</desc>\n"
    append rte "$indent$indent<number>$rteNumber</number>\n"

    foreach pt [::Route::GetXYZ] {
	if {[lindex $pt 4] eq "waypoint"} {
	    set who [lindex $pt 5]
	    if {! [info exists seen($who)]} {
		append wpt [::GPX::WayPoint "wpt" $pt 1]
		set seen($who) 1
	    }
	}
	append rte [::GPX::WayPoint "rtept" $pt 2]
    }
    append rte "$indent</rte>\n"
    return [list $wpt $rte]
}
##+##########################################################################
#
# ::GPX::Roads2GPX -- converts one or more road into GPX XML format
#
proc ::GPX::Roads2GPX {args} {
    variable indent
    global roads state route

    set result [::GPX::Header]

    set cnt 0
    foreach rid $args {
	incr cnt
	foreach {nid1 nid2} $roads($rid) break

	::Route::ClearRoute
	set route(start) $nid1
	set route(tail) $nid2
	set route(nodes) [list $nid1 $nid2]
	set route(roads) $rid
	set route(turns) "B B"

	foreach {wpt rte} [::GPX::GetRoutePoints $rid $rid $cnt] break
	append result $rte
    }
    ::Route::ClearRoute
    append result "</gpx>"
    return $result
}
proc ::GPX::SaveRoad2GPX {rid} {
    set gpx [::GPX::Roads2GPX $rid]
    set fname [file join $::state(zdir) "road_$rid.gpx"]
    set fout [open $fname "w"]
    puts $fout $gpx
    close $fout
    return
}
##+##########################################################################
#
# ::GPX::Nodes2GPX -- converts one or more nodes into GPX XML format
#
proc ::GPX::AllNodes2GPX {} {
    return [::GPX::Nodes2GPX visible]
}
proc ::GPX::Nodes2GPX {args} {
    global nodes

    set arg0 [lindex $args 0]
    if {$arg0 eq "visible"} {
	set args $::region(node,visible)
    }

    set result [::GPX::Header]
    foreach nid $args {
	set pt [lrange $nodes($nid) 0 3]
	lappend pt waypoint $nid
	append result [::GPX::WayPoint "wpt" $pt 1]
    }
    append result "</gpx>"
    return $result
}
##+##########################################################################
#
# ::GPX::WayPoint -- produces GPX format for one of our nodes
#  pt is from ::Route::GetXYZ
#
proc ::GPX::WayPoint {xmlNode pt indentSize} {
    variable indent

    set pre [string repeat $indent $indentSize]
    set pre2 [string repeat $indent [expr {1 + $indentSize}]]
    foreach {desc ele lat lon type id} $pt break

    set result "$pre<$xmlNode lat=\"$lat\" lon=\"-$lon\""
    if {$type eq "routepoint"} {
	if {[::BadMath::IsBad $ele]} {
	    append result "/>\n"
	} else {
	    append result ">\n"
	    append result "$pre2<ele>[::Data::ToMetric $ele ft1]</ele>\n"
	    append result "$pre</$xmlNode>\n"
	}
	return $result
    }

    append result ">\n"
    if {! [::BadMath::IsBad $ele]} {
	append result "$pre2<ele>[::Data::ToMetric $ele ft1]</ele>\n"
    }
    if {$type eq "waypoint"} {
	regexp {^n?([A-Zn][0-9]+)} [string map {Xn X} $id] => id
	append result "$pre2<name>$id</name>\n"
	if {$desc ne ""} {
	    append result $pre2 {<cmt><![CDATA[} $desc {]]></cmt>} \n
	    append result $pre2 {<desc><![CDATA[} $desc {]]></desc>} \n
	}
	append result "$pre2<sym>Waypoint</sym>\n"
	append result "$pre2<type>KLIMB node</type>\n"
    } else {
	append result "$pre2<type>KLIMB road point</type>\n"
    }

    #append result "$pre2<src>USGS 7.5 Quad</src>\n"
    append result "$pre</$xmlNode>\n"
    return $result
}
## EON GPX
## BON POSTIT
##+##########################################################################
#
# ::Postit::Go -- adds postit/annotation for what/id
#
proc ::Postit::Go {what id {details {}} {omission {}}} {
    variable A

    if {$what eq "popup"} {
	set what $::state(popup,what)
	if {$what eq "node" || $what eq "road" || $what eq "poi" \
		|| $what eq "wpt" || $what eq "geo"} {
	    set id $::state(popup,who)
	} else {
	    set what "user"
	    set id [::Edit::GetNextID a]
	}
    }

    set aid "[string index $what 0],$id"
    if {$details eq {}} { set details 1}

    if {$details == 0} {
	::Postit::DialogX delete $aid
	return
    }

    set A($aid,what) $what
    set A($aid,id) $id
    ::Postit::GetText $aid $details $omission
    ::Postit::GetXY $aid
    ::Postit::Draw $aid
    if {$what eq "user"} {
	::Postit::Dialog $aid
    }
}
##+##########################################################################
#
# ::Postit::GetText -- figures out the text for a postit
#   1 = road/node name
#   2 = road/node distance/elev
#   4 = road climbing
#
proc ::Postit::GetText {aid details omission} {
    variable A
    global roads nodes poi

    if {[info exists A($aid,txt)] && [info exists A($aid,details)]} {
	if {$details eq {} || $A($aid,details) == $details} return
    }
    if {$details eq {}} {set details 1}

    set txt ""
    set id $A($aid,id)
    set what $A($aid,what)
    set A($aid,details) $details
    set noWrap 0
    if {$what eq "road"} {
	set txt ""

	foreach {. . north dist south . name . . . q} $roads($id) break

	;# Add in any skipped legs
	foreach {oNorth oDist oSouth} [concat $omission 0 0 0] break
	set north [::BadMath::Add $north $oNorth]
	set dist  [::BadMath::Add $dist $oDist]
	set south [::BadMath::Add $south $oSouth]

	if {$q <= $::zone(goodData)} {
	    set north [::BadMath::MakeGood $north]
	    set south [::BadMath::MakeGood $south]
	    set dist  [::BadMath::MakeGood $dist]
	}

	if {$details & 1} {
	    set txt $name
	    regsub -all {\s*\(.*\)} $txt {} txt	;# Remove parentheses
	    if {$txt eq ""} {set txt "Road $id"}
	    set n [expr {[string length $txt] / 2}]
	}
	if {$details & 2} {			;# Distance also
	    if {$txt ne ""} {append txt "\n"}
	    append txt [::Data::NBSP [::Data::Units $dist dist]]
	}
	if {$details & 4} {			;# climbing also
	    if {$txt ne ""} {append txt "\n"}
	    append txt [::Data::NBSP [::Data::Units $north climb 1]]
	    append txt "/"
	    append txt [::Data::NBSP [::Data::Units $south climb 1]]
	}
    } elseif {$what eq "node"} {
	set txt ""
	foreach {name ele} $nodes($id) break
	if {$details & 1} {
	    set txt $name
	    if {$txt eq ""} {set txt "Node [::Edit::PrettyNode $id]"}
	}
	if {$details & 2} {
	    if {$txt ne ""} {append txt "\n"}
	    append txt [::Data::Units $ele climb 2 0]
	}
    } elseif {$what eq "wpt"} {
	set txt [::GPS::GetWptAnnotation $id]
	set noWrap 1
    } elseif {$what eq "poi" || $what eq "wpt" || $what eq "geo"} {
	::Balloon::SetText $what $id
	if {[info exists ::Balloon::btext($what,$id)]} {
	    set txt $::Balloon::btext($what,$id)
	}
    }
    if {! $noWrap} {
	set n [expr {[string length $txt] / 2}]
	if {$n < 10} {set n 10}
	set txt [string trim [join [::Description::TwoLines $txt $n] "\n"]]
	set txt [::Data::NoNBSP $txt]
    }
    set A($aid,txt) $txt
}
##+##########################################################################
#
# ::Postit::ClearText -- clears cached postit data
#
proc ::Postit::ClearText {what who} {
    variable A

    set aid "[string index $what 0],$who"
    array unset A $aid,txt
}
##+##########################################################################
#
# ::Postit::GetXY -- figures out where a postit should go
#
proc ::Postit::GetXY {aid} {
    variable A
    global nodes roads poi state

    if {[info exists A($aid,xy)]} return
    set A($aid,anchor) n
    set A($aid,doShout) 1
    set x {}

    if {$A($aid,what) eq "road"} {
	foreach {lat lon} [::Data::Halfway $A($aid,id)] break
	foreach {x y} [::Display::pos2canvas root $lat $lon] break
	#foreach {nid1 nid2} $roads($A($aid,id)) break
	#foreach {x1 y1} [lindex $nodes($nid1) 4] break
	#foreach {x2 y2} [lindex $nodes($nid2) 4] break
	#set x [expr {($x1 + $x2) / 2}]
	#set y [expr {($y1 + $y2) / 2}]
	#set A($aid,doShout) 0
    } elseif {$A($aid,what) eq "node"} {
	set nid $A($aid,id)
	foreach {x y} [lindex $nodes($nid) 4] break
    } elseif {$A($aid,what) eq "poi"} {
	set poid $A($aid,id)
	foreach {x y} [lindex $poi($poid) 6] break
    } elseif {$A($aid,what) eq "wpt" || $A($aid,what) eq "geo"} {
	foreach {x y} [::GPS::GetXY $A($aid,id)] break
    } elseif {$A($aid,what) eq "user"} {
	if {[info exists state(popup,c)]} {
	    foreach {x y} $state(popup,c) break
	}
    }
    set A($aid,pt) [list $x $y]
    if {$A($aid,anchor) eq "n"} {
	set y [expr {$y + 15 + ($A($aid,doShout) ? 15 : 0)}]
    }
    set A($aid,xy) [list $x $y]
}
##+##########################################################################
#
# ::Postit::Draw -- draws the actual postit
#
proc ::Postit::Draw {aid} {
    variable A
    .c delete $aid

    if {! [info exists A($aid,txt)] || $A($aid,txt) eq ""} return
    if {! [info exists A($aid,xy)]} return
    foreach {x y} $A($aid,xy) break
    .c create text $x $y -tag [list $aid $aid,txt postit a,txt] \
	-justify center -text $A($aid,txt) -anchor $A($aid,anchor) \
	-font $::state(a,font)
    set xy [::Postit::GetShoutXY $aid]
    .c create poly $xy -tag [list postit $aid $aid,box a,box] -smooth 1 \
	-fill $::state(a,color) -outline black
    .c raise $aid,txt $aid,box
    .c raise nodes

    .c bind $aid <Button-1> [list ::Postit::Button click $aid %x %y]
    .c bind $aid <B1-Motion> [list ::Postit::Button move $aid %x %y]
    .c bind $aid <ButtonRelease-1> [list ::Postit::Button release $aid %x %y]
    .c bind $aid <Double-Button-1> [list ::Postit::Dialog $aid]
    .c bind $aid <<MenuMousePress>> \
	[list ::Display::DoPopupMenu %x %y postit $aid]
}
##+##########################################################################
#
# ::Postit::UpdateShout -- Updates postit box after its been
# move to have shout out
#
proc ::Postit::UpdateShout {aid} {
    variable A
    set xy [::Postit::GetShoutXY $aid]
    .c coords $aid,box $xy
}
##+##########################################################################
#
# ::Postit::GetShoutXY -- Returns coords for postit box which will
# have a) rounded corners and b) a shout out.
#
proc ::Postit::GetShoutXY {aid} {
    variable A
    variable maxShoutWidth
    set radius 5
    set optimalWidth 12

    foreach {ax ay} $A($aid,pt) break
    foreach xy {x0 y0 x1 y1} val [.c bbox $aid,txt] dxy {-3 -1 3 1} {
	set $xy [expr {$val + $dxy}]
    }
    set xy [::Display::RoundRectXY $x0 $y0 $x1 $y1 $radius]
    set A($aid,shout) [list 0 0]
    if {! $A($aid,doShout)} { return $xy }

    set side ""
    if {$ay < $y0} { set side N }
    if {$ay > $y1} { set side S }
    if {$side eq "" && $ax < $x0} { set side W }
    if {$side eq "" && $ax > $x1} { set side E }

    if {$side eq "N" || $side eq "S"} {
	set dx0 [expr {$x0+15}]
	set dx1 [expr {$dx0 + $optimalWidth}]
	if {$dx1 > $x1-2*$radius} {
	    set dx0 [expr {$x0 + 2*$radius}]
	    set dx1 [expr {$x1 - 2*$radius}]
	    if {$dx1 <= $dx0} {
		set dx0 [expr {($x0+$x1)/2 - 1}]
		set dx1 [expr {($x0+$x1)/2}]
	    }
	}

	set mid [expr {($x0+$x1)/2.}]
	if {$ax > $mid + ($x1-$x0)/4.} {     ;# Right side arrow
	    set x0 [expr {$mid + ($mid - $dx1)}]
	    set x1 [expr {$mid + ($mid - $dx0)}]
	    set dx0 $x0
	    set dx1 $x1
	}

	if {$side eq "N"} {
	    set shoutXY [linsert $xy 4 \
			     $dx0 $y0 $dx0 $y0 $dx0 $y0 \
			     $ax $ay $ax $ay $ax $ay \
			     $dx1 $y0 $dx1 $y0 $dx1 $y0]
	    set A($aid,shout) [list $side 0 $y0]
	} else {
	    set shoutXY [linsert $xy 16 \
			     $dx1 $y1 $dx1 $y1 $dx1 $y1 \
			     $ax $ay $ax $ay $ax $ay \
			     $dx0 $y1 $dx0 $y1 $dx0 $y1]
	    set A($aid,shout) [list $side 0 $y1]
	}
	return $shoutXY
    }
    if {$side eq "W" || $side eq "E"} {
	set dy0 [expr {$y0 + 2*$radius}]
	set dy1 [expr {$dy0 + $optimalWidth}]
	if {$dy1 > $y1-2*$radius} {
	    set dy0 [expr {$y0 + 2*$radius}]
	    set dy1 [expr {$y1 - 2*$radius}]
	    if {$dy1 <= $dy0} {
		set dy0 [expr {($y0+$y1)/2 - 1}]
		set dy1 [expr {($y0+$y1)/2}]
	    }
	}
	if {$side eq "W"} {
	    set shoutXY [linsert $xy 22 \
			     $x0 $dy1 $x0 $dy1 $x0 $dy1 \
			     $ax $ay $ax $ay $ax $ay \
			     $x0 $dy0 $x0 $dy0 $x0 $dy0]
	    set A($aid,shout) [list $side $x0 0]
	} else {
	    set shoutXY [linsert $xy 10 \
			     $x1 $dy0 $x1 $dy0 $x1 $dy0 \
			     $ax $ay $ax $ay $ax $ay \
			     $x1 $dy1 $x1 $dy1 $x1 $dy1]

	    set A($aid,shout) [list $side $x1 0]
	}
	return $shoutXY
    }
    return $xy
}
##+##########################################################################
#
# ::Postit::Redraw -- redraws all annotations (with possible different font)
#
proc ::Postit::Redraw {} {
    variable A

    foreach aid [array names A *,what] {
	regsub {,what$} $aid {} aid
	::Postit::Draw $aid
    }
}
##+##########################################################################
#
# ::Postit::Button -- handles button clicks on a postit
#
proc ::Postit::Button {what aid x y} {
    variable A
    variable cxy

    if {$what eq "click"} {
	set ::foo [list $what $aid $x $y]
	#xforeach {what aid x y} $::foo break
	.c itemconfig $aid,box -width 3
	.c config -cursor fleur
	set x [.c canvasx $x] ; set y [.c canvasy $y]
	set cxy [list $x $y]
	foreach {side shX shY} $A($aid,shout) break
	set A($aid,keepAnchor) 1
	if {($side eq "N" && $y < $shY) ||
	    ($side eq "S" && $y > $shY) ||
	    ($side eq "W" && $x < $shX) ||
	    ($side eq "E" && $x > $shX)	} {
	    set A($aid,keepAnchor) 0
	}
    } elseif {$what eq "release"} {
	.c itemconfig $aid,box -width 1
	.c config -cursor {}
	set A($aid,xy) [.c coords $aid,txt]
    } elseif {$what eq "move"} {
	set x [.c canvasx $x] ; set y [.c canvasy $y]
	foreach {ox oy} $cxy break		;# Where it was
	set dx [expr {$x - $ox}]
	set dy [expr {$y - $oy}]
	set cxy [list $x $y]

	.c move $aid $dx $dy
	if {$A($aid,keepAnchor)} {
	    ::Postit::UpdateShout $aid
	} else {
	    lset A($aid,pt) 0 [expr {[lindex $A($aid,pt) 0] + $dx}]
	    lset A($aid,pt) 1 [expr {[lindex $A($aid,pt) 1] + $dy}]
	    lset A($aid,shout) 1 [expr {[lindex $A($aid,shout) 1] + $dx}]
	    lset A($aid,shout) 2 [expr {[lindex $A($aid,shout) 2] + $dy}]
	}
    }
}
##+##########################################################################
#
# ::Postit::DoRoute -- Adds annotation for a complete route
#
proc ::Postit::DoRoute {{force 0}} {
    global route roads
    variable Details

    if {$force} { set Details(onoff) 1 }
    if {! $Details(onoff)} {
	::Postit::Reset
	return
    }
    set Details(rtotals) 0
    set rd [expr {$Details(rnames) + 2*$Details(rdist) + 4*$Details(rclimb)}]
    set nd [expr {$Details(nnames) + 2*$Details(nelev) + 4*$Details(rtotals)}]

    if {$route(start) == -1} return
    set oNorth [set oDist [set oSouth 0]]
    foreach rid [concat {{}} $route(roads)] nid $route(nodes) turn $route(turns) {
	if {$turn eq "O"} {		     ;# Skipped
	    foreach {. . north dist south} $roads($rid) break
	    set oNorth [::BadMath::Add $oNorth $north]
	    set oDist  [::BadMath::Add $oDist $dist]
	    set oSouth [::BadMath::Add $oSouth $south]
	    continue
	}
	if {$rid ne ""} {
	    ::Postit::Go road $rid $rd [list $oNorth $oDist $oSouth]
	    set oNorth [set oDist [set oSouth 0]]
	}
	::Postit::Go node $nid $nd
    }
    ::Display::Raise
}
##+##########################################################################
#
# ::Postit::Dialog -- puts up dialog to edit a postit's text
#
proc ::Postit::Dialog {aid} {
    variable A
    global state

    ::Postit::GetText $aid {} {}	;# In case it was cleared

    set W .postit
    set WBTN $W.buttons
    set txt "Annotation for $A($aid,what) [::Edit::PrettyNode $A($aid,id)]"
    set title "$state(progname) Annotation"
    ::Display::MakeDialogBox $W $title $title [list ::img::postit postit.gif]

    ::my::label $W.body.l -text $txt -font boldFont
    text $W.body.t -height 3 -width 30 -font {Helvetica 8}
    #::Display::TileBGFix $W.body.t
    $W.body.t insert end $A($aid,txt)
    ::my::checkbutton $W.body.shout -text "Show shout out" \
	-variable ::Postit::A(dlg,doShout)
    set A(dlg,doShout) $A($aid,doShout)
    grid $W.body.l -sticky w
    grid $W.body.t -sticky news
    grid $W.body.shout -sticky w
    grid columnconfigure $W.body 0 -minsize 10
    grid columnconfigure $W.body 0 -weight 1
    grid rowconfigure $W.body 1 -weight 1

    ::ttk::button $WBTN.update -text "Update" \
	-command [list ::Postit::DialogX "update" $aid]
    ::ttk::button $WBTN.delete -text "Delete" \
	-command [list ::Postit::DialogX delete $aid]
    ::ttk::button $WBTN.dismiss -text "Dismiss" -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    focus $W.body.t
    ::Display::CenterWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Postit::DialogX -- handles postit dialog button commands
#
proc ::Postit::DialogX {what aid} {
    variable A

    if {$what eq "delete"} {
	array unset A $aid,txt
	array unset A $aid,details
	.c delete $aid
	destroy .postit
	return
    }
    if {$what eq "update"} {
	set txt [string trim [.postit.body.t get 0.0 end]]
	regsub -all { +\n} $txt "\n" txt

	if {[string tolower $txt] eq "klimb is great!"} {
	    destroy .postit
	    ::Data::SetPriviledge "printing" 1
	    return
	}

	set A($aid,txt) $txt
	set A($aid,doShout) $A(dlg,doShout)
	::Postit::Go $A($aid,what) $A($aid,id) $A($aid,details)
	destroy .postit
	return
    }
}
##+##########################################################################
#
# ::Postit::Reset -- erases all postit state
#
proc ::Postit::Reset {} {
    variable A
    if {[winfo exists .c]} {
	.c delete postit
    }
    array unset A
    set ::state(postit,next) 1
    set ::Postit::Details(onoff) 0
}
## EON POSTIT
## BON PHOTO
##+##########################################################################
#
# ::Photo::AddNew -- creates a new photo
#
proc ::Photo::AddNew {phid lat lon url sdesc ldesc} {
    global photos

    if {$phid eq ""} {
	set phid [::Edit::GetNextID "ph"]
	if {$phid eq ""} {
	    WARN "Cannot get next photo id"
	    return
	}
    }
    if {$ldesc eq ""} { set ldesc $sdesc }
    set photos($phid) [list $lat $lon $url $sdesc $ldesc]
    ::Photo::Draw $phid
}
##+##########################################################################
#
# ::Photo::DrawAll -- draws all the photos we know about
#
proc ::Photo::DrawAll {} {
    global photos

    .c delete photo
    foreach phid [array names photos] {
	::Photo::Draw $phid
    }
}
##+##########################################################################
#
# ::Photo::Draw -- draws the actual photo
#
proc ::Photo::Draw {phid} {
    global photos

    .c delete $phid
    if {! [info exists photos($phid)]} return
    foreach {lat lon url sdesc ldesc} $photos($phid) break
    if {! [::Display::ClipNode $lat $lon]} return

    ::Display::MakeImage ::img::photo photo.gif

    set xy [::Display::pos2canvas root $lat $lon]
    .c create image $xy -image ::img::photo -tag [list photo $phid]
    ::Balloon::Create [list .c $phid] photo $phid $ldesc $sdesc
    ::Data::MarkModified photo $phid

    .c bind $phid <Double-Button-1> [list ::Photo::Dialog $phid]
    .c bind $phid <<MenuMousePress>> \
	[list ::Display::DoPopupMenu %x %y photo $phid]

    #.c bind $phid <Button-1> [list ::Photo::Button click $phid %x %y]
    #.c bind $phid <B1-Motion> [list ::Photo::Button move $phid %x %y]
    #.c bind $phid <ButtonRelease-1> [list ::Photo::Button release $phid %x %y]
}
##+##########################################################################
#
# ::Photo::Delete -- deletes a specific photo
#
proc ::Photo::Delete {phid} {
    global photos

    .c delete $phid
    array unset photos($phid)
    ::Data::MarkModified photo $phid 1
}
##+##########################################################################
#
# ::Photo::Dialog -- the dialog for a given photo
#
proc ::Photo::Dialog {phid} {
    global photos
    set schemas {klimb http local}
    set ::phid $phid

    foreach {lat lon url sdesc ldesc} $photos($phid) break
    set n [regexp {^(.*?):(.*?)$} $url => schema path]
    if {! $n} { return [WARN "malformed url for photo '$phid'\n'$url"] }
    if {[lsearch $schemas $schema] == -1} {
	return [WARN "Unknown schema '$schema' for photo '$phid'"]
    }

    if {$schema eq "klimb"} {
	::About::Large2 $path			;# Use About image dialog
	return
    }

    set W .photo
    set WF $W.ftitle
    set WB $W.body
    set WBTN $W.buttons
    ::Display::MakeDialogBox $W "Kodak Moment" "Kodak Moment" \
	[list ::img::camera camera.gif]
    #destroy $WF
    ::ttk::button $WBTN.dismiss -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    ::Photo::_FillBody $WB $phid $schema $path $ldesc

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Photo::_FillBody -- Fills in the body part of the photo dialog, based
# on the url schema
#
proc ::Photo::_FillBody {WB phid schema path caption} {
    set caption [string map [list \\n \n] $caption]

    if {$schema eq "http"} {
	set caption [::Data::WordWrap $caption 25]
	::my::label $WB.txt -text $caption -font fontBold -anchor c -justify c
	::ttk::button $WB.web -text "View in Browser" \
	    -command [list ::Photo::GoWeb $phid]
	set url "http:$path"
	::Balloon::Create $WB.web button photo $url $url
	pack $WB.txt -side top -fill x
	pack $WB.web -side top -pady 20

	if {! [::Data::CanDo webPage]} {
	    $WB.web config -state disabled
	}
	return
    }

    if {$schema eq "local"} {
	set dirs {about/org about local}
	lappend dirs [file join $::state(zdir) local]
	foreach dir $dirs {
	    set iname [file join $::state(idir) $dir $path]
	    if {[file exists $iname]} break
	}

	::my::label $WB.img -text "Missing Image" -foreground red \
	    -font bolderFont -anchor c
	::my::label $WB.ltxt -text $caption -font boldFont -anchor c -justify c
	if {[file exists $iname]} {
	    set bg [::ttk::style lookup [$WB.img cget -style] -background]
	    ::Display::MakeShadowPhoto ::img::photo2 $iname $bg
	    $WB.img config -image ::img::photo2
	}
	pack $WB.img -side top
	pack $WB.ltxt -side top
    }
}
##+##########################################################################
#
# ::Photo::GoWeb -- brings up the web page for this photo
#
proc ::Photo::GoWeb {phid} {
    global photos

    destroy .photo
    ::Balloon::Cancel
    WebPage [lindex $photos($phid) 2]
}
## EON PHOTO
## BON EMBELLISHMENT
proc ::Embellishment::AddNew {eid type ll options} {
    variable E
    set eid e,$eid
    set E($eid) [list $type $ll $options]
    ::Embellishment::Draw $eid
}
proc ::Embellishment::DrawAll {} {
    variable E
    foreach eid [array names E] {
	::Embellishment::Draw $eid
    }
}
proc ::Embellishment::Draw {eid} {
    variable E

    .c delete $eid
    if {! [info exists E($eid)]} return

    foreach {type ll options} $E($eid) break
    set visible 0
    set xy {}
    foreach {lat lon} $ll {
	if {[::Display::ClipNode $lat $lon]} { set visible 1 }
	set xy [concat $xy [::Display::pos2canvas root $lat $lon]]
    }
    if {! $visible} return

    if {$type eq "arrow"} {
	set type "line"
	set options [lassign $options dx dy]
	lassign $xy x y
	lappend xy [expr {$x+$dx}] [expr {$y+$dy}]
    }

    set n [catch {
	set id [eval [list .c create $type $xy] $options]
    }]
    if {! $n} {
	.c addtag $eid withtag $id
	.c addtag embell withtag $id
	.c bind $eid <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y embellishment $eid]
    }
}
## EON EMBELLISHMENT
## BON GPS
##+##########################################################################
#
# ::GPS::ReadGPSTrack -- reads GIS file w/ tracks and waypoints
#
proc ::GPS::ReadGPSTrack {fname2} {
    variable tracks
    variable wpts
    variable fname $fname2
    variable ready 0

    array unset ::GPS::wpts w*			;# Leave geocache data intact
    array unset ::GPS::tracks
    foreach var {tracks(rcnt) tracks(tcnt) tracks(tdate) \
		     wpts(wcnt) wpts(gcnt)} {
	if {! [info exists $var]} { set $var 0 }
    }

    # See if it's a XML file
    set n [::XML::Init file $fname]
    if {$n} {
	set xmlType [::XML::DocType]
	if {$xmlType eq "gpx"} {
	    ::GPS::ReadGPX
	} elseif {$xmlType eq "loc"} {
	    ::GPS::ReadLOC
	} elseif {$xmlType eq "History"} {	;# Garmin Forerunner
	    ::GPS::ReadHistory
	} else {
	    WARN "Unknown GPS file type"
	    ::GPS::ShowStatus 0 0
	    return
	}
	::GPS::ShowStatus 0 0
	set ready 1
	return
    }

    # See if it's a TOPO! file
    set n [::GPS::ReadTOPO! $fname 1]
    ::GPS::ShowStatus 0 0
    if {! $n} {
	WARN "Error reading GPS file: '$fname'"
	set ready -1
	return
    }
    set ready 1
}
#+##########################################################################
#
# ::GPS::ReadGPX -- reads in a <gpx> XML document
#
proc ::GPS::ReadGPX {} {
    variable tracks
    variable wpts

    foreach var {tracks(rcnt) tracks(tcnt) wpts(wcnt) wpts(gcnt)} {
	if {! [info exists $var]} { set $var 0 }
    }

    set start [clock clicks -milliseconds]
    ::GPS::ReadGPX_tcl
    set end [clock click -milliseconds]
    set ::ttime [expr {$end - $start}]
}
#proc ::GPS::ReadGPX_tdom {} {
#    variable tracks
#    variable wpts
#
#    array unset tracks
#    array unset wpts
#    foreach var {tracks(rcnt) tracks(tcnt) wpts(wcnt) wpts(gcnt)} {
#	if {! [info exists $var]} { set $var 0 }
#    }
#    ::Data::CanDo gpx
#
#    set token [::gpx::Create :: $::XML::XML]
#    foreach wptData [::gpx::GetAllWaypoints $token] {
#	lassign $wptData lat lon wptMeta
#
#	;# lat lon name desc url type xy ele name2
#	set wpt [list $lat [expr {abs($lon)}]]
#	foreach key {name desc url type xy ele name2} {
#	    if {[dict exists $wptMeta $key]} {
#		lappend wpt [dict get $wptMeta $key]
#	    } elseif {$key eq "desc" && [dict exists $wptMeta cmt]} {
#		lappend wpt [dict get $wptMeta cmt]
#	    } elseif {$key eq "link" && [dict exists $wptMeta link]} {
#		lappend wpt [dict get $wptMeta link href]
#	    } else {
#		lappend wpt ?
#	    }
#	}
#	set name [lindex $wpt 2]
#	set type [lindex $wpt 5]
#	if {$type eq "Geocache"} {
#	    set wpts(g,$name) $wpt
#	    incr wpts(gcnt)
#	} else {
#	    set wpts(w,$name) $wpt
#	    incr wpts(wcnt)
#	}
#    }
#    set tcnt [::gpx::GetTrackCount $token]
#    set tracks(tcnt) $tcnt
#    for {set trkId 0} {$trkId < $tcnt} {incr trkId} {
#	set trkMeta [::gpx::GetTrackMetadata $token [expr {$trkId+1}]]
#	set tracks($trkId,name) [dict get $trkMeta name]
#
#	set trkPts [::gpx::GetTrackPoints $token [expr {$trkId+1}]]
#	set tracks($trkId,track) {}
#	foreach trkPt $trkPts {
#	    lassign $trkPt lat lon trkMeta
#
#	    ;# lat lon ele time
#	    set thisPt [list $lat [expr {abs($lon)}]]
#	    set ele ?
#	    if {[dict exists $trkMeta ele]} {
#		set ele [dict get $trkMeta ele]
#		set ele [::Data::ToEnglish $ele m0]
#	    }
#	    lappend thisPt $ele
#	    set ttime ?
#	    if {[dict exists $trkMeta time]} {
#		set ttime [dict get $trkMeta time]
#		set ttime [::Data::ReadTime $ttime]
#	    }
#	    lappend thisPt $ttime
#
#	    lappend tracks($trkId,track) $thisPt
#	}
#    }
#    ::gpx::Cleanup $token
#}
proc ::GPS::ReadGPX_tcl {} {
    variable tracks
    variable wpts

    set _state 0
    while {1} {
	foreach {type val attr} [::XML::NextToken] break
	if {$type eq "EOF"} break
	if {$type ne "ELEMENT_NODE"} continue

	if {$_state == 0} {			;# Waiting for something
	    if {$val eq "trk"} {
		set xyz {}
		set _state 1
	    } elseif {$val  eq "rte"} {
		set xyz {}
		set _state 3
	    } elseif {$val eq "wpt"} {
		::GPS::ShowStatus
		set lat [::XML::GetAttribute $attr "lat"]
		set lon [::XML::GetAttribute $attr "lon"]
		;# lat lon name desc url type xy ele name2 time
		set wpt [list $lat [expr {abs($lon)}] ? ? ? ? ? ? ? time]
		set _state 5
	    } elseif {$val eq "time"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    set tracks(tdate) [::Data::ReadTime $val]
		}
	    }
	    continue
	}
	if {$_state == 1} {			;# In <trk>
	    if {$val eq "/trk"} {
		set tracks($tracks(tcnt),track) $xyz
		append tracks($tracks(tcnt),name) "" ;# Default to empty name
		incr tracks(tcnt)
		set _state 0
	    } elseif {$val eq "trkpt"} {
		::GPS::ShowStatus
		set lat [::XML::GetAttribute $attr "lat"]
		set lon [::XML::GetAttribute $attr "lon"]
		set pt [list $lat [expr {abs($lon)}] ? ?] ;# lat lon ele time
		set _state 2
	    } elseif {$val eq "name"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    set tracks($tracks(tcnt),name) $val
		}
	    }
	    continue
	}
	if {$_state == 2} {			;# In <trkpt>
	    if {$val eq "/trkpt"} {
		lappend xyz $pt
		set _state 1
	    } elseif {$val eq "ele"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    lset pt 2 [::Data::ToEnglish $val m0]
		}
	    } elseif {$val eq "time"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    set ttime [::Data::ReadTime $val]
		    if {$ttime ne ""} {
			lset pt 3 $ttime
		    }
		}
	    }
	    continue
	}
	if {$_state == 3} {			;# In <rte>
	    if {$val eq "/rte"} {
		set tracks($tracks(rcnt),route) $xyz
		incr tracks(rcnt)
		set _state 0
	    } elseif {$val eq "rtept"} {
		set lat [::XML::GetAttribute $attr "lat"]
		set lon [::XML::GetAttribute $attr "lon"]
		set pt [list $lat [expr {abs($lon)}] ?]
		set _state 4
	    }
	    continue
	}
	if {$_state == 4} {			;# In <rtept>
	    if {$val eq "/rtept"} {
		lappend xyz $pt
		set _state 3
	    } elseif {$val eq "ele"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    lset pt end $val
		}
	    }
	    continue
	}
	if {$_state == 5} {			;# In <wpt>
	    if {$val eq "/wpt"} {
		set name [lindex $wpt 2]
		set type [lindex $wpt 5]
		if {[string match -nocase "geocache*" $type]} {
		    set wpts(g,$name) $wpt
		    incr wpts(gcnt)
		} else {
		    set wpts(w,$name) $wpt
		    incr wpts(wcnt)
		}
		set _state 0
		continue
	    }
	    ;# lat lon name desc url type xy ele name2 time
	    if {[string match "/*" $val]} continue ;# Skip closing tag
	    foreach {type2 val2 attr2} [::XML::NextToken] break
	    if {$type2 ne "TEXT_NODE"} continue
	    if {$val eq "name"} {
		lset wpt 2 $val2
	    } elseif {$val eq "desc"} {
		lset wpt 8 $val2
		regsub {^(.*)\s+by\M.*$} $val2 {\1} val2 ;# No "by ..."
		lset wpt 3 $val2
	    } elseif {$val eq "url"} {
		lset wpt 4 $val2
	    } elseif {$val eq "type"} {
		lset wpt 5 [string totitle $val2]
	    } elseif {$val eq "ele"} {
		lset wpt 7 $val2
	    } elseif {$val eq "cmt"} {
		set ttime [::Data::ReadTime $val2]
		if {$ttime ne ""} {
		    lset wpt 9 $ttime
		}
	    }
	    continue
	}
    }
}
##+##########################################################################
#
# ::GPS::ReadLOC -- reads <loc> XML file--from www.geocaching.com
#  NB. this will only contain waypoints (geocache)
#
proc ::GPS::ReadLOC {} {
    variable tracks
    variable wpts

    foreach var {tracks(rcnt) tracks(tcnt) wpts(wcnt) wpts(gcnt)} {
	if {! [info exists $var]} { set $var 0 }
    }

    set start [clock clicks -milliseconds]
    if {$::XML::tdom(exists)} {
	::GPS::ReadLOC_tdom
    } else {
	::GPS::ReadLOC_tcl
    }
    set end [clock click -milliseconds]
    set ::ttime [expr {$end - $start}]
}
##+##########################################################################
#
# ::GPS::ReadLOC_tdom -- a tdom reader of .loc files
# assumes exact ordering w/i waypoint
#
proc ::GPS::ReadLOC_tdom {} {
    variable wpts

    dom parse $::XML::XML doc
    set root [$doc documentElement]		;# <loc>
    set waypoint [$root firstChild]
    set total [llength [$root childNodes]]

    set cnt 0
    while {1} {
	if {$waypoint eq {}} break		;# All done

	;# lat lon id desc url type xy ele desc2
	set this {? ? ? ? ? ? ? ? ?}
	incr cnt

	#set nameNode [$waypoint firstChild]
	set nameNode [$waypoint selectNodes name]
	set id [$nameNode getAttribute id]
	set name2 [set name [[$nameNode firstChild] data]]
	regsub {^(.*)\s+by\y.*$} $name {\1} name2 ;# Remove "by ..."
	lset this 2 $id
	lset this 8 $name
	lset this 3 $name2

	#set latNode [$waypoint child 2]
	set latNode [$waypoint selectNodes coord]
	set lat [$latNode getAttribute lat]
	set lon [$latNode getAttribute lon]
	lset this 0 $lat
	lset this 1 [expr {abs($lon)}]

	#set type [[[$waypoint child 3] firstChild] data]
	set type [[[$waypoint selectNodes type] firstChild] data]
	lset this 5 $type

	#set url [[[$waypoint lastChild] firstChild] data]
	#set url [[[$root selectNodes /loc/waypoint\[$cnt\]/link] firstChild] data]
	set url [[[$waypoint selectNodes link] firstChild] data]
	lset this 4 $url

	if {$type eq "Geocache"} {
	    set wpts(g,$id) $this
	    incr wpts(gcnt)
	} else {
	    set wpts(w,$id) $this
	    incr wpts(wcnt)
	}
	if {($cnt % 10) == 0} {
	    ::GPS::ShowStatus $cnt $total
	}

	set waypoint [$waypoint nextSibling]
    }
}
##+##########################################################################
#
# ::GSP::ReadLOC_tcl -- a tcl-only reader of .loc files
#
proc ::GPS::ReadLOC_tcl {} {
    variable wpts

    set _state 0
    set cnt -1
    while {1} {
	foreach {type val attr} [::XML::NextToken] break
	if {$type eq "EOF"} break

	if {$_state == 0} {			;# Waiting for <waypoint>
	    if {$type eq "ELEMENT_NODE" && $val eq "waypoint"} {
		;# lat lon name desc url type xy ele desc2 time
		set this {? ? ? ? ? ? ? ? ? ?}
		set _state 1
	    }
	    continue
	}
	if {$_state == 1} {			;# Inside a <waypoint>
	    if {$type ne "ELEMENT_NODE"} continue
	    if {$val eq "/waypoint"} {
		if {([incr cnt] % 10) == 0} ::GPS::ShowStatus
		set name [lindex $this 2]
		set type [lindex $this 5]

		if {$type eq "Geocache"} {
		    set wpts(g,$name) $this
		    incr wpts(gcnt)
		} else {
		    set wpts(w,$name) $this
		    incr wpts(wcnt)
		}
		set _state 0
	    } elseif {$val eq "name"} {
		set id [::XML::GetAttribute $attr "id"]
		lset this 2 $id
		foreach {type2 val2 attr2} [::XML::NextToken] break
		if {$type2 eq "TEXT_NODE"} {
		    lset this 8 $val2
		    regsub {^(.*)\s+by\M.*$} $val2 {\1} val2 ;# No "by ..."
		    lset this 3 $val2
		}
		continue
	    } elseif {$val eq "coord"} {
		set lat [::XML::GetAttribute $attr "lat"]
		set lon [::XML::GetAttribute $attr "lon"]
		lset this 0 $lat
		lset this 1 [expr {abs($lon)}]
		continue
	    } elseif {$val eq "link"} {
		foreach {type2 val2 attr2} [::XML::NextToken] break
		if {$type2 eq "TEXT_NODE"} {
		    lset this 4 $val2
		}
	    } elseif {$val eq "type"} {
		foreach {type2 val2 attr2} [::XML::NextToken] break
		if {$type2 eq "TEXT_NODE"} {
		    lset this 5 [string totitle $val2]
		}
	    }
	    continue
	}
    }
}
#+##########################################################################
#
# ::GPS::ReadHistory -- reads in a <History> XML document (Garmin Forerunner)
#   see http://www.garmin.com/xmlschemas/ForerunnerLogbookv1.xsd
#
proc ::GPS::ReadHistory {} {
    variable tracks
    variable wpts

    foreach var {tracks(rcnt) tracks(tcnt) tracks(tdate) \
		     wpts(wcnt) wpts(gcnt)} {
	if {! [info exists $var]} { set $var 0 }
    }

    set _state 0
    while {1} {
	foreach {type val attr} [::XML::NextToken] break
	if {$type eq "EOF"} break
	if {$type ne "ELEMENT_NODE"} continue

	if {$_state == 0} {			;# Waiting for something
	    if {$val eq "Track"} {
		set xyz {}
		set _state 1
	    } elseif {$val eq "Lap"} {		;# Contains meta data
		set _state 3
	    }
	    continue
	}
	if {$_state == 1} {			;# In <Track>
	    if {$val eq "/Track"} {
		set tracks($tracks(tcnt),track) $xyz
		append tracks($tracks(tcnt),name) "" ;# Default to empty name
		incr tracks(tcnt)
		set _state 0
	    } elseif {$val eq "Trackpoint"} {
		::GPS::ShowStatus
		set pt [list ? ? ? ?]		;# lat lon ele time
		set _state 2
	    }
	    continue
	}
	if {$_state == 2} {			;# In <Trackpoint>
	    if {$val eq "/Trackpoint"} {
		lappend xyz $pt
		set _state 1
	    } elseif {$val eq "Latitude"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    lset pt 0 $val
		}
	    } elseif {$val eq "Longitude"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    lset pt 1 [expr {abs($val)}]
		}
	    } elseif {$val eq "Altitude"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    lset pt 2 [::Data::ToEnglish $val m0]
		}
	    } elseif {$val eq "Time"} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    set ttime [::Data::ReadTime $val]
		    if {$ttime ne ""} {
			lset pt 3 $ttime
		    }
		}
	    }
	    continue
	}
	if {$_state == 3} {			;# In <Lap>
	    if {$val eq "/Lap"} {
		set _state 0
	    } elseif {$val eq "StartTime" && $tracks(tdate) != 0} {
		foreach {type val attr} [::XML::NextToken] break
		if {$type eq "TEXT_NODE"} {
		    set tracks(tdate) [::Data::ReadTime $val]
		}
	    }
	}
    }
}
##+##########################################################################
#
# ::GPS::ReadTOPO! -- reads in TOPO! GPS Data Format
#   TOPO! GPS Data Format DegMinSec NAD83 ElevFeet Local-Time
#   001,40,3,47,-82,29,50,919,10/15/2004,09:37:53,
#
proc ::GPS::ReadTOPO! {fname2 {useXML 0}} {
    variable tracks
    variable wpts
    variable fname $fname2

    array unset ::GPS::tracks
    set tracks(tcnt) 0
    set tracks(rcnt) 0

    if {$useXML} {
	set lines [split $::XML::XML "\n"]; set llen [llength $lines]
    } else {
	set fin [open $fname r]
	set lines [split [read $fin] "\n"]; set llen [llength $lines]
	close $fin
    }

    # Check for correct format
    set line [lindex $lines 0]
    if {! [string match "TOPO! GPS Data Format*" $line]} {return 0}
    set dms [regexp {DegMinSec} $line]

    set xyz {}					;# Our track
    for {set idx 1} {$idx < $llen} {incr idx} {
	::GPS::ShowStatus $idx $llen
	set line [lindex $lines $idx]
	set s [split $line ","]
	if {$dms} {
	    foreach {id lat1 lat2 lat3 lon1 lon2 lon3 ele date ttime} $s break
	} else {
	    foreach {id lat1 lat2 lon1 lon2 ele date ttime} $s break
	    set lat3 [set lon3 0]
	}

	set lat [lat2int $lat1 $lat2 $lat3]
	set lon [lat2int $lon1 $lon2 $lon3]
	set ele [::Data::ToMetric $ele feet]
	set rtime [clock scan "$ttime $date"]
	lappend xyz [list $lat $lon $ele $rtime]
    }

    if {[llength $xyz] > 0} {
	set tracks($tracks(tcnt),track) $xyz
	append tracks($tracks(tcnt),name) ""	;# Default to empty name
	incr tracks(tcnt)
	set tracks(tdate) [lindex $xyz 0 3]
	return 1
    }
    return 0
}
##+##########################################################################
#
# ::GPS::GetStartWpts -- Returns pseudo waypoint at start of a track
# if one isn't already there (needed by Google Maps)
#
proc ::GPS::GetStartWpts {trackNum} {
    variable tracks
    variable wpts

    lassign [lindex $tracks($trackNum,track) 0] lat lon
    set dist [::GPS::FindNearestWpt $lat $lon]
    if {$dist > 1000} {
	return [list $lat $lon "start track [expr {$trackNum+1}]"]
    }
    return [list ? ? ?]
}
##+##########################################################################
#
# ::GPS::FindNearestWpt -- Finds distance in feet to nearest waypoint
#
proc ::GPS::FindNearestWpt {lat lon} {
    variable wpts

    set minDist 9999
    foreach wpt [array names wpts w,*] {
	lassign $wpts($wpt) lat1 lon1
	set dist [::Data::Distance $lat $lon $lat1 $lon1 1]
	if {$dist < $minDist} {set minDist $dist}
    }
    return $minDist
}
##+##########################################################################
#
# ::GPS::ShowStatus -- does a progress bar of XML processing
#
proc ::GPS::ShowStatus {{num -1} {max -1}} {
    if {$num == -1} {
	foreach {num max} [::XML::Progress] break
    }
    ::Display::DoProgressBar $num $max
}
proc ::GPS::Status {} {
    if {$::GPS::ready != 1} {return [list $::GPS::ready 0 0 0 0]}
    return [list $::GPS::ready $::GPS::tracks(tcnt) $::GPS::tracks(rcnt) \
		$::GPS::wpts(wcnt) $::GPS::wpts(gcnt)]
}
proc ::GPS::Clear {} {
    array unset ::GPS::tracks
    array unset ::GPS::wpts
    set ::GPS::ready 0
    ::Geocache::DeleteAll
}
##+##########################################################################
#
# ::GPS::DrawWpts -- draws all known geocaches
#
proc ::GPS::DrawWpts {wtype reCenter {annotate 0}} {
    variable wpts

    set tag [expr {$wtype eq "g" ? "geo" : "wpt"}]
    set xy ""
    set isVisible 0

    .c delete $tag
    foreach id [array names wpts $wtype,*] {
	foreach {lat lon name desc url type} $wpts($id) break
	if {! [::Display::ClipNode $lat $lon]} continue ;# Off the screen
	set xy [::Display::pos2canvas root $lat $lon]
	lset wpts($id) 6 $xy
	incr isVisible [eval ::Display::IsVisible $xy]

	set tag2 ${tag}_$id
	::GPS::Symbol .c $xy $wtype [list $tag $tag2]

	set short $desc
	if {$short eq "?"} { set short $name }
	if {[string match "Flag,*" $type]} { set type "Waypoint" }
	set long "$type $name"
	if {$desc ne "?"} {
	    append long ": $desc"
	}

	::Balloon::Create [list .c $tag2] $tag $id $short $long
	.c bind $tag2 <Double-Button-1> [list ::GPS::ShowInfo $id]
	.c bind $tag2 <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y $tag $id]
	if {$annotate} {
	    ::Postit::Go wpt $id
	}
    }
    if {$reCenter && ! $isVisible} { ::Display::ToCenter $xy}
}
##+##########################################################################
#
# ::GPS::BalloonText -- returns text needed for balloon help for a waypoint
#
proc ::GPS::BalloonText {id} {
    variable wpts
    foreach {lat lon name desc url type} $wpts($id) break
    set desc [string trim $desc]
    return [list $desc "$type $name : $desc"]
}
##+##########################################################################
#
# ::GPS::GetXY -- returns position of a waypoint
#
proc ::GPS::GetXY {id} {
    variable wpts
    return [lindex $wpts($id) 6]
}
##+##########################################################################
#
# ::GPS::GetXYZ -- returns track in format used by ::Route::GetXYZ
#
proc ::GPS::GetXYZ {which} {
    variable tracks
    set pts {}
    foreach pt $tracks($which,track) {
	foreach {lat lon ele} $pt break
	lappend pts [list {} $ele $lat $lon routepoint $which "" $ele]
    }
    return $pts
}
proc ::GPS::GetWpts {} {
    variable wpts

    set pts {}
    foreach arr [array names wpts w,*] {
	;# lat lon name desc url type xy ele name2
	foreach {lat lon name . . . . ele .} $wpts($arr) break
	# name ele lat lon type who utm
	lappend pts [list $name $ele $lat $lon trackpoint . ""]
    }
    return $pts
}
##+##########################################################################
#
# ::GPS::DrawTrack -- draws the specified track, optionally only between
# low and high
#
proc ::GPS::DrawTrack {which {low 0} {high -1}} {
    variable tracks
    variable skip

    if {! [info exists tracks($which,track)]} return
    if {$high == -1} { set high [llength $tracks($which,track)] }

    set id $which
    set xyz $tracks($which,track)
    set xy {}
    set x0 [set y0 -999]
    set trkpt 0
    set colors [list "yellow" "green" "deepskyblue" "deeppink"]
    set color [lindex $colors [expr {$id % [llength $colors]}]]

    for {set i $low} {$i <= $high} {incr i} {
	set pt [lindex $xyz $i]
	if {$pt eq ""} break

	foreach {lat lon ele ttime} $pt break
	set lat [lat2int $lat 0 0]
	set lon [lat2int [expr {abs($lon)}] 0 0]
	foreach {x1 y1} [::Display::pos2canvas root $lat $lon] break
	if {int($x1) == int($x0) && int($y1) == int($y0)} continue

	lappend xy $x1 $y1
	set x0 $x1 ; set y0 $y1

	set tag2 "trkpt_[incr trkpt]"
	if {$skip >= 0 && ($trkpt == 1 || $skip == 0 || ($trkpt % $skip) == 0)} {
	    .c create oval [::Display::MakeBox [list $x1 $y1] 3] -fill $color \
		-outline black -tag [list trk trkpt $tag2]
	    set ele [Round0  $ele]
	    ::Balloon::Create [list .c $tag2] trkpt $trkpt \
		"trkpt $trkpt\n$ele ft"
	}
    }
    if {[llength $xy] > 2} {
	incr id
	.c create line $xy -tag [list trk trk$id] -width 5 -fill $color
	.c bind trk$id <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y track $id]
	::Balloon::Create [list .c trk$id] trk $id "track $id" "track $id"

	::Display::ToCenter [lrange $xy 0 1]
    }
    ::Display::Raise
}
##+##########################################################################
#
# ::GPS::ClearTrack -- erases all tracks on the map
#
proc ::GPS::ClearTrack {} {
    .c delete trk
}
##+##########################################################################
#
# ::GPS::GetTrackXY -- returns canvas xy and total distance for track segment
#
proc ::GPS::GetTrackXY {tid {start 0} {end 0x7fffFFFF}} {
    variable tracks

    if {$start <= $end} {
	set tpts [lrange $tracks($tid) $start $end]
    } else {
	set tpts [::Data::Reverse [lrange $tracks($tid) $end $start]]
    }

    set xy {}
    set x0 [set y0 -999]
    set dist 0					;# How long the hill is
    set lat0 -999
    foreach pt $tpts {
	foreach {lat lon ele ttime} $pt break
	set lat [lat2int $lat 0 0]
	set lon [lat2int [expr {abs($lon)}] 0 0]
	foreach {x1 y1} [::Display::pos2canvas root $lat $lon] break
	if {int($x1) == int($x0) && int($y1) == int($y0)} continue

	lappend xy $x1 $y1
	set x0 $x1 ; set y0 $y1

	if {$lat0 != -999} {
	    set d [::Data::Distance $lat $lon $lat0 $lon0]
	    set dist [expr {$dist + $d}]
	}
	set lat0 $lat ; set lon0 $lon
    }
    return [list $xy $dist]
}
##+##########################################################################
#
# ::GPS::GetProfileData -- takes a GPS route creates the data structure
# used by the ::Profile code
#
proc ::GPS::GetProfileData {tnum} {
    variable tracks

    set xy {}
    set tnodes {}
    foreach {. tclimb tdesc} $tracks($tnum,stats) break
    set tclimb [Round10 [::Data::Convert [lindex $tracks($tnum,stats) 1] climb]]
    set tdesc [Round10 [::Data::Convert [lindex $tracks($tnum,stats) 2] climb]]

    set hidx 0
    set hidx2 [lindex $tracks($tnum,compress) $hidx 5]
    set sofar 0					;# Climb so far

    set tdist 0
    set idx -1
    foreach pt $tracks($tnum,track) {
	incr idx
	foreach {lat lon ele} $pt break
	set lat [lat2int $lat 0 0]
	set lon [lat2int [expr {abs($lon)}] 0 0]

	if {$xy eq {}} {			;# First point
	    foreach {lat0 lon0 ele0} [list $lat $lon $ele] break
	    set minE [set maxE $ele]
	}
	if {$ele < $minE} {set minE $ele} elseif {$ele > $maxE} {set maxE $ele}

	;# Handle climbing so far
	set this {}
	if {$idx == $hidx2} {
	    set d [lindex $tracks($tnum,compress) $hidx 4]
	    if {$d > 0} { set sofar [expr {$sofar + $d}] }
	    incr hidx
	    set hidx2 [lindex $tracks($tnum,compress) $hidx 5]
	    set this $sofar
	}

	set dist [::Data::Distance $lat0 $lon0 $lat $lon]
	set tdist [expr {$tdist + $dist}]
	lappend xy [list $tdist $ele]
	lappend tnodes [list -1 $tdist $ele 4 $this 0]

	foreach {lat0 lon0 ele0} [list $lat $lon $ele] break
    }
    set data [list 0 [Round1 $tdist] $minE $maxE $tclimb $tdesc $tnodes]
    return $data
}
##+##########################################################################
#
# ::GPS::ShowInfo -- double click dialog for wpt or geo
#
proc ::GPS::ShowInfo {id} {
    variable wpts

    set ::geoid $id
    foreach {lat lon name desc url type . ele} $wpts($id) break
    set lat [int2lat [lat2int $lat 0 0]]
    set lon [int2lat [lat2int $lon 0 0]]
    foreach {lat lon} [::Display::PrettyLat $lat $lon] break

    set W .geo
    if {$type eq "Waypoint"} {
	set wtitle "$::state(progname) GPS Location"
	set title "$type $name\nLatitude $lat\nLongitude $lon"
	set icon [list ::img::gps gps.gif]
	set desc "$type $desc"
    } else {
	set wtitle "$::state(progname) Geocache Location"
	set title "$type $name\nLatitude $lat\nLongitude $lon"
	set icon [list ::img::geo geocache.gif]
    }
    ::Display::MakeDialogBox $W $wtitle $title $icon

    set width [winfo reqwidth $W.title]
    if {[string is double -strict $ele] && $ele > 0} {
	set ele [::Data::RConvert2 $ele climb metric]
	append desc "\nElevation: [::Data::Units [Round10 $ele] climb 1]"
    }
    message $W.body.txt -text $desc -anchor w -width $width
    ::Display::TileBGFix $W.body.txt
    grid $W.body.txt -sticky ew

    ::ttk::button $W.dismiss -text "Dismiss" -command [list destroy $W]
    ::ttk::button $W.zoom -text Zoom -command "destroy $W; ::Zoom::Go geo $id"
    ::ttk::button $W.browse -text "Web" -command "WebPage $url; destroy $W"
    if {! [::Data::CanDo webPage]} { $W.browse config -state disabled }
    ::Balloon::Create $W.browse geocache url "Look on the web for details" $url
    pack $W.browse $W.zoom $W.dismiss -side left -expand 1 -pady 10 -padx 10 \
	-in $W.buttons
    if {$url eq "?"} {destroy $W.browse}
    if {$type eq "Waypoint"} {destroy $W.zoom}

    ::Display::CenterWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::GPS::Symbol -- draws our symbol for a waypoint or geocache
#
proc ::GPS::Symbol {W xy type tag {sscale 1}} {
    global state

    set color $state($type,color)
    set fill $state($type,fill)
    set radius [expr {$state($type,size) * $sscale}]

    set r2 [expr {sqrt($radius*$radius /2.0)}]
    foreach {X0 Y0 X1 Y1} [::Display::MakeBox $xy $radius] break
    foreach {x0 y0 x1 y1} [::Display::MakeBox $xy $r2] break

    set tagx [concat $tag wo]
    $W create oval $X0 $Y0 $X1 $Y1 -outline $color -fill $fill -tag $tagx \
	-width 2

    set tagx [concat $tag wx]
    $W create line $x0 $y0 $x1 $y1 -tag $tagx -fill $color -width $sscale
    $W create line $x0 $y1 $x1 $y0 -tag $tagx -fill $color -width $sscale
    foreach {x y} $xy break
    $W create line $X0 $y  $X1 $y  -tag $tagx -fill $color -width $sscale
    $W create line $x  $Y0 $x  $Y1 -tag $tagx -fill $color -width $sscale
}

proc ::GPS::__Node2Track {nid {tid 0,track}} {
    variable tracks
    variable err

    foreach {. alt lat lon} $::nodes($nid) break
    set idx [::GPS::Closest2Track $lat $lon $tid 0]

    set alt2 [lindex $tracks($tid) $idx 2]
    set err(node,$nid,dist) [Round1 $err(dist)]
    set err(node,$nid,alt) [expr {$alt - $alt2}]
    set err(node,$nid,xalt) $alt2
    return $idx
}
proc ::GPS::__ExtractRoad {rid {tid 0,track}} {
    variable tracks

    foreach {nid1 nid2} $::roads($rid) break
    set idx1 [::GPS::Node2Track $nid1 $tid]
    set idx2 [::GPS::Node2Track $nid2 $tid]
    if {$idx1 > $idx2} {
	foreach idx1 $idx2 idx2 $idx1 break
    }
    set tracks(road,$rid) [lrange $tracks($tid) $idx1 $idx2]
    return $rid
}


proc ::GPS::__RoadClimb {rid {tid 0,track}} {
    variable err

    foreach {nid1 nid2} $::roads($rid) break
    set idx1 [::GPS::Node2Track $nid1 $tid]
    set idx2 [::GPS::Node2Track $nid2 $tid]

    set southBound 1
    if {$idx1 > $idx2} {
	foreach idx1 $idx2 idx2 $idx1 break
	set southBound 0
    }
    foreach {climb desc} [::GPS::ComputeClimb $tid $idx1 $idx2] break
    if {$southBound} {
	return [list $desc $climb $idx1 $idx2]
    }
    return [list $climb $desc $idx2 $idx1]
}
proc ::GPS::__RouteClimb {{tid 0,track}} {
    global route roads
    variable err
    array unset err

    set result ""
    set from $route(start)
    foreach rid $route(roads) {
	foreach {nid1 nid2} $roads($rid) break
	set to $nid1
	if {$from eq $nid1} {set to $nid2}

	foreach {climb desc} [::GPS::RoadClimb $rid] break
	set diff [expr {$climb - $desc}]
	foreach {. . kclimb . kdesc} $::roads($rid) break
	set kdiff [::BadMath::Real [::BadMath::Sub $kclimb $kdesc]]

	set eclimb [expr {$climb - [::BadMath::Real $kclimb]}]
	set edesc  [expr {$desc  - [::BadMath::Real $kdesc]}]
	set ediff  [expr {$diff  - [::BadMath::Real $kdiff]}]

	regsub {\.\d+$} $rid {} rid

	regexp {^[^.]*} $from f
	regexp {^[^.]*} $to t
	set d1 "$f (dist: $err(node,$from,dist), alt: $err(node,$from,alt))"
	set d2 "$t (dist: $err(node,$to,dist), alt: $err(node,$to,alt))"
	set line [format "%5s: %-18s -> %-18s : " $rid $d1 $d2]
	append line [format "%5s / %5s  (%s /%s)" $climb $desc $kclimb $kdesc]


	#set line [format "%4s %-11s:" $rid "($f,$t)"]
	#append line [format " %5s/ %5s %8s" $climb $desc "($diff)"]
	#append line [format " :: %5s/ %5s %8s" $kclimb $kdesc "($kdiff)"]
	#append line [format " : %4s (%5s,%5s) -> %4s (%5s,%5s)" \
	#	      $f $err(node,$from,dist) $err(node,$from,alt) \
	#	      $t $err(node,$to,dist) $err(node,$to,alt)]

	set line [format "%4s %-11s:" $rid "($f,$t)"]
	append line [format " climb: %6s %6s %8s" $climb $kclimb "($eclimb)"]
	append line [format "  desc: %6s %6s %8s" $desc $kdesc "($edesc)"]
	append line [format "  delta: %6s %6s %8s" $diff $kdiff "($ediff)"]
	append line "\n"

	set line [format "%4s: %4s -> %4s\n" $rid $d1 $d2]
	append line [format "  climb: %6s %6s %8s\n" $climb $kclimb "($eclimb)"]
	append line [format "  desc:  %6s %6s %8s\n" $desc $kdesc "($edesc)"]
	append line [format "  delta: %6s %6s %8s\n" $diff $kdiff "($ediff)"]

	append result $line
	set from $to
    }
    return $result
}
proc ::GPS::Closest2Track {lat lon which {start 0}} {
    variable tracks
    variable err

    set len [llength $tracks($which)]
    for {set idx $start} {$idx < $len} {incr idx} {
	foreach {rlat rlon} [lindex $tracks($which) $idx] break

	set dist [::Data::Distance $lat $lon $rlat $rlon 1]
	if {$dist < 100} {
	    #puts "$idx: $dist"
	}
	if {$idx == $start || $dist < $min} {
	    set min $dist
	    set best $idx
	}
    }
    set err(dist) $min
    return $best
}
proc ::GPS::ComputeClimb {which {start 0} {end end}} {
    variable tracks

    # First convert absolute altitudes into delta
    set deltas {}
    set last [lindex $tracks($which) $start 2]
    foreach xyz [lrange $tracks($which) $start $end] {
	set alt [lindex $xyz 2]
	set d [expr {$alt - $last}]
	if {$d != 0} {
	    lappend deltas $d
	}
	set last $alt
    }

    # Next, combine consecutive climbs or descends into one item
    set result {}
    lappend deltas 0
    set last 0
    foreach delta $deltas {
	if {($delta < 0 && $last < 0) || ($delta > 0 && $last > 0)} {
	    set last [expr {$last + $delta}]
	} else {
	    lappend result $last
	    set last $delta
	}
    }
    set result [lrange $result 1 end]
    return [CalcClimb $result]
}
##+##########################################################################
#
# ::GPS::GetWptAnnotation -- Returns text to go into a waypoint annotation
#
proc ::GPS::GetWptAnnotation {id} {
    variable wpts

    ;# lat lon name desc url type xy ele name2 time
    lassign $wpts($id) . . name desc url type xy ele name2 ttime

    set txt {}
    if {$name ne "?"} {  append txt $name \n}
    if {$name2 ne "?"} { append txt $name2 \n}
    if {$desc ne "?"} {  append txt $desc \n}
    if {$url ne "?"} {   append txt $url \n}
    if {$ttime ne "?" && $ttime ne "time"} {
	append txt [clock format $ttime -format "%b %d, %Y %l:%M %p"] \n
    }
    if {$ele ne "?"} {
	set feet [Round0 [::Data::ToEnglish $ele m]]
	set pretty [::Data::Units $feet climb 1]
	append txt "Elevation: $pretty\n"
    }
    return [string trim $txt]
}
## EON GPS
## BON GEOCACHE
##+##########################################################################
#
# ::Geocache::Dialog -- displays our Geocaching dialog box
#
proc ::Geocache::Dialog {} {
    set W .geocache
    set WBTN $W.buttons
    set title "$::state(progname) Geocache Dialog"
    ::Display::MakeDialogBox $W $title $title [list ::img::geo geocache.gif] 5
    wm deiconify $W

    ::ttk::button $WBTN.dismiss -text "Dismiss" -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    ::my::labelframe $W.ffile -text "Geocache File"
    ::my::entry $W.ename -textvariable ::Geocache::fname -state disabled
    ;#T $W.ename config -disabledforeground [$W.ename cget -fg]
    ::ttk::button $W.bname -text "Browse..." -command [list ::Geocache::Read $W]
    grid $W.ename $W.bname -in $W.ffile -padx 5 -sticky ew -pady {0 5}
    grid columnconfigure $W.ffile 0 -weight 1

    ::my::label $W.msg -textvariable ::Geocache::S(msg) -foreground red -anchor center
    set ::Geocache::S(msg) ""

    ::my::labelframe $W.show -text "Geocache Info"
    $W.show config -pad 5
    ::my::label $W.ltcnt -text "Total:" -anchor w
    ::my::label $W.tcnt -textvariable ::Geocache::tcnt -anchor w
    ::ttk::button $W.delete -text "Delete All" -command ::Geocache::DeleteAll
    ::my::label $W.lvcnt -text "Visible:" -anchor w
    ::my::label $W.vcnt -textvariable ::Geocache::vcnt -anchor w -width 22

    grid $W.ltcnt $W.tcnt -in $W.show -sticky we
    grid $W.delete -row 0 -in $W.show -column 2
    grid $W.lvcnt $W.vcnt -in $W.show -sticky we

    grid $W.ffile -sticky ew -in $W.body
    grid $W.msg -sticky ew -in $W.body -pady {10 0}
    grid $W.show -sticky ew -in $W.body -pady 10

    ::Geocache::CntVisible
    ::Display::CenterWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Geocache::CntVisible -- counts how many geocaches are in the region
#
proc ::Geocache::CntVisible {} {
    variable tcnt
    variable vcnt

    set tcnt [llength [array names ::GPS::wpts g,*]]
    set vcnt 0
    foreach pt [array names ::GPS::wpts g,*] {
	foreach {lat lon} $::GPS::wpts($pt) break
	incr vcnt [::Display::ClipNode $lat $lon]
    }
}
##+##########################################################################
#
# ::Geocache::Read -- reads GIS file w/ geocache data
#
proc ::Geocache::Read {W {filename ""}} {
    variable fname
    variable defaultName

    if {$filename eq ""} {			;# Get file to load
	set types {
	    {{TopoGrafix Data Files} {.loc}}
	    {{GPX Exchange Files} {.gpx}}
	    {{All Files} *}}

	set filename $fname
	if {$filename eq "<nothing loaded>"} {set filename $defaultName}
	set ext [file extension $filename]
	if {$ext eq ""} {set ext ".loc"}
	set filename [tk_getOpenFile \
			  -defaultextension $ext \
			  -title "$::state(progname) Browse for Geocache File" \
			  -filetypes $types \
			  -parent $W \
			  -initialdir [file dirname $filename] \
			  -initialfile [file tail $filename]]
	if {$filename eq ""} return
    }
    ::Geocache::DeleteAll
    set fname $filename
    set defaultName $filename

    ::Display::MakeProgressBar . "Processing Geocache Data"

    # See if it's a XML file
    set n [::XML::Init file $fname]
    if {$n} {
	set xmlType [::XML::DocType]
	if {$xmlType eq "gpx"} {
	    ::GPS::ReadGPX
	} elseif {$xmlType eq "loc"} {
	    ::GPS::ReadLOC
	}
	set ::GPS::ready 1
    }

    ::Display::DoProgressBar 0 0		;# Delete progress bar
    ::GPS::DrawWpts g 0
    ::Geocache::CntVisible
    ::NodeList::Create				;# Should be up a level
    set ::Geocache::S(msg) \
	"$::GPS::wpts(gcnt) [::Data::Plural $::GPS::wpts(gcnt) waypoint waypoints] loaded"
}
##+##########################################################################
#
# ::Geocache::DeleteAll -- erases currently loaded geocaches
#
proc ::Geocache::DeleteAll {} {
    variable fname "<nothing loaded>"
    variable tcnt 0
    variable vcnt 0

    array unset ::GPS::wpts g,*			;# Don't touch track, waypoint
    set ::GPS::wpts(gcnt) 0
    if {[winfo exists .c]} {.c delete geo}
}
## EON GEOCACHE
## BON TRACKS
##+##########################################################################
#
# ::Tracks::Dialog -- displays our GPS dialog box
#
proc ::Tracks::Dialog {} {
    set W .gps
    set WBTN $W.buttons
    set title "$::state(progname) GPS Dialog"
    ::Display::MakeDialogBox $W $title $title [list ::img::gps gps.gif] 5
    wm protocol $W WM_DELETE_WINDOW "::Tracks::Cleanup ; destroy $W"

    ::ttk::button $WBTN.clear -text "Clear" -command ::Tracks::Cleanup
    ::ttk::button $WBTN.dismiss -text "Dismiss" -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    ::my::labelframe $W.ffile -text "GPS Track File"
    ::my::entry $W.ename -textvariable ::Tracks::fname -state disabled
    ;#T $W.ename config -disabledforeground [$W.ename cget -fg]
    ::ttk::button $W.bname -text "Browse..." -command [list ::Tracks::GetFile $W]
    grid $W.ename $W.bname -in $W.ffile -padx 5 -sticky ew -pady {0 5}
    grid columnconfigure $W.ffile 0 -weight 1

    ::my::labelframe $W.show -text "Track Info"
    $W.show config -pad 5
    ::my::frame $W.show.labels
    ::my::frame $W.show.buttons
    grid $W.show.labels x $W.show.buttons -sticky new
    grid columnconfigure $W.show 1 -weight 1

    ::my::label $W.tlname -text "Name:" -anchor w
    ::my::label $W.tname -textvariable ::Tracks::name -anchor w
    ::my::label $W.tldate -text "Date:" -anchor w
    ::my::label $W.tdate -textvariable ::Tracks::tdate -anchor w -width 22
    ::my::label $W.tldist -text "Distance:" -anchor w
    ::my::label $W.tdist -textvariable ::Tracks::distance -anchor w
    ::my::label $W.tltime -text "Time:" -anchor w
    ::my::label $W.ttime -textvariable ::Tracks::ttime -anchor w

    ::my::label $W.tlclimb -text "Climb:" -anchor w
    ::my::label $W.tclimb -textvariable ::Tracks::climbs -anchor w
    ::my::label $W.tldescend -text "Descend:" -anchor w
    ::my::label $W.tdescend -textvariable ::Tracks::descends -anchor w

    ::my::label $W.tllegs -text "Legs:" -anchor w
    ::my::label $W.tlegs -textvariable ::Tracks::legs -anchor w
    ::my::label $W.tlwpt -text "Waypoints:" -anchor w
    ::my::label $W.twpt -textvariable ::Tracks::waypoints -anchor w
    grid $W.tlname $W.tname -in $W.show.labels -sticky we
    grid $W.tldate $W.tdate -in $W.show.labels -sticky we
    grid $W.tldist $W.tdist -in $W.show.labels -sticky we
    grid $W.tltime $W.ttime -in $W.show.labels -sticky we
    grid $W.tlclimb $W.tclimb -in $W.show.labels -sticky we
    grid $W.tldescend $W.tdescend -in $W.show.labels -sticky we
    grid $W.tllegs $W.tlegs -in $W.show.labels -sticky we
    grid $W.tlwpt $W.twpt -in $W.show.labels -sticky we

    ::Tracks::TrackSelector
    ::ttk::button $W.track -text "Show Track" -command {::Tracks::DoIt track}
    ::ttk::button $W.profile -text "Show Profile" -command {::Tracks::DoIt profile}
    ::ttk::button $W.3dprofile -text "Show 3D Profile" \
	-command {::Tracks::DoIt 3dprofile}
    if {! [::Data::CanDo 3d]} {$W.3dprofile config -state disabled}
    ::ttk::button $W.wpt -text "Show Waypoints" -command {::Tracks::DoIt wpt}
    ::ttk::button $W.google -text "Google Maps" -command {::Tracks::DoIt google}
    ::ttk::button $W.zoom -text "Zoom" -command {::Tracks::DoIt zoom}
    grid $W.select -in $W.show.buttons -sticky ew
    grid $W.track -in $W.show.buttons -sticky ew
    grid $W.profile -in $W.show.buttons -sticky ew
    grid $W.3dprofile -in $W.show.buttons -sticky ew
    grid $W.wpt -in $W.show.buttons -sticky ew
    grid $W.google -in $W.show.buttons -sticky ew
    grid $W.zoom -in $W.show.buttons -sticky ew


    set WNB "$W.nb"
    ttk::notebook $WNB -padding 6
    ttk::notebook::enableTraversal $WNB

    ::my::frame $W.hill
    $WNB add $W.hill -text "Hills" -underline 0 -padding 5

    ::my::frame $W.hill.f
    ::ttk::button $W.fhill -image ::img::star -command ::Tracks::GetHillData
    ::my::label $W.flbl -text "Show hills taller than"
    ::my::entry $W.hheight -textvariable ::Tracks::height_external -width 5
    set ::Tracks::height_external [::Data::Convert $::Tracks::height climb]
    set units [::Data::Label 0 climb 0]
    regsub {^[0-9]+ +} $units {} units
    ::my::label $W.hunits -text $units
    ::my::label $W.lslope -text "and steeper than"
    ::my::entry $W.eslope -textvariable ::Tracks::slope -width 3
    ::my::label $W.lslope2 -text "%"

    grid $W.hill.f - -pady 5 -sticky news
    grid $W.fhill $W.flbl $W.hheight $W.hunits $W.lslope $W.eslope $W.lslope2 \
	-in $W.hill.f -sticky wns

    ::ttk::scrollbar $W.hill.sb -orient v -command [list $W.hill.lb yview]
    listbox $W.hill.lb -height 9 -exportselection 0 -highlightthickness 0 \
	-listvariable ::Tracks::hillData -yscroll [list $W.hill.sb set] \
	 -background white

    #::Display::TileBGFix $W.hill.lb
    bind $W.hill.lb <<ListboxSelect>> {::Tracks::HillSelect %W}
    grid $W.hill.lb $W.hill.sb -sticky news -pady {0 5}
    grid rowconfigure $W.hill 1 -weight 1
    grid columnconfigure $W.hill 0 -weight 1

    ::my::label $W.segs
    $WNB add $W.segs -text "Segments" -underline 0 -padding 5
    ::Tracks::SegmentsPane $W.segs

    grid $W.ffile -sticky ew -in $W.body
    grid $W.show -sticky ew -in $W.body -pady 10
    grid $WNB -sticky news -in $W.body
    grid rowconfigure $W.body 2 -weight 1
    grid columnconfigure $W.body 0 -weight 1

    ::Tracks::ReState
    ::Display::RightWindow $W
    wm deiconify $W
    wm resizable $W 1 1
}
proc ::Tracks::NewZone {} {
    set ::Tracks::fname "<nothing loaded>"
}
##+##########################################################################
#
# ::Tracks::SegmentsPane -- Draws the track segments notebook pane
#
proc ::Tracks::SegmentsPane {W} {
    variable Segs
    set Segs(wt) $W.t

    ::ttk::frame $W.buttons
    checkbutton $W.buttons.all -text "Select / deselect all" \
	-variable ::Tracks::Segs(all) \
	-command [list ::Tracks::ToggleSegments toggle]
    ::ttk::button $W.buttons.road -text "Create New Road" \
	-command [list ::Tracks::MakeRoadDialog $W.buttons.road]
    ;# ::ttk::button $W.buttons.on -text "All on" \
    ;# 	-command [list ::Tracks::ToggleSegments on]
    ;# ::ttk::button $W.buttons.off -text "All off" \
    ;# 	-command [list ::Tracks::ToggleSegments off]
    eval pack [winfo child $W.buttons] -side left -expand 1 -pady {{10 0}}
    pack $W.buttons -side bottom -fill x

    ::ttk::scrollbar $W.sb_y -command [list $W.t yview] -orient vertical
    text $W.t -yscrollcommand [list $W.sb_y set] -width 40 -height 20
    $W.t config -cursor arrow
    $W.t config -tabs {70 center 160 center 280 center}
    $W.t tag config sel -background magenta -foreground black
    $W.t tag config header -background \#d4d0c8 -font boldFont \
	-relief raised -borderwidth 2
    pack $W.sb_y -side right -fill y
    pack $W.t -side left -fill both -expand 1

    $W.t tag config band0 -background $::Favorites::S(bandColor,0)
    $W.t tag config band1 -background $::Favorites::S(bandColor,1)
    $W.t tag config warning -foreground red -font bigBold
    $W.t insert end \tBearing\tDistance\tTime\n header
    $W.t config -state disabled
}
##+##########################################################################
#
# ::Tracks::SegmentsFill -- Fills in the track segments pane with the
# current track.
#
proc ::Tracks::SegmentsFill {} {
    set wt $::Tracks::Segs(wt)
    set trackId $::Tracks::trackNum

    $wt config -state normal
    $wt delete 1.0 end
    $wt insert end \tBearing\tDistance\tTime\n header
    if {! [info exists ::GPS::tracks($trackId,track)]} {
	$wt insert end "no track loaded" warning
	$wt config -state disabled
	return
    }

    array unset ::Tracks::Segs var,*

    set idx 0
    foreach {lat0 lon0 alt0 tim0} [lindex $::GPS::tracks($trackId,track) 0] break
    foreach wpt $::GPS::tracks($trackId,track) {
	foreach {lat lon alt tim} $wpt break
	set dxy [Round0 [::Data::Distance $lat0 $lon0 $lat $lon 1]]
	set dtim [expr {$tim - $tim0}]
	set bearing [::Data::Bearing $lat0 $lon0 $lat $lon]

	set lat0 $lat
	set lon0 $lon
	set alt0 $alt
	set tim0 $tim

	incr idx
	set odd [expr {$idx % 2}]
	$wt insert end [format %3d. $idx] band$odd

	set clr $::Favorites::S(bandColor,$odd)
	checkbutton $wt.w$idx -bg $clr -activebackground $clr \
	    -variable ::Tracks::Segs(var,$idx) \
	    -command [list ::Tracks::ToggleSegments $idx]
	$wt window create end -window $wt.w$idx
	$wt insert end "\t$bearing\t$dxy ft\t$dtim sec\n" band$odd
    }
    set ::Tracks::Segs(max) $idx
    ::Tracks::ToggleSegments on
    $wt config -state disabled
    return

    set col0 [winfo reqwidth $wt.w1]
    set col1 [font measure boldFont Bearing]
    set col2 [font measure boldFont Distance]
    set col3 [font measure boldFont Time]

    $wt config -tabs {50 center 160 center 280 center}
    set tab0 [expr {$col0 + $col1/2 - 5}]
    set tab1 [expr {$tab0 + $col1/2 + $col2/2 + 15}]
    set tab2 [expr {$tab1 + $col2/2 + $col3/2 + 15}]
    set tabs [list $tab0 center $tab1 center $tab2 center]
    $wt config -tabs $tabs
}
##+##########################################################################
#
# ::Tracks::ToggleSegments -- Handles toggling a segment
# checkbutton, inverting all buttons below it.
#
proc ::Tracks::ToggleSegments {idx} {
    variable Segs

    if {$idx eq "toggle"} {
	set idx [expr {$Segs(all) ? "on" : "off"}]
    }
    if {$idx eq "on" || $idx eq "off"} {
	set onoff [expr {$idx eq "on"}]
	for {set i 1} {$i <= $Segs(max)} {incr i} {
	    set Segs(var,$i) $onoff
	}
    } else {
	for {set i [incr idx]} {$i <= $Segs(max)} {incr i} {
	    set Segs(var,$i) [expr {1 - $Segs(var,$i)}]
	}
    }
    ::Tracks::DrawAllSegments
}
##+##########################################################################
#
# ::Tracks::DrawAllSegments -- Draws all ON segments of our track
#
proc ::Tracks::DrawAllSegments {} {
    variable Segs
    variable trackNum

    ::GPS::ClearTrack
    set cnt(on) [set cnt(off) 0]
    set _state NEEDLOW
    set Segs(first) ?
    set Segs(last) ?
    for {set i 1} {$i <= $Segs(max)} {incr i} {
	if {$Segs(var,$i)} { incr cnt(on) } else { incr cnt(off) }
	if {$Segs(var,$i)} {
	    if {$Segs(first) eq "?"} { set Segs(first) $i }
	    set Segs(last) $i
	}
	if {$_state eq "NEEDLOW" && $Segs(var,$i)} {
	    set low [expr {$i-1}]
	    set _state "NEEDHIGH"
	} elseif {$_state eq "NEEDHIGH" && ! $Segs(var,$i)} {
	    ::GPS::DrawTrack $trackNum $low [expr {$i-1}]
	    set _state "NEEDLOW"
	}
    }
    if {$_state eq "NEEDHIGH"} {
	::GPS::DrawTrack $trackNum $low $Segs(max)
    }

    set Segs(all) [expr {$cnt(off) == 0 ? 1 : 0}]
}
##+##########################################################################
#
# ::Tracks::GetFile -- asks for and loads in GPS file
#
proc ::Tracks::GetFile {W} {
    variable fname
    variable filetype

    set types {
	{{GPS Exchange} .gpx}
	{{TOPO! GPS Data Format} .txt}
	{{XML GIS Data} .xml}
	{{All Files} *}}

    set gfname [expr {$fname eq "<nothing loaded>" ? "" : $fname}]
    set initDir [expr {$fname eq "<nothing loaded>" ? $::state(zdir) : \
			   [file dirname $fname]}]
    set ext [file extension $gfname]
    if {$ext eq ""} {set ext ".gpx"}
    set n [tk_getOpenFile -title "$::state(progname) Browse for GPS file" \
	       -initialfile $gfname \
	       -initialdir $initDir \
	       -defaultextension $ext \
	       -parent $W \
	       -filetypes $types \
	       -typevariable ::Tracks::filetype]
    if {$n eq ""} return
    ::Tracks::LoadFile $W $n
}
##+##########################################################################
#
# ::Tracks::LoadFile -- loads in a given gps file
#
proc ::Tracks::LoadFile {W fname2} {
    variable fname ""
    variable trackNum
    variable trackCnt

    ::Tracks::ReState 0
    ::Tracks::Cleanup

    set fname $fname2
    set pbar [::Display::MakeProgressBar $W "Processing GPS file..."]
    after 10 ::GPS::ReadGPSTrack [list $fname]
    DoGrab $pbar $pbar

    ::Tracks::CleanupTracks			;# Get rid of empty tracks
    foreach {ready trackCnt} [::GPS::Status] break
    set trackNum 0
    ::Tracks::IsVisible
    ::Tracks::TrackSelector

    ::Tracks::ReState
    ::NodeList::Create

    if {$ready && $trackCnt == 0} {
	WARN "The GPS file contains no tracks"
	return
    }
    ::GPS::ClearTrack
    ::GPS::DrawTrack $::Tracks::trackNum
}
##+##########################################################################
#
# ::Tracks::IsVisible -- test if start of track is visible
#
proc ::Tracks::IsVisible {} {
    variable trackNum
    variable trackCnt
    variable isVisible 0

    if {$trackCnt == 0} return
    set cnt 0
    foreach trkpt $::GPS::tracks($trackNum,track) {
	incr cnt
	lassign $trkpt lat lon
	if {[::Display::ClipNode $lat $lon]} {
	    set isVisible $cnt
	    return
	}
    }
    WARN "This track is outside the current region."
}
##+##########################################################################
#
# ::Tracks::ReState -- toggles -state normal/disabled of dialog widgets
#
proc ::Tracks::ReState {{forceOff 0}} {
    variable fname
    variable ttime "?"
    variable tdate "?"
    variable name "?"
    variable distance "?"
    variable legs "?"
    variable climbs "?"
    variable descends "?"
    variable waypoints "?"
    variable hillData ""
    variable trackNum
    variable trackCnt 0
    variable isVisible

    foreach {. tcnt . wcnt .} [::GPS::Status] break
    if {[file exist $fname] && $tcnt > 0 && ! $forceOff} {
	set s normal

	set trackCnt $tcnt
	if {$trackNum >= $trackCnt} {set trackNum 0}

	foreach {distance climbs descends legs} \
	    $::GPS::tracks($trackNum,stats) break
	set distance [::Data::Units [Round1 $distance] dist 3 2]
	set climbs [::Data::Units [Round10 $climbs] climb 1 0]
	set descends [::Data::Units [Round10 $descends] climb 1 0]
	set legs [comma $legs]

	set waypoints $::GPS::wpts(wcnt)
	if {$::GPS::tracks(tdate) != 0 && $::GPS::tracks(tdate) ne ""} {
	    set tdate [clock format $::GPS::tracks(tdate) -gmt 1 \
			   -format "%b %d, %Y %I:%M %p"]
	}
	set name $::GPS::tracks($trackNum,name)
	if {$name eq "ACTIVE LOG"} {set name ""}

	set start [lindex $::GPS::tracks($trackNum,track) 0 3]
	set end [lindex $::GPS::tracks($trackNum,track) end 3]
	catch {
	    set ttime [::Data::TimeFormat [expr {($end - $start) / 60.0}] 1]
	}
	::Tracks::GetHillData
	::Tracks::SegmentsFill
    } else {
	set s disabled
    }

    # Display update
    if {! [winfo exists .gps]} return
    ::Tracks::Disable $s
    if {$wcnt == 0} { .gps.wpt config -state disabled}
    if {$tcnt < 2} { .gps.select.m config -state disabled}
    if {! $isVisible} {
	.gps.track config -state disabled
	.gps.wpt config -state disabled
    }
}
##+##########################################################################
#
# ::Tracks::GetInfo -- returns name, distance, climb and desc for a track
#
proc ::Tracks::GetInfo {{who {}}} {
    variable name
    variable distance
    variable climbs
    variable descends
    variable trackNum

    if {$who eq {}} {set who $trackNum}
    set tname "Track [expr {$who + 1}]"
    if {$trackNum != $who} {
	return [list $tname "?" "?" "?"]
    }

    if {$name ne ""} {set tname $name}
    return [list $tname $distance $climbs $descends]
}
##+##########################################################################
#
# ::Tracks::Disable -- toggles -state for all but some widgets in .gps
#
proc ::Tracks::Disable {how} {
    set omit {.gps .gps.icon .gps.title .gps.ftitle .gps.buttons .gps.body
	.gps.ffile .gps.ename .gps.bname .gps.show .gps.hill
	.gps.buttons.clear .gps.buttons.dismiss .gps.show.labels
	.gps.show.buttons .gps.hill.f .gps.hill.sb
	.gps.select .gps.select.m.menu .gps.segs.t
    }

    set stack .gps
    while {[llength $stack] > 0} {
	set who [lindex $stack 0]
	set stack [concat [lrange $stack 1 end] [winfo child $who]]
	if {[lsearch $omit $who] != -1} continue
	if {! [winfo exists $who]} continue
	catch {$who config -state $how}
    }
    if {$how eq "normal" && ! [::Data::CanDo 3d]} {
	.gps.3dprofile config -state disabled
    }
}
##+##########################################################################
#
# ::Tracks::DoIt -- handle button actions
#
proc ::Tracks::DoIt {what args} {
    variable trackNum
    if {$what eq "track"} {
	after 1 {::GPS::DrawTrack $::Tracks::trackNum}
    } elseif {$what eq "profile"} {
	after 1 {::Profile::Profile $::Tracks::trackNum}
    } elseif {$what eq "3dprofile"} {
	::3D::RunGnuplot track $::Tracks::trackNum
	if {! [::Data::CanDo 3d]} {.gps.3dprofile config -state disabled}
    } elseif {$what eq "wpt"} {
	::GPS::DrawWpts w 1 $::state(su)
	::NodeList::Create
    } elseif {$what eq "google"} {
	::Google::GoGoogleMaps $trackNum
    } elseif {$what eq "zoom"} {
	::Zoom::Go track $trackNum
    }
}
##+##########################################################################
#
# ::Tracks::Cleanup -- cleans up and possibly exits dialog
#
proc ::Tracks::Cleanup {} {
    .c delete trk hill wpt
    ::NodeList::Create
}
##+##########################################################################
#
# ::Tracks::GetHillData -- fills in listbox of all the hills based off
#  height and slope specs
#
proc ::Tracks::GetHillData {} {
    variable hillData ""
    variable height
    variable height_external
    variable slope
    variable trackNum

    if {! [string is double -strict $height_external]} {
	set height_external ""
	return
    }
    if {! [string is double -strict $slope]} {
	set slope ""
	return
    }
    set height [Round10 [::Data::RConvert $height_external climb]]
    set hills [::Hills::GetAndDrawAllHills $trackNum $height $slope]

    foreach hill $hills {
	foreach {id low high delta dist sslope} $hill break
	set how [expr {$low <= $high ? "climbs" : "descends"}]
	set delta [::Data::Units $delta climb 1 2]
	set dist [::Data::Units [Round2 $dist] dist 3 2]

	set line "\#$id: $how $delta in $dist ($sslope%)"
	lappend hillData $line
    }
}
##+##########################################################################
#
# ::Tracks::HillSelect -- Moves highlight to specified hill
#
proc ::Tracks::HillSelect {W} {
    variable activeHill

    ::Hills::HighlightHill $activeHill 0
    set sel [$W curselection]
    if {$sel eq ""} return
    set activeHill [$W get $sel]
    regexp {\#(\d+)} $activeHill => activeHill
    ::Hills::HighlightHill $activeHill 1
}
##+##########################################################################
#
# ::Tracks::TrackSelector -- creates and/or updates tk_optionMenu
# which selects tracks
#
proc ::Tracks::TrackSelector {} {
    variable trackCnt
    variable trackNum
    variable trackSelect

    set w .gps.select
    if {! [winfo exists $w]} { ::tk::frame $w }	;# Holds our option menu

    set args [list "Track 1"]
    for {set i 2} {$i <= $trackCnt} {incr i} {lappend args "Track $i"}

    destroy $w.m
    eval tk_optionMenu $w.m ::Tracks::trackSelect $args
    set trackSelect "Track [expr {$trackNum + 1}]"
    $w.m config -highlightthickness 0
    pack $w.m -fill both -expand 1

    set cnt -1
    foreach _ $args {
	incr cnt
	$w.m.menu entryconfig $cnt \
	    -command [list ::Tracks::SelectTrack $cnt]
    }
}
##+##########################################################################
#
# ::Tracks::SelectTrack -- called when track selection changes
#
proc ::Tracks::SelectTrack {tnum} {
    variable trackNum

    if {$tnum == $trackNum} return		;# Nothing's changed
    set trackNum $tnum
    ::Tracks::IsVisible
    ::Tracks::ReState
    ::Tracks::DoIt track
}
##+##########################################################################
#
# ::Tracks::CleanupTracks -- removes 0 length tracks & get distance and legs
#
proc ::Tracks::CleanupTracks {} {
    foreach {. tcnt} [::GPS::Status] break

    set idx 0					;# Index into good tracks
    for {set i 0} {$i < $tcnt} {incr i} {
	foreach {xy dist} [::GPS::GetTrackXY $i,track] break
	if {$dist == 0} {
	    unset ::GPS::tracks($i,track)
	    continue
	}
	if {$i > $idx} {
	    set ::GPS::tracks($idx,track) $::GPS::tracks($i,track)
	    unset ::GPS::tracks($i,track)
	}
	set legs [expr {[llength [lrange $xy 2 end]] / 2}]
	set ::GPS::tracks($idx,stats) [list $dist ? ? $legs]
	::Hills::GrindTrack $idx

	incr idx
    }
    set ::GPS::tracks(tcnt) $idx
}
##+##########################################################################
#
# ::Tracks::MakeRoadDialog -- Creates sub-dialog to create a road from a track
#
proc ::Tracks::MakeRoadDialog {placeMaster} {
    variable Segs

    set f "[winfo toplevel $placeMaster].f"
    destroy $f
    frame $f -borderwidth 2 -relief solid -padx .07i -pady .07i
    ::ttk::label $f.n -text "Road Name"
    ::ttk::entry $f.ne -textvariable ::Tracks::Segs(road,name) \
	-justify center
    ::ttk::label $f.s -text "Start Node"
    ::ttk::entry $f.se -textvariable ::Tracks::Segs(road,first) -width 5 \
	-justify center
    ::ttk::button $f.sb -image ::img::star -command {::Tracks::NearestNode first}
    ::ttk::label $f.e -text "End Node"
    ::ttk::entry $f.ee -textvariable ::Tracks::Segs(road,last) -width 5 \
	-justify center
    ::ttk::button $f.eb -image ::img::star -command {::Tracks::NearestNode last}
    frame $f.buttons
    ::ttk::button $f.buttons.road -text "Create" \
	-command [list Tracks::CreateRoad $f]
    ::ttk::button $f.buttons.cancel -text "Cancel" -command  [list destroy $f]

    grid $f.n $f.ne -
    grid $f.s $f.se $f.sb -sticky w
    grid $f.e $f.ee $f.eb -sticky w
    grid $f.buttons - - -sticky ew
    grid columnconfigure $f 2 -weight 1
    eval pack [winfo child $f.buttons] -side left -expand 1 -pady {{10 0}}

    place $f -in $placeMaster -relx .5 -y 0 -anchor s -bordermode outside
    ::Tracks::NearestNode first
    ::Tracks::NearestNode last
    set Segs(road,name) "My new GPS road"
}
##+##########################################################################
#
# ::Tracks::NearestNode -- Finds node nearest either end of a track
#
proc ::Tracks::NearestNode {which} {
    set trackId $::Tracks::trackNum
    set ::Tracks::Segs(road,$which) ?
    if {! [string is integer -strict $::Tracks::Segs($which)]} return

    set idx [expr {$::Tracks::Segs($which) - 1}]
    lassign [lindex $::GPS::tracks($trackId,track) $idx] lat lon
    if {! [string is double -strict $lat] || ! [string is double -strict $lon]} \
	return
    lassign [::Data::NearestNode $lat $lon] nid dist
    if {$dist < 1000} {
	set ::Tracks::Segs(road,$which) [::Edit::PrettyNode $nid]
    }
}
##+##########################################################################
#
# ::Tracks::CreateRoad -- Creates new road from selected GPS track segments
#
proc ::Tracks::CreateRoad {f} {
    variable Segs
    global rid

    set trackId $::Tracks::trackNum
    destroy $f
    if {$Segs(first) eq "?"} return
    foreach which {first last} {
	set nid [::Edit::FindNode $Segs(road,$which)]
	if {$nid ne ""} {
	    set Segs(road,$which) $nid
	} else {
	    set idx [expr {$Segs(first) - 1}]
	    lassign [lindex $::GPS::tracks($trackId,track) $idx] lat lon alt
	    set nid [::Edit::GetNextID n]
	    set ndata [list "Track $which" ? $lat 0 0 $lon 0 0]
	    ::Edit::AddNode2 $nid $ndata
	    set Segs(road,$which) $nid
	    incr Segs(road,$which) [expr {$which eq "first" ? 1 : -1}]
	}
    }
    set rid [::Edit::GetNextID r]
    set xyz [::Tracks::GetSegmentXYZ]
    set rdata [list $Segs(road,first) $Segs(road,last) ? ? ? 4 $Segs(road,name) \
		   "" $xyz]
    ::Edit::AddRoad2 $rid $rdata
}
##+##########################################################################
#
# ::Tracks::GetSegmentXYZ -- Turns track info into format for AddRoad2
#
proc ::Tracks::GetSegmentXYZ {} {
    variable Segs

    if {$Segs(first) eq "?"} { return {}}

    set trackId $::Tracks::trackNum
    set xyz {xyz}
    for {set i $Segs(first)} {$i <= $Segs(last)} {incr i} {
	if {! $Segs(var,$i)} continue
	lassign [lindex $::GPS::tracks($trackId,track) [expr {$i-1}]] lat lon alt
	lappend xyz $lat 0 0 $lon 0 0 ?
    }
    return $xyz
}
## EON TRACKS
## BON HILLS
##+##########################################################################
#
# ::Hills::Dialog -- Puts up the hills dialog. We should combine
# this code with the similar one in Tracks.
#
proc ::Hills::Dialog {} {
    variable Hills

    set Hills(height,external) [::Data::Convert $Hills(height) climb]
    ::Hills::GetHillData

    set W .hills
    set WB $W.body
    set WBTN $W.buttons
    set F1 $WB.f1
    set F2 $WB.f2
    set F3 $WB.f3
    set title "$::state(progname) Hills Dialog"
    ::Display::MakeDialogBox $W $title $title [list ::img::hills hills.gif] 5
    wm protocol $W WM_DELETE_WINDOW [list ::Hills::Cleanup $W]

    ::ttk::button $WBTN.help -text "Help" -command {::Help::Help "Hills Dialog"}
    ::ttk::button $WBTN.dismiss -text "Close" -command [list ::Hills::Cleanup $W]
    ::Display::GridChildren $WBTN 1

    set F1 $WB.f1
    ::my::frame $F1
    if {1} {
	set headers {Id Which Size Distance Gradient}
	set Hills(tree) [::TileTable::Create $F1 $headers $Hills(table)]
	::TileTable::SortBy $F1.tree Id 0
	bind $Hills(tree) <<TreeviewSelect>> ::Hills::TreeSelection
    } else {
	::ttk::scrollbar $F1.sb -orient v -command [list $F1.lb yview]
	listbox $F1.lb -height 9 -width 45 \
	    -exportselection 0 -highlightthickness 0 \
	    -listvariable ::Hills::Hills(data) -yscroll [list $F1.sb set]
	#::Display::TileBGFix $F1.lb
	bind $F1.lb <<ListboxSelect>> {::Hills::HillSelect %W}
	grid $F1.lb $F1.sb -sticky news -pady {0 5}
	grid columnconfigure $F1 0 -weight 1
	grid rowconfigure $F1 0 -weight 1
    }

    set F2 $WB.f2
    ::my::frame $F2

    ::my::label $F2.flbl -text "Only hills taller than"
    ::my::entry $F2.hheight -textvariable ::Hills::Hills(height,external) \
	-width 5 -validate key -validatecommand {string is double %P} \
	-justify center
    set units [::Data::Label 0 climb 0]
    regsub {^[0-9]+ +} $units {} units
    ::my::label $F2.hunits -text "$units and steeper than"

    ::my::entry $F2.eslope -textvariable ::Hills::Hills(slope) -width 3 \
	-validate key -validatecommand {string is double %P} -justify center
    ::my::label $F2.lslope2 -text "%"

    ::ttk::button $WB.filter -text "Apply Filter" -command ::Hills::NewHillData
    grid $F2.flbl $F2.hheight $F2.hunits $F2.eslope $F2.lslope2 -sticky ew

    grid $F1 - -sticky news
    grid $F2 - -sticky n
    grid $WB.filter -pady 5
    grid columnconfigure $WB {0 1} -weight 1
    grid rowconfigure $WB 0 -weight 1

    ::Display::RightWindow $W
    wm deiconify $W
    wm resizable $W 1 1
}
##+##########################################################################
#
# ::Hills::Cleanup -- Deletes hills dialog and cleans up the display
#
proc ::Hills::Cleanup {W} {
    .c delete trk hill wpt
    if {[winfo exists .pro.c]} { .pro.c delete hill }
    ::NodeList::Create
    destroy $W
}
##+##########################################################################
#
# ::Hills::NewHillData -- Inserts new hill data into our table
#
proc ::Hills::NewHillData {} {
    variable Hills
    set tree $Hills(tree)
    set headers {Id Which Size Distance Gradient}
    ::Hills::GetHillData
    ::TileTable::InsertData $tree $Hills(table) $headers
}
##+##########################################################################
#
# ::Hills::GetHillData -- Gets all the hills and updates the listbox
#
proc ::Hills::GetHillData {} {
    variable Hills

    if {$Hills(height,external) eq ""} {set Hills(height,external) 0}
    if {$Hills(slope) eq ""} {set Hills(slope) 0}

    ::Hills::GrindTrack route			;# Put route into GPS track
    set Hills(height) [Round10 [::Data::RConvert $Hills(height,external) climb]]
    set hills [::Hills::GetAndDrawAllHills route $Hills(height) $Hills(slope)]

    set Hills(data) ""
    set Hills(table) {}
    foreach hill $hills {
	foreach {id low high delta dist sslope} $hill break
	set how [expr {$low <= $high ? "climbs" : "descends"}]
	set how2 [string totitle $how]
	set delta [::Data::Units $delta climb 1 2]
	set dist [::Data::Units [Round2 $dist] dist 3 2]

	set line " \#$id: $how $delta in $dist ($sslope%)"
	lappend Hills(data) $line
	lappend Hills(table) [list #$id $how2 $delta $dist $sslope%]
    }
    if {$Hills(data) eq ""} {
	set Hills(data) {"no matches"}
	set Hills(table) [list [list "no matches"]]
    }
}
##+##########################################################################
#
# ::Hills::HillSelect -- handles clicking in the hills listbox
#
proc ::Hills::HillSelect {W} {
    variable Hills

    ::Hills::HighlightHill $Hills(activeHill) 0
    set sel [$W curselection]
    if {$sel eq ""} return
    set Hills(activeHill) [$W get $sel]
    if {[regexp {\#(\d+)} $Hills(activeHill) => Hills(activeHill)]} {
	::Hills::HighlightHill $Hills(activeHill) 1
    }
}
##+##########################################################################
#
# ::Hills::TreeSelect -- handles clicking in the hills table
#
proc ::Hills::TreeSelection {} {
    variable Hills

    ::Hills::HighlightHill $Hills(activeHill) 0

    set id [$Hills(tree) selection]
    if {$id eq ""} return
    set Hills(activeHill) [lindex [$Hills(tree) item $id -values] 0]
    if {[regexp {\#(\d+)} $Hills(activeHill) => Hills(activeHill)]} {
	::Hills::HighlightHill $Hills(activeHill) 1
    }
    set tag [$Hills(tree) item $id -tag]
    ::TileTable::BandTable $Hills(tree); ;# Unmark previous selected
    $Hills(tree) tag configure $tag -background magenta
}
##+##########################################################################
#
# ::Hills::GetAndDrawAllHills -- draws all hills over given height
#
proc ::Hills::GetAndDrawAllHills {tnum height slope} {
    variable Hills
    .c delete hill
    if {[winfo exists .pro.c]} { .pro.c delete hill }

    ::Hills::FindHills $tnum $height $slope

    foreach hill $Hills(hills) {
	foreach {id start end delta dist sslope sDist} $hill break
	set tag "hill$id"
	::Hills::DrawOneHill $tnum $tag $start $end
	::Hills::DrawOneHillProfile $tnum $tag $start $end

	set dist [::Data::Units [Round2 $dist] dist 3 2]
	set delta [::Data::Units $delta climb 1 2]
	set txt "Hill \#$id: $delta in $dist ($sslope%)"

	::Balloon::Create [list .c $tag] hill $tag $txt $txt
	::Balloon::Create [list .pro.c $tag] hill $tag $txt $txt
    }
    return $Hills(hills)
}
##+##########################################################################
#
# ::Hills::DoOneHill -- draws one hill identified by its id
#
proc ::Hills::DoOneHill {id tag} {
    variable Hills

    set tnum route
    foreach hill $Hills(hills) {
	foreach {id2 start end delta dist sslope sDist} $hill break
	if {$id == $id2} {
	    ::Hills::DrawOneHill $tnum $tag $start $end
	    ::Hills::DrawOneHillProfile $tnum $tag $start $end
	    break
	}
    }
}
##+##########################################################################
#
# ::Hills::DrawOneHill -- draws one hill given start and end index
#
proc ::Hills::DrawOneHill {tnum tag start end} {
    global state

    foreach {xy dist} [::GPS::GetTrackXY $tnum,track $start $end] break
    set uphill [expr {$start <= $end ? 1 : 0}]

    if {[llength $xy] > 2} {
	set color [expr {$uphill ? $state(trk,climb) : $state(trk,descent)}]
	.c create line $xy -tag [list hill $tag bg_$tag] -width 9 \
	    -arrow last -arrowshape {16 20 10}
	.c create line $xy -tag [list hill $tag] -width 3 -fill $color \
	    -arrow last -arrowshape {13 15 6}
    }

    ::Display::Raise
}
proc ::Hills::DrawOneHillProfile {tnum tag start end} {
    global state
    if {! [winfo exists .pro.c]} return

    set clr $state(trk,climb)
    if {$start > $end} {
	set clr $state(trk,descent)
	foreach {start end} [list $end $start] break
    }
    set xy [::Profile::GetEdge $start $end]
    if {$xy eq ""} return

    .pro.c delete $tag
    .pro.c create poly $xy -tag [list hill $tag] -fill $clr -outline {} \
	-stipple gray50
}
##+##########################################################################
#
# ::Hills::HightlightHill -- emphasizes a given hill
#
proc ::Hills::HighlightHill {who onoff} {
    variable Hills
    global state

    set tag hill$who
    if {$onoff} {
	::Hills::SeeHill $tag
	set color magenta ;# white
	set width 11
	set proColor $color
	set proWidth 5
    } else {
	set color black
	set width 9
	set proColor {}
	set proWidth 0
    }
    .c itemconfig bg_hill$who -fill $color -width $width
    .c raise $tag
    catch {.c raise nodes hill}
    if {[winfo exists .pro.c]} {
	.pro.c itemconfig $tag -outline $proColor -width $proWidth
    }

    if {! $onoff} {
	::Profile::GPSSection $onoff 0 0 ""
    } else {
	foreach {. start end} [lindex $Hills(hills) [expr {$who - 1}]] break
	set col [expr {$start<=$end ? $state(trk,climb) : $state(trk,descent)}]
	::Profile::GPSSection $onoff $start $end $col
    }
}
##+##########################################################################
#
# ::Hills::SeeHill -- makes sure we can view this hill
#
proc ::Hills::SeeHill {tag} {
    ::Display::ToCenter [lrange [.c coords $tag] 0 1]
    ::Display::ToCenter [lrange [.c coords $tag] end-1 end]
}
##+##########################################################################
#
# ::Hills::FindHills -- returns list of all hills over given height
#   each hill => {lowIdx highIdx climb distance slope}
#
proc ::Hills::FindHills {tnum height slope} {
    variable Hills

    set result {}
    set idx 0					;# Index into track points
    set id 1					;# Index into hills found
    set tid $tnum,track

    foreach datum $::GPS::tracks($tnum,compress) {
	set lidx $idx				;# Last index
	set climb [lindex $datum 4]
	set idx [lindex $datum 5]

	if {$climb < $height && $climb > -$height} continue

	if {$climb >= $height} {
	    set dist [Round2 [lindex [::GPS::GetTrackXY $tid $lidx $idx] 1]]
	    set hill [list $id $lidx $idx $climb $dist]
	} elseif {$climb <= -$height} {
	    set dist [Round2 [lindex [::GPS::GetTrackXY $tid $idx $lidx] 1]]
	    set hill [list $id $idx $lidx [expr {-$climb}] $dist]
	}
	if {$dist == 0} {
	    #puts "0 distance: $lidx $idx"
	    #set sslope 100
	    continue
	} elseif {$::state(units,internal) eq "english"} {
	    set sslope [Round1 [expr {abs($climb) / 52.80 / $dist}]]
	} else {
	    set sslope [Round1 [expr {abs($climb) / 10.0 / $dist}]]
	}
	if {$sslope < $slope} continue		;# Too shallow, skip

	lappend hill $sslope
	incr id
	lappend result $hill
    }
    set Hills(hills) $result
}
##+##########################################################################
#
# ::Hills::GrindTrack -- massages track data into its hills
#
proc ::Hills::GrindTrack {tnum} {
    if {$tnum eq "route"} {
	set ::GPS::tracks($tnum,track) [::Hills::_Route2Track]
    }
    set data [::Hills::_GetAlts $::GPS::tracks($tnum,track)]
    set ::GPS::tracks($tnum,compress) [::Hills::_CompressClimbs $data]

    set climbing 0
    set descending 0

    foreach datum $::GPS::tracks($tnum,compress) {
	set climb [lindex $datum 4]
	if {$climb > 0} {
	    set climbing [expr {$climbing + $climb}]
	} else {
	    set descending [expr {$descending - $climb}]
	}
    }
    lset ::GPS::tracks($tnum,stats) 1 $climbing
    lset ::GPS::tracks($tnum,stats) 2 $descending
}
##+##########################################################################
#
# ::Hills::_Route2Track -- converts route info into track format
#
proc ::Hills::_Route2Track {} {
    set xyz [::Route::GetXYZ]

    set data {}
    foreach item $xyz {
	foreach {. . lat lon . . . alt} $item break
	if {! [string is double -strict $alt]} continue
	lappend data [list $lat $lon $alt 0]
    }
    set ::GPS::tracks(route,stats) [list 0 0 0 0]
    return $data
}
##+##########################################################################
#
# ::Hills::_GetAlts -- massages track data into alternating up/down legs
#
proc ::Hills::_GetAlts {data} {
    # Data enters as {lat lon alt time}
    # Data leaves in {lat lat alt time delta index}

    # First convert absolute metric altitudes into delta
    if {$data eq ""} { set data {{ . . 0 . }}}
    set deltas [list [concat [lindex $data 0] 0 0]]
    set index -1
    set last [lindex $data 0 2]			;# Start height
    foreach datum $data {
	incr index
	set alt [lindex $datum 2]
	set d [expr {$alt - $last}]
	if {$d != 0} {
	    lappend deltas [concat $datum $d $index]
	    set last $alt
	}
    }

    # Next, combine consecutive climbs or descends into one item
    set last 0
    set ldatum [lindex $deltas 0]
    set result {}

    foreach datum [concat $deltas [list {0 0 0 0 0 99999}]] {
	set d [lindex $datum 4]
	if {($d < 0 && $last < 0) || ($d > 0 && $last > 0)} {
	    set last [expr {$last + $d}]
	} else {
	    lappend result [lreplace $ldatum 4 4 $last]
	    set last $d
	}
	set ldatum $datum
    }
    set result [lrange $result 1 end]
    return $result
}
##+##########################################################################
#
# CompressClimbs -- given a list of alternating climb and descents this
# removes all small bumps less than a certain threshold. The algorithm
# is by Dan Connelly.
#
# First examine triplets: if middle less than LIMIT and less than the
# other two then we combine the three into 1. Second, if the first two
# items are less than LIMIT then combine them (with two special cases
# of the new item equally 0 or being the same sign as the next item).
# Third, repeat second step for the end of the list.

proc ::Hills::_CompressClimbs {data} {
    variable LIMIT
    set deltas [lrange $data 1 end]

    # Examine triplets, combining if middle if necessary
    for {set n 2} {$n < [llength $deltas]} {} {
	set n-1 [expr {$n - 1}]
	set n-2 [expr {$n - 2}]
	set first [lindex $deltas ${n-2} 4]
	set mid [lindex $deltas ${n-1} 4]
	set amid [expr {abs($mid)}]
	set last [lindex $deltas $n 4]

	if {$amid < $LIMIT && $amid <= abs($first) && $amid <= abs($last)} {
	    set new [expr {$first + $mid + $last}]
	    lset deltas $n 4 $new
	    set deltas [lreplace $deltas ${n-2} ${n-1}]
	    set n [expr {${n-2} < 2 ? 2 : ${n-2}}]
	} else {
	    incr n
	}
    }

    # Now do head cancellation
    while {[llength $deltas] > 1} {
	set first [lindex $deltas 0 4]
	set second [lindex $deltas 1 4]
	if {abs($first) >= $LIMIT || abs($second) >= $LIMIT} break
	set new [expr {$first + $second}]
	if {$new == 0} {
	    set deltas [lrange $deltas 2 end]
	} else {
	    set n 1
	    set third [lindex $deltas 2 4]
	    if {$third ne {} \
		    && ($new < 0 && $third < 0) || ($new > 0 && $third > 0)} {
		set new [expr {$new + $third}]
		set n 2
	    }
	    set deltas [lrange $deltas $n end]
	    lset deltas 0 4 $new
	}
    }

    # Now do tail cancellation
    while {[llength $deltas] > 1} {
	set first [lindex $deltas end 4]
	set second [lindex $deltas end-1 4]
	if {abs($first) >= $LIMIT || abs($second) >= $LIMIT} break
	set new [expr {$first + $second}]
	if {$new == 0} {
	    set deltas [lrange $deltas 0 end-2]
	} else {
	    set n 1
	    set third [lindex $deltas end-2 4]
	    if {$third ne {} \
		    && ($new < 0 && $third < 0) || ($new > 0 && $third > 0)} {
		set new [expr {$new + $third}]
		set n 2
	    }
	    set deltas [lrange $deltas 0 end-$n]
	    lset deltas end 4 $new
	}
    }
    set deltas [concat [list [lindex $data 0]] $deltas]
    return $deltas
}
## EON HILLS
## BON XML
##+##########################################################################
#
# ::XML::Init -- initialize XML parser, returns true if okay XML
#   file <fname>  | data <data> | reset
#
proc ::XML::Init {what {param ""}} {
    variable XML
    variable loc
    variable valid
    variable length
    variable tdom

    if {$tdom(exists) == -1} {
	set tdom(exists) [expr {! [catch {package require tdom}]}]
    }

    set valid 0
    if {$what eq "file"} {
	set n [catch {set fin [open $param r]}]
	if {$n} {return 0}
	set XML [read $fin]
	close $fin
    } elseif {$what eq "data"} {
	set XML $param
    } elseif {$what eq "reset"} {
	array unset tdom(myDom)
    } else {
	return 0
    }

    if {$tdom(exists)} {
	dom setStoreLineColumn 1
	array unset tdom(myDom)			;# Clean up last dom tree
	set tdom(tree) {}

	set n [catch {set tdom(doc) [dom parse $XML tdom(myDom)]}]
	if {! $n} {
	    set tdom(root) [$tdom(doc) documentElement]
	    ::XML::TreePush {} 4
	    ::XML::TreePush $tdom(root) 0
	    set length [[$tdom(root) lastChild] getLine]
	    set valid 1
	}
    } else {
	set XML [string trim $XML];
	regsub -all {<!--.*?-->} $XML {} XML	;# Remove all comments
	set loc 0
	set valid [expr {[string range $XML 0 0] eq "<"}]
	set length [string length $XML]
    }
    return $valid
}
proc ::XML::Test {} {
    global allXML
    set allXML {}
    ::XML::Init reset
    while {1} {
	foreach {type val} [::XML::NextToken] break
	lappend allXML [list $type $val]
	if {$type eq "EOF"} break
    }
}
##+##########################################################################
#
# ::XML::DocType -- returns the type of XML document loaded in ::XML::Init
#
proc ::XML::DocType {} {
    variable loc; variable valid; variable tdom
    if {! $valid} {return ""}

    if {$tdom(exists)} {
	return [$tdom(root) nodeName]
    }

    foreach {old loc} [list $loc 0] break
    while {1} {
	foreach {type val attr} [::XML::NextToken] break
	if {$type ne "ELEMENT_NODE"} continue
	if {$val eq "?xml"} continue
	break
    }
    set loc $old
    return $val
}
##+##########################################################################
#
# ::XML::NextToken -- parses out the next token from the XML data
#
proc ::XML::NextToken {} {
    set func ::XML::NextToken_tcl
    if {$::XML::tdom(exists)} {
	set func ::XML::NextToken_tdom
    }
    return [$func]
}
proc ::XML::NextToken_tcl {} {
    variable XML; variable loc; variable valid

    if {! $valid} {return [list EOF "" ""]}
    set n [regexp -start $loc -indices {(.*?)\s*?<(.*?)/?>} $XML all txt tok]
    if {! $n} {return [list EOF "" ""]}
    foreach {all0 all1} $all {txt0 txt1} $txt {tok0 tok1} $tok break

    if {$txt1 >= $txt0} {			;# Got text
	set txt [string range $XML $txt0 $txt1]
	set loc [expr {$txt1 + 1}]
	return [list "TEXT_NODE" $txt ""]
    }

    set token [string range $XML $tok0 $tok1]	;# Got something in brackets
    set loc [expr {$all1 + 1}]
    if {[regexp {^!\[CDATA\[(.*)\]\]} $token => txt]} {	;# Is it CDATA stuff?
	return [list "TEXT_NODE" $txt ""]
    }
    set attr ""
    regexp {^(.*?)\s+(.*?)$} $token => token attr
    return [list "ELEMENT_NODE" $token $attr]
}

proc ::XML::NextToken_tdom {} {
    variable tdom

    foreach {node done} [::XML::NextNode] break

    if {$node eq {}} {
	foreach {type val node} {EOF "" ""} break
    } else {
	set type [$node nodeType]
	if {$type eq "ELEMENT_NODE"} {
	    set val [$node nodeName]
	    if {$done} {set val "/$val"}
	} else {
	    if {$done} {
		return [::XML::NextToken_tdom]
		set val "NIL"
	    } else {
		set val [$node data]
	    }
	}
    }
    return [list $type $val $node]
}
# State: 0 print this node
#        1 walk children
#        2 print this end node
#        3 next sibling
proc ::XML::NextNode {} {
    while {1} {
	set nodeX [::XML::TreePop]
	if {$nodeX eq {}} { return [list {} 0]}
	foreach {node _state} $nodeX break

	if {$_state == 0} {			;# Unvisited
	    ::XML::TreePush $node 1
	    return [list $node 0]
	}
	if {$_state == 1} {			;# Need to walk children
	    set next [$node firstChild]
	    if {$next ne {}} {
		::XML::TreePush $node 2
		::XML::TreePush $next 1
		return [list $next 0]
	    }

	    ::XML::TreePush $node 3
	    return [list $node 1]
	}

	if {$_state == 2} {
	    ::XML::TreePush $node 3
	    return [list $node 1]
	}
	if {$_state == 3} {
	    set next [$node nextSibling]
	    if {$next ne {}} {
		::XML::TreePush $next 1
		return [list $next 0]
	    }
	}

    }
}
proc ::XML::TreePush {node _state} {
    lappend ::XML::tdom(tree) [list $node $_state]
}
proc ::XML::TreePop {} {
    set val [lindex $::XML::tdom(tree) end]
    set ::XML::tdom(tree) [lrange $::XML::tdom(tree) 0 end-1]
    return $val
}
##+##########################################################################
#
# ::XML::Progress -- returns info useful for progress bar
#
proc ::XML::Progress {} {
    variable loc; variable valid; variable length; variable tdom

    if {! $valid} {return [list 0 0 0]}
    if {$tdom(exists)} {
	set loc [[lindex $tdom(tree) end 0] getLine]
    }
    return [list $loc $length]
}

proc ::XML::GetAttribute {attr which} {
    if {$::XML::tdom(exists)} {
	set val [$attr getAttribute $which]
    } else {
	set val ""
	set re "\\m$which=\x22(.*?)\x22"
	regexp $re $attr => val
    }
    return $val
}
##+##########################################################################
#
# ::XML::Indent -- fixes up indentation for simple XML
#
proc ::XML::Indent {xml} {
    # Assumes one element per line

    set lvl 0
    set result ""
    foreach line [split $xml "\n"] {
	set line [string trim $line]
	if {$line eq ""} continue

	if {[string match "</*" $line]} {
	    incr lvl -2
	    append result [string repeat " " $lvl] $line "\n"
	} else {
	    append result [string repeat " " $lvl] $line "\n"
	    if {! [string match "<*" $line]} continue
	    if {! [regexp {/>|</} $line]} {
		incr lvl 2
	    }
	}
    }
    return $result
}
## EON XML
## BON ZOOM
##+##########################################################################
#
# ::Zoom::Go -- zooms given road id
#
proc ::Zoom::Go {what who} {
    variable ZMAP

    ::Zoom::Init
    if {! $::state(zoom,canDo)} return

    set what [string tolower $what]
    if {$what eq "popup"} {
	set what $::state(popup,what)
	set who $::state(popup,who)
	if {$what eq "map"} {
	    set what "coords"
	    set who "map"
	}
    }
    set n [lsearch -exact {road node poi geo route track coords} $what]
    if {$n == -1} return

    set ZMAP(what) $what
    set ZMAP(who) $who
    set ZMAP(readonly) [expr {!$::state(su) && [string range $who 0 0] ne "X"}]
    set ZMAP(guessable) [expr {$::state(su) || ($what eq "road" \
				    && [string match "X*" $who])}]

    ::Zoom::DoDisplay
    ::Zoom::GetDetails $what $who
    set ::Zoom::DS(title) $::Zoom::RINFO(title)
    ::Zoom::MakeMap
    ::Data::UniqueTrace ::Zoom::RINFO {::Zoom::IsModified 1}
    ::Atlas::Reparent
}
##+##########################################################################
#
# ::Zoom::Init -- loads everything needed by the zoom feature
#   http://terraserver-usa.com/about.aspx?n=AboutLinktoHtml
#
proc ::Zoom::Init {} {
    variable STATIC
    global state

    set STATIC(maxRendered) $state(zoom,maxRendered)
    if {[info exists state(zoom,canDo)] && ! $state(zoom,canDo)} return

    set state(zoom,canDo) 0			;# Assume we can't do it
    if {! [::Data::CanDo internet]} {
	return [WARN "This feature requires the http extension"]
    }
    if {! $state(can,jpeg)} {
	return [WARN "This feature requires the Img extension"]
    }
    if {! [::Data::CanDo pgu]} {
	return [WARN "This feature requires KLIMB's pgu extension"]
    }

    set state(zoom,canDo) 1
    set STATIC(url2) $STATIC(url)
    ::Zoom::FindCache
}
##+##########################################################################
#
# ::Zoom::FindCache -- returns location of our cache directory
#
proc ::Zoom::FindCache {} {
    #set ::Zoom::STATIC(cache) [file join $::state(wdir) zoom]
    set ::Zoom::STATIC(cache) [file join $::state(zdir) zoom]
    return $::Zoom::STATIC(cache)
}
##+##########################################################################
#
# ::Zoom::MakeMap -- sets us up for a new map to be displayed
#
proc ::Zoom::MakeMap {} {
    variable DS
    variable ZMAP
    variable stats

    #::PGU::Cancel -all
    set ZMAP(ready) 0
    set ZMAP(mag) [expr {$DS(mag) + 10}]
    set ZMAP(theme) $DS(theme)
    set ZMAP(rendered) {}			;# List of all rendered cells
    incr ZMAP(sid)				;# Session id
    ::Zoom::Layout
    ::Zoom::DrawGrid
    ::Zoom::DrawPoints
    if {$ZMAP(what) eq "route"} {
	::MilePost::Go $::Zoom::W
	::Arrow::Go $::Zoom::W
    }
    if {$::state(atlas)} {
	::Atlas::Begin
    }
    update

    ::Zoom::StartMapFetch
    set ZMAP(ready) 1
    set stats(rendered) 0
    #::Zoom::RunAllQueues ;# this happens via Expose from scrollbar
}
##+##########################################################################
#
# ::Zoom::Canvas2Small -- converts W coordinates to W2 coordinates
#
proc ::Zoom::Canvas2Small {args} {
    variable STATIC

    set xy {}
    foreach x $args {
	lappend xy [expr {$x / $STATIC(small)}]
    }
    return $xy
}
##+##########################################################################
#
# Clear -- clears the map and deletes all map images
#
proc ::Zoom::Clear {} {
    variable W
    variable W2
    variable ZMAP

    if {[info exists ::nnode(l0)] && $::nnode(l0) eq "Elevation"} {
	destroy .nnode
    }
    if {[winfo exist $W]} {
	$W delete all
	$W2 delete all

	$W config -scrollregion {0 0 99999 99999}
	$W xview moveto 0
	$W yview moveto 0
	update
    }
    foreach img [image names] {
	if {[string match "::zoom::*" $img]} {
	    image delete $img
	}
    }
    set ZMAP(rendered) {}
}
##+##########################################################################
#
# ::Zoom::MyScroller -- our scroll procedure that also gets maps
#
proc ::Zoom::MyScroller {xy first last} {
    ::Zoom::GetScreenRect
    ${::Zoom::T}.sb_$xy set $first $last
    ::Zoom::OverviewBox
    if {$::state(atlas)} {::ClipBox::Onscreen $::Zoom::W}
    after idle ::Zoom::Expose
}
##+##########################################################################
#
# ::Zoom::OverviewBox -- moves overview box on the grid window
#
proc ::Zoom::OverviewBox {} {
    variable W2
    variable SCREEN

    if {! [winfo exists $W2]} {
	INFO "missing $W2"
	return
    }

    set xy [::Zoom::Canvas2Small $SCREEN(l) $SCREEN(t) $SCREEN(r) $SCREEN(b)]
    $W2 coords over $xy
    ::Zoom::OverviewVisible $xy
}
##+##########################################################################
#
# ::Zoom::OverviewVisible -- keeps center of the overview box visible
#
proc ::Zoom::OverviewVisible {xy} {
    variable W2
    foreach {x0 y0 x1 y1} $xy break		;# Coordinates of overview box
    set x [expr {($x0 + $x1) / 2}]		;# Center of overview box
    set y [expr {($y0 + $y1) / 2}]

    foreach {l t r b} [::Display::GetScreenRect $W2] break
    if {$x <= $r && $y <= $b && $x >= $l && $y >= $t} return ;# Visible
    foreach {l t r b} [$W2 cget -scrollregion] break
    set cw [winfo width $W2]
    set ch [winfo height $W2]

    set xview [expr {(($x - $cw/2.0) - $l) / ($r - $l)}]
    set yview [expr {(($y - $ch/2.0) - $t) / ($b - $t)}]

    $W2 xview moveto $xview
    $W2 yview moveto $yview
}
##+##########################################################################
#
# ::Zoom::GetScreenRect -- gets coordinates of the visible part of the canvas
#
proc ::Zoom::GetScreenRect {} {
    variable SCREEN
    variable W

    foreach {sl st sr sb} [$W cget -scrollregion] break
    set sw [expr {$sr - $sl}]			;# Scroll width
    set sh [expr {$sb - $st}]			;# Scroll height

    # Get canvas info (could have used scrollbar for this)
    foreach {xl xr} [$W xview] break
    foreach {yt yb} [$W yview] break

    set SCREEN(l) [expr {round($sl + $xl * $sw)}]
    set SCREEN(r) [expr {round($sl + $xr * $sw)}]
    set SCREEN(t) [expr {round($st + $yt * $sh)}]
    set SCREEN(b) [expr {round($st + $yb * $sh)}]

    set SCREEN(w) [expr {$SCREEN(r) - $SCREEN(l)}]
    set SCREEN(h) [expr {$SCREEN(b) - $SCREEN(t)}]

    set SCREEN(rows) [expr {int(ceil($SCREEN(h) / 200.0))}]
    set SCREEN(cols) [expr {int(ceil($SCREEN(w) / 200.0))}]
}
##+##########################################################################
#
# ::Zoom::Layout -- figures out cells that are on the map
#
proc ::Zoom::Layout {} {
    variable SCREEN
    variable ZMAP
    variable RINFO

    ::Zoom::Clear
    set core [::Zoom::GetCellsOverCore]

    foreach {ZMAP(o,x) ZMAP(o,y)} [lindex $core 0] break
    incr ZMAP(o,x) -1 ; incr ZMAP(o,y) 2	;# Put in center of window

    foreach {t l b r} [::Zoom::GetBbox $core] break
    set extra [expr {$SCREEN(cols) - ($r - $l + 1)}]
    if {$extra > 0} {
	incr l [expr {-int(ceil($extra / 2.0))}]
	incr r [expr {$extra / 2}]
    }
    set extra [expr {$SCREEN(rows) - ($t - $b + 1)}]
    if {$extra > 0} {
	incr t [expr {int(ceil($extra / 2.0))}]
	incr b [expr {-($extra / 2)}]
    }
    incr t ; incr l -1				;# Supply a margin
    incr b -1 ; incr r
    set ZMAP(cells) [::Zoom::GetInnerCells [list $l $t] [list $r $b]]
    set ZMAP(bbox) [list $t $l $b $r]
    set ZMAP(core) $core
    set ZMAP(width) [expr {$r - $l + 1}]
    set ZMAP(height) [expr {$t - $b + 1}]
    set ZMAP(zone) [lindex $RINFO(pts) 0 6 2]
}
##+##########################################################################
#
# ::Zoom::GetDetails -- gets meta info about road or node
#
proc ::Zoom::GetDetails {what who} {
    variable RINFO

    array unset ::Zoom::RINFO
    set RINFO(what) $what
    set RINFO(who) $who
    if {$what eq "road"} {
	::Zoom::GetRoadInfo $who
    } elseif {$what eq "node"} {
	::Zoom::GetNodeInfo $who
    } elseif {$what eq "route"} {
	::Zoom::GetRouteInfo
    } elseif {$what eq "track"} {
	::Zoom::GetTrackInfo $who
    } elseif {$what eq "coords"} {
	::Zoom::GetCoordsInfo $who
    } elseif {$what eq "poi" || $what eq "geo"} {
	::Zoom::GetPOIInfo $what $who
    }

    ::Zoom::SwapNodeRoad $what
    ::Zoom::DisplayReadOnly
    ::Zoom::IsModified 0
}
##+##########################################################################
#
# ::Zoom::GetRoadInfo -- fills in RINFO w/ data about the road
#
proc ::Zoom::GetRoadInfo {who} {
    variable RINFO

    set RINFO(pts) [::Route::GetXYZ $who]	;# All the bends in the road
    foreach {. . RINFO(north) RINFO(dist) RINFO(south) RINFO(type) \
		 RINFO(title)} $::roads($who) break
    ::Zoom::GuessDistance
    ::Zoom::GuessClimbing
}
##+##########################################################################
#
# ::Zoom::GetNodeInfo -- fills in RINFO w/ data about the node
#
proc ::Zoom::GetNodeInfo {who} {
    variable RINFO

    set RINFO(pts) [::Route::GetXYZ "" $who]
    foreach {RINFO(title) RINFO(ele) lat lon} [lindex $RINFO(pts) 0] break
    set usgs [lindex $RINFO(pts) 0 8]
    if {$usgs eq {}} {set usgs "0+?"}
    set RINFO(usgs) [::Data::Label $usgs climb 3 2]

    set utm [::Data::ll2utm $lat $lon]
    lset RINFO(pts) 0 6 $utm
}
##+##########################################################################
#
# ::Zoom::GetPOIInfo -- Gets info about a POI
#
proc ::Zoom::GetPOIInfo {what who} {
    variable RINFO
    global poi

    if {$what eq "poi"} {
	foreach {RINFO(type) RINFO(title) lat lon RINFO(loc) RINFO(desc)} \
	    $poi($who) break
	set utm [::Data::ll2utm $lat $lon]
	set RINFO(pts) [list [list $RINFO(title) ? $lat $lon poi $who $utm]]
	return
    }
    if {$what eq "geo"} {
	foreach {lat lon . RINFO(title)} $::GPS::wpts($who) break
	set utm [::Data::ll2utm $lat $lon]
	set RINFO(pts) [list [list $RINFO(title) ? $lat $lon geo $who $utm]]
	return
    }
}
##+##########################################################################
#
# ::Zoom::GetRouteInfo -- fills in RINFO w/ data about the current route
#
proc ::Zoom::GetRouteInfo {} {
   variable RINFO

    set RINFO(pts) [::Route::GetXYZ]
    set RINFO(title) "Current Route"
    set RINFO(dist) $::msg(dist2)
    set RINFO(climb) $::msg(climb2)
    set RINFO(desc) $::msg(desc2)
    set ::Zoom::ZMAP(readonly) 1
}
##+##########################################################################
#
# ::Zoom::GetTrackInfo -- fills RINFO w/ data about a GPS track
#
proc ::Zoom::GetTrackInfo {who} {
    variable RINFO

    set rpts [::GPS::GetXYZ $who]
    set wpts [::GPS::GetWpts]
    set RINFO(pts) [concat $rpts $wpts]

    #set all [::Tracks::GetInfo $who]

    foreach var [list title dist climb desc] val [::Tracks::GetInfo $who] {
	set RINFO($var) $val
    }
    set ::Zoom::ZMAP(readonly) 1
}
##+##########################################################################
#
# ::Zoom::GetCoordsInfo -- fills RINFO w/ data about current coord
# can be called from coordinate locator or directly from map popup
#
proc ::Zoom::GetCoordsInfo {who} {
    variable RINFO

    set RINFO(title) "User Coordinates"
    if {$who eq "map"} {
	foreach {x y} $::state(popup) break
	foreach {. . . . lat lon} [::Display::canvas2pos $x $y] break
	set lat [int2lat $lat]
	set lon [int2lat $lon]
    } else {
	foreach {lat lon} [::Coords::Where] break
    }
    foreach {RINFO(lat) RINFO(lon)} [::Display::PrettyLat $lat $lon] break
    set lat [eval lat2int $lat]
    set lon [eval lat2int $lon]

    set RINFO(pts) [list [list "" ? $lat $lon coords "" ""]]
    set ::Zoom::ZMAP(readonly) 1
}
##+##########################################################################
#
# ::Zoom::GetInnerCells -- returns list of all cells w/i x0,y0 - x1,y1
#
proc ::Zoom::GetInnerCells {xy0 xy1} {
    foreach {x0 y0} $xy0 {x1 y1} $xy1 break
    if {$x0 > $x1} {foreach x0 $x1 x1 $x0 break}
    if {$y0 > $y1} {foreach y0 $y1 y1 $y0 break}

    set cells {}
    for {set x $x0} {$x <= $x1} {incr x} {
	for {set y $y1} {$y >= $y0} {incr y -1} {
	    lappend cells [list $x $y]
	}
    }
    return $cells
}
##+##########################################################################
#
# ::Zoom::GetCoreCells -- gets cells along straight line from two points
#
proc ::Zoom::GetCoreCells {x0 y0 x1 y1} {
    set dx [expr {abs($x1 - $x0) / 2.0}]
    set dy [expr {abs($y1 - $y0) / 2.0}]

    if {$dx > 1 || $dy > 1} {
	set x2 [expr {($x0 + $x1) / 2}]
	set y2 [expr {($y0 + $y1) / 2}]

	set cells1 [::Zoom::GetCoreCells $x0 $y0 $x2 $y2]
	set cells2 [::Zoom::GetCoreCells $x2 $y2 $x1 $y1]
	set cells [concat $cells2 $cells1]
    } else {
	set cells [::Zoom::GetInnerCells [list $x0 $y0] [list $x1 $y1]]
    }
    return $cells
}
##+##########################################################################
#
# ::Zoom::ShowCore -- debugging routines highlight core cells
# in the status window
#
proc ::Zoom::ShowCore {} {
    variable ZMAP

    foreach cell $ZMAP(core) {
	foreach {x y} $cell break
	::Zoom::Status $x $y cancel
    }
}
##+##########################################################################
#
# ::Zoom::GetCellsOverCore -- returns list of cells to cover all pts
#
proc ::Zoom::GetCellsOverCore {} {
    variable RINFO

    # Convert all to UTM and get bounding box
    unset -nocomplain mcells
    set idx -1
    foreach pt $RINFO(pts) {
	incr idx
	foreach {name ele lat lon type who utm} $pt break
	if {$utm eq ""} {
	    set utm [::Data::ll2utm $lat $lon]
	    lset RINFO(pts) $idx 6 $utm
	}
	set xy1 [lrange [::Zoom::ChunkUTM $utm] 0 1]
	if {$idx == 0} {
	    set org $xy1
	    set mcells($xy1) 1
	} else {
	    foreach cell [eval ::Zoom::GetCoreCells $xy0 $xy1] {
		set mcells($cell) 1
	    }
	}
	set xy0 $xy1
    }
    unset mcells($org)		;# Put origin first
    return [concat [list $org] [array names mcells]]
}
##+##########################################################################
#
# ::Zoom::GetBbox -- gets bounding box for a set of cells
#
proc ::Zoom::GetBbox {cells} {
    set first [lindex $cells 0]
    foreach {x y} $first break
    set t [set b $y]
    set l [set r $x]

    foreach cell $cells {
	foreach {x y} $cell break
	if {$y > $t} { set t $y } elseif {$y < $b} { set b $y}
	if {$x > $r} { set r $x } elseif {$x < $l} { set l $x}
    }
    return [list $t $l $b $r]
}
##+##########################################################################
#
# ::Zoom::ChunkUTM -- takes a UTM coord and a scale and returns
# the chunk values that terra server wants to fetch that page. It also
# returns the excess into that chunk.
#
# NB. returns x,y NOT northing, easting
#
proc ::Zoom::ChunkUTM {utm {sscale -1}} {
    if {$sscale == -1} {set sscale $::Zoom::ZMAP(mag)}

    foreach {north east . letter} $utm break

    set mult [expr {int(100 * pow(2,$sscale-9))}]
    set eX [expr {$east / double($mult)}]
    set eY [expr {$north / double($mult)}]
    set XX [expr {int($eX)}]
    set YY [expr {int($eY)}]

    return [list $XX $YY $eX $eY]
}
##+##########################################################################
#
# ::Zoom::Close -- cleans up and closes all the zoom windows
#
proc ::Zoom::Close {} {
    ::PGU::Cancel
    ::Zoom::Clear
    destroy $::Zoom::T
    ::Atlas::Reparent
}
##+##########################################################################
#
# DrawGrid -- draws the grid laid out by MakeLayout
#
proc ::Zoom::DrawGrid {} {
    variable ZMAP
    variable W
    variable W2
    variable COLORS

    $W delete cell
    catch {$W2 delete cell}
    set ww [expr {$ZMAP(width) * 200.0 / ([winfo width $W2] - 5)}]
    set hh [expr {$ZMAP(height) * 200.0 / ([winfo height $W2] - 5)}]
    set small [expr {$ww > $hh ? $ww : $hh}]
    if {$small > 30} {set small 30.0}
    set ::Zoom::STATIC(small) $small

    foreach cell $ZMAP(cells) {
	foreach {XX YY} $cell break
	set xy [::Zoom::CellBox $XX $YY]
	$W create rect $xy -tag [list cell cell$XX,$YY]
	set xys [eval ::Zoom::Canvas2Small $xy]
	$W2 create rect $xys -tag [list cell cell$XX,$YY] -fill $COLORS(empty)

	#continue
	# This draws id in each cell
	foreach {x0 y0 x1 y1} $xy break
	set x [expr {($x0 + $x1) / 2}]
	set y [expr {($y0 + $y1) / 2}]
	$W create text $x $y -tag cell -text "$XX,$YY" -font {Helvetica 18 bold}
    }
    $W config -scrollregion [$W bbox all]
    $W2 config -scrollregion [$W2 bbox all]
    $W2 create rect -1000 -1000 -1000 -1000 -tag over -width 4
}
##+##########################################################################
#
# CellBox -- returns coordinates of a given cell
#
proc ::Zoom::CellBox {XX YY {z 0}} {
    set xy1 [::Zoom::Chunk2canvas $XX [expr {$YY+1}] $z] ;# Upper left corner
    set xy2 [::Zoom::Chunk2canvas [expr {$XX+1}] $YY $z] ;# Lower right corner
    return [concat $xy1 $xy2]
}
##+##########################################################################
#
# ::Zoom::Chunk2canvas -- returns x,y of lower left corner of a chunk
#
proc ::Zoom::Chunk2canvas {XX YY {small 0}} {
    variable ZMAP
    variable STATIC

    set z [expr {$small ? $STATIC(small) : 1}]
    set x [expr {200 * ($XX-$ZMAP(o,x)) / $z}]
    set y [expr {200 * ($ZMAP(o,y)-$YY) / $z}]
    return [list $x $y]
}
##+##########################################################################
#
# ::Zoom::DrawPoints -- draws all the points in RINFO(pts)
#
proc ::Zoom::DrawPoints {} {
    variable ZMAP
    variable RINFO
    variable W
    variable W2
    global nodes state

    $W delete route
    $W2 delete route

    set bindAll [expr {$ZMAP(what) ne "road"}]
    set xy {}
    set xys {}
    set cnt -1
    set color $state(n,0,color)
    foreach pt $RINFO(pts) {
	incr cnt
	foreach {name ele lat lon type who utm} $pt break
	foreach {x y} [::Zoom::utm2canvas $utm] break
	lappend xy $x $y
	foreach {xs ys} [::Zoom::utm2canvas $utm 1] break
	lappend xys $xs $ys

	set tag pt_$cnt
	set tag2 ppt_$cnt
	::Balloon::Delete [list $W $tag]
	::Balloon::Delete [list $W2 $tag]

	if {$type eq "waypoint"} {
	    set item [expr {[string match "X*" $who] ? "rect" : "oval"}]
	    set coords [::Display::MakeBox [list $x $y] $state(n,size)]
	    $W create $item $coords -tag [list route node $tag] -fill $color

	    set coords2 [::Display::MakeBox [list $xs $ys] 5]
	    $W2 create $item $coords2 -tag [list route node $tag] -fill $color

	    set txt ""
	    regexp {[A-Za-z0-9]+} [string map {n {} N {}} $who] txt
	    if {$state(n,size) > 8} {
		$W create text $x $y -tag [list route node $tag] \
		    -font {times 8} -text $txt
	    }
	    if {$::state(me) && $ZMAP(what) eq "node"} {
		foreach {x0 y0 x1 y1} $coords break
		$W create line $x0 $y0 $x1 $y1 -tag [list route node a $tag] \
		    -width 2
		$W create line $x0 $y1 $x1 $y0 -tag [list route node a $tag] \
		    -width 2
	    }

	    ::Balloon::Create [list $W $tag] node $who "" ""
	    ::Balloon::Create [list $W2 $tag] node $who "" ""
	    if {$bindAll && ! $ZMAP(readonly)} {
		$W bind $tag <Button-1> \
		    [list ::Zoom::MoveNode down $tag $cnt %x %y]
		$W bind $tag <B1-Motion> \
		    [list ::Zoom::MoveNode move $tag $cnt %x %y]
	    }
	} elseif {$type eq "trackpoint"} {
	    set coords [::Display::MakeBox [list $x $y] $state(n,size)]
	    $W create oval $coords -tag [list trackpoint $tag] -fill $color
	    set coords2 [::Display::MakeBox [list $xs $ys] 5]
	    $W2 create oval $coords2 -tag [list trackpoint $tag] -fill $color
	    set xy [lrange $xy 0 end-2]
	    set xys [lrange $xys 0 end-2]

	    ::Balloon::Create [list $W $tag] trkpt $name $name $name
	    ::Balloon::Create [list $W2 $tag] trkpt $name $name $name
	} elseif {$type eq "poi"} {
	    set coords [::Display::MakeStar [list $x $y] \
			    [expr {2*$state(p,size)}]]
	    $W create poly $coords -fill $state(p,color) \
		-tag [list route node $tag]
	    set coords [::Display::MakeStar [list $xs $ys] 10]
	    $W2 create poly $coords -fill $state(p,color) \
		-tag [list route node $tag]
	    ::Balloon::Create [list $W $tag] poi $who
	    ::Balloon::Create [list $W2 $tag] poi $who

	    if {$bindAll && ! $ZMAP(readonly)} {
		$W bind $tag <Button-1> \
		    [list ::Zoom::MoveNode down $tag $cnt %x %y]
		$W bind $tag <B1-Motion> \
		    [list ::Zoom::MoveNode move $tag $cnt %x %y]
	    }
	} elseif {$type eq "geo"} {
	    ::GPS::Symbol $W [list $x $y] g [list route geo $tag] 2
	    ::GPS::Symbol $W2 [list $xs $ys] g [list route geo $tag]
	    ::Balloon::Create [list $W $tag] wpt $who
	    ::Balloon::Create [list $W2 $tag] wpt $who
	    if {$bindAll && ! $ZMAP(readonly)} {
		$W bind $tag <Button-1> \
		    [list ::Zoom::MoveNode down $tag $cnt %x %y]
		$W bind $tag <B1-Motion> \
		    [list ::Zoom::MoveNode move $tag $cnt %x %y]
	    }
	} elseif {$type eq "coords"} {
	    set ltag [list route node $tag]
	    $W create line $x -99999 $x 99999 -tag $ltag -width 2
	    $W create line -99999 $y 99999 $y -tag $ltag -width 2
	    $W2 create line $xs -99999 $xs 99999 -tag $ltag -width 2
	    $W2 create line -99999 $ys 99999 $ys -tag $ltag -width 2

	    set coords [::Display::MakeBox [list $x $y] $state(n,size)]
	    $W create oval $coords -tag $ltag -fill $color -width 2

	    set coords [::Display::MakeBox [list $xs $ys] 5]
	    $W2 create oval $coords -tag $ltag -fill $color -width 2

	} else {				;# Routepoints
	    set coords [::Display::MakeBox [list $x $y] 4]
	    $W create oval $coords -tag [list route rtept $tag] -fill $color
	    if {[string is double -strict $ele]} {
		$W create oval [::Display::MakeBox [list $x $y] 1] -fill black \
		    -tag [list route rtept $tag $tag2]
	    }

	    set coords [::Display::MakeBox [list $xs $ys] 3]
	    $W2 create oval $coords -fill $color -tag [list route rtept $tag]

	    $W bind $tag <<MenuMousePress>> \
		[list ::Zoom::DoPopupMenu %x %y rtept $cnt]
	    if {! $ZMAP(readonly)} {
		$W bind $tag <Control-Button-2> \
		    [list ::Zoom::DoPopupMenu %x %y delete $cnt]
		$W bind $tag <Button-1> \
		    [list ::Zoom::MoveNode down $tag $cnt %x %y]
		$W bind $tag <B1-Motion> \
		    [list ::Zoom::MoveNode move $tag $cnt %x %y]
	    }
	}
    }
    if {[llength $xy] > 2} {
	set clr $state(r,0,9,color)
	set width $state(r,0,9,width)
	$W create line $xy -tag {route road} -fill $clr -width $width
	$W2 create line $xys -tag {route road} -fill $clr -width $width
	::Balloon::Create [list $W road] road $who "" ""
	::Balloon::Create [list $W2 road] road $who "" ""
    }
    $W raise node
    $W raise geo
    $W raise rtept
    $W raise trackpoint
    $W raise milepost
    $W raise arrow
    $W raise zoom
    $W raise BOX
    $W2 raise node
    $W2 raise geo
    $W2 raise rtept
    $W2 raise trackpoint
    if {$ZMAP(mag) > 13} { $W lower rtept }

    bind $W <Control-Button-1> break		;# Disable bend road buttons
    bind $W <Control-Button-2> break

    $W bind img <<MenuMousePress>> "::Zoom::DoPopupMenu %x %y map; break"
    if {$ZMAP(what) eq "node"} {
	$W bind road <<MenuMousePress>> {::Zoom::DoPopupMenu %x %y node; break}
	if {! $ZMAP(readonly)} {
	    $W bind node <Enter> [list $W config -cursor hand2]
	    $W bind node <Leave> [list $W config -cursor {}]
	}
    } else {
	$W bind road <<MenuMousePress>> {::Zoom::DoPopupMenu %x %y road; break}
	if {! $ZMAP(readonly)} {
	    $W bind road <Control-Button-3> {::Zoom::DoPopupMenu %x %y add; break}
	    $W bind img <Control-Button-3> {::Zoom::DoPopupMenu %x %y add; break}
	    $W bind rtept <Enter> [list $W config -cursor hand2]
	    $W bind rtept <Leave> [list $W config -cursor {}]
	}
    }
}
##+##########################################################################
#
# ::Zoom::MoveNode -- moves a route point to the mouse position
#
proc ::Zoom::MoveNode {what tag idx x y} {
    variable ZMAP
    variable RINFO
    variable W
    variable W2
    variable lcxy				;# Last cursor xy

    if {$ZMAP(readonly) || ! $ZMAP(ready)} return
    set cx [$W canvasx $x]
    set cy [$W canvasy $y]
    set cxy [list $cx $cy]

    if {$what eq "down"} {
	set lcxy $cxy
	::Balloon::Cancel
	return
    } elseif {$what eq "up"} {
	# Enable balloon help
    }

    foreach {dx dy} $lcxy break
    set lcxy $cxy

    # Move the node
    set dx [expr {$cx - $dx}]
    set dy [expr {$cy - $dy}]
    $W move $tag $dx $dy
    eval $W2 move $tag [::Zoom::Canvas2Small $dx $dy]

    # Move the road
    set xy [$W coords road]
    if {$xy ne {}} {
	lset xy [expr {2 * $idx}] $cx
	lset xy [expr {2 * $idx + 1}] $cy
	$W coords road $xy
    }

    set xy [$W2 coords road]
    if {$xy ne {}} {
	foreach {sx sy} [::Zoom::Canvas2Small $cx $cy] break
	lset xy [expr {2 * $idx}] $sx
	lset xy [expr {2 * $idx + 1}] $sy
	$W2 coords road $xy
    }

    # Update the points list
    # NB. don't use cx,cy because that's anywhere on the circle
    foreach {x0 y0} [::Data::BboxCenter [$W bbox $tag]] break
    set utm [::Zoom::canvas2utm $x0 $y0]
    lset RINFO(pts) $idx 6 $utm			;# Put in new UTM position
    lset RINFO(pts) $idx 2 0			;# Erase lat/lon position
    lset RINFO(pts) $idx 3 0
    if {[lindex $RINFO(pts) $idx 1] ne "?"} {
	lset RINFO(pts) $idx 1 ?		;# Destroy elevation info
	$W delete ppt_$idx
    }
    ::Zoom::IsModified 1
    ::Zoom::GuessDistance
    ::Zoom::GuessClimbing

    set RINFO(usgs) ?
}
##+##########################################################################
#
# ::Zoom::GuessDistance -- how long the road is
#
proc ::Zoom::GuessDistance {} {
    variable RINFO
    variable ZMAP

    set RINFO(guess,dist) ""
    if {$ZMAP(what) ne "road"} return

    set lat0 -1
    set dist 0

    set idx -1
    foreach pt $RINFO(pts) {
	incr idx
	foreach {. . lat1 lon1 . . utm} $pt break
	if {$lat1 == 0} {			;# In utm
	    foreach {lat1 lon1} [eval ::Data::utm2ll $utm] break
	    lset RINFO(pts) $idx 2 $lat1
	    lset RINFO(pts) $idx 3 $lon1
	}

	if {$lat0 != -1} {
	    set d [::Data::Distance $lat0 $lon0 $lat1 $lon1]
	    set dist [expr {$dist + $d}]
	}
	set lat0 $lat1
	set lon0 $lon1
    }
    set RINFO(guess,dist) [::Data::Convert [Round1 $dist] dist]
}
##+##########################################################################
#
# ::Zoom::GuessClimbing -- computes climbing for a road smoothing
# out small bumps.
#
proc ::Zoom::GuessClimbing {} {
    variable RINFO
    variable ZMAP

    set RINFO(guess,north) "?"
    set RINFO(guess,south) "?"
    if {$ZMAP(what) ne "road"} return

    set z {}
    foreach pt $RINFO(pts) {
	set alt [lindex $pt 1]
	if {[string is double -strict $alt]} {
	    lappend z $alt
	}
    }
    if {[llength $z] < 2} return		;# Not enough data points

    foreach {climb desc} [::Data::PreCalcClimb $z] break
    set RINFO(guess,north) $desc
    set RINFO(guess,south) $climb
}
##+##########################################################################
#
# utm2canvas -- converts from utm into canvas coordinates
#
proc ::Zoom::utm2canvas {utm {small 0}} {
    foreach {. . eX eY} [::Zoom::ChunkUTM $utm] break
    foreach {x y} [::Zoom::Chunk2canvas $eX $eY $small] break
    return [list $x $y]
}
proc ::Zoom::ll2canvas {lat lon} {
    set utm [::Data::ll2utm $lat $lon]
    return [::Zoom::utm2canvas $utm]
}
##+##########################################################################
#
# ::Zoom::NewMag -- handles changing zoom level
#
proc ::Zoom::NewMag {delta} {
    variable ZMAP
    variable DS

    if {! $ZMAP(ready)} return
    if {$delta < 0 && $DS(mag) > 0} {
	if {$DS(theme) ne "topo" || $DS(mag) > 1} {
	    incr DS(mag) -1
	}
    } elseif {$delta > 0 && $DS(mag) < 9} {
	incr DS(mag)
    }

    if {$DS(mag) + 10 == $ZMAP(mag)} return	;# Hasn't changed
    ::Zoom::MakeMap
}
##+##########################################################################
#
# NewTheme -- Handles changing between topo and aerial views
#
proc ::Zoom::NewTheme {} {
    variable ZMAP
    variable DS

    if {$DS(theme) eq "topo"} {
	raise $::Zoom::T.left.b-2_cover		;# Hide illegal mag level
	raise $::Zoom::T.left.b-1_cover
	raise $::Zoom::T.left.b0_cover
	if {$DS(mag) <= 0} {			;# Not legal mag value
	    set DS(mag) 1
	}
    } elseif {$DS(theme) eq "aerial"} {
	raise $::Zoom::T.left.b-2_cover		;# Hide illegal mag level
	raise $::Zoom::T.left.b-1_cover
	lower $::Zoom::T.left.b0_cover
	if {$DS(mag) < 0} {			;# Not legal mag value
	    set DS(mag) 0
	}
	if {$DS(mag) == 1} {
	    set DS(mag) 0
	}
    } else {					;# Urban
	lower $::Zoom::T.left.b-2_cover
	lower $::Zoom::T.left.b-1_cover
	lower $::Zoom::T.left.b0_cover
	if {$DS(mag) == 1} {
	    set DS(mag) 0
	}
    }
    if {! $ZMAP(ready)} return
    if {$DS(theme) eq $ZMAP(theme) && $DS(mag) + 10 == $ZMAP(mag)} return
    ::Zoom::MakeMap
    return
}
##+##########################################################################
#
# ::Zone::DoDisplay -- Creates our GUI
#
proc ::Zoom::DoDisplay {} {
    global state
    variable T
    variable W
    variable W2
    variable DS
    variable SCREEN
    variable RINFO

    if {[winfo exists $T]} {
	::Zoom::Clear
	raise $T
	set txt "Save [string totitle $::Zoom::ZMAP(what)] Data"
	.sr_popup entryconfig 9 -label $txt
	return
    }

    destroy $T
    toplevel $T
    wm geom $T +10+10
    wm title $T "$::state(progname) Zoom"
    wm transient $T .
    wm protocol $T WM_DELETE_WINDOW ::Zoom::Close

    set W "$T.c"

    ::tk::frame $T.main -borderwidth 2 -relief ridge -background beige
    ::my::frame $T.ctrl -borderwidth 2 -relief ridge -pad 5

    ::my::label $T.title -background beige -borderwidth 0 \
	-font bolderFont -anchor c -textvariable ::Zoom::DS(title) -pad 5
    ::tk::frame $T.left -bg beige
    ::ttk::scrollbar $T.sb_x -command [list $W xview] -orient horizontal
    ::ttk::scrollbar $T.sb_y -command [list $W yview] -orient vertical
    canvas $W -width $SCREEN(w) -height $SCREEN(h) -highlightthickness 0 \
	-bg $::Zoom::COLORS(empty) -bd 0
    $W config -xscrollcommand [list ::Zoom::MyScroller x]
    $W config -yscrollcommand [list ::Zoom::MyScroller y]
    $W config -scrollregion [list 0 0 [$W cget -width] [$W cget -height]]

    # Road info
    ::ttk::frame $T.data
    ::Zoom::MakeRoadFrame $T.data
    ::Zoom::MakeNodeFrame $T.data
    ::Zoom::MakePOIFrame $T.data
    ::Zoom::MakeGEOFrame $T.data
    ::Zoom::MakeRouteFrame $T.data route
    ::Zoom::MakeRouteFrame $T.data track
    ::Zoom::MakeCoordsFrame $T.data

    # Map status
    ::my::labelframe $T.zgrid -text "Map Status"
    set W2 "$T.zgrid.c"
    ::ttk::scrollbar $T.zgrid.sb_x -command [list $W2 xview] -orient horizontal
    ::ttk::scrollbar $T.zgrid.sb_y -command [list $W2 yview] -orient vertical
    canvas $W2 -width 200 -height 200 -yscrollcommand [list $T.zgrid.sb_y set] \
	-xscrollcommand [list $T.zgrid.sb_x set] -highlightthickness 0 \
	-scrollregion {0 0 200 200}
    ::Display::TileBGFix $W2
    grid rowconfigure $T.zgrid 0 -minsize 10
    grid $W2 $T.zgrid.sb_y -sticky news -row 1
    grid $T.zgrid.sb_x -sticky news
    grid rowconfigure $T.zgrid 1 -weight 1
    grid columnconfigure $T.zgrid 0 -weight 1

    # Legend
    ::my::labelframe $T.zlegend -text "Map Legend"
    set WW $T.zlegend
    set items {Queued queued Fetching pending Retrieved done  \
		   Web web Cache cache Empty empty \
		   Timeout timeout Failure failure Discarded discarded}
    set row 1
    set col 0
    foreach {txt color} $items {
	::tk::label $WW.$color -text $txt -anchor c -bd 1 -relief solid \
	    -bg $::Zoom::COLORS($color) -font boldFont
	if {$::Zoom::COLORS($color) eq "blue"} { $WW.$color config -fg white}
	grid $WW.$color -row $row -column $col -sticky ew -padx 5 -pady 2
	if {[incr col] >= 3} {
	    incr row
	    set col 0
	}
    }
    grid columnconfigure $WW {0 1 2} -weight 1 -uniform a
    grid rowconfigure $WW 100 -minsize 5

    # Internet statistics
    ::my::labelframe $T.stats -text "Internet Statistics" -pad 5
    ::my::label $T.lqueue -text Queued -anchor w
    ::my::label $T.equeue -textvariable ::Zoom::stats(queued) -relief sunken \
	-width 5 -anchor c
    ::my::label $T.lload -text Loading -anchor w
    ::my::label $T.eload -textvariable ::Zoom::stats(loading) -relief sunken \
	-width 5 -anchor c
    ::my::label $T.lretrieve -text Retrieved -anchor w
    ::my::label $T.eretrieve -textvariable ::Zoom::stats(retrieved) \
	-width 5 -relief sunken -anchor c
    ::my::label $T.lrendered -text Rendered -anchor w
    ::my::label $T.erendered -textvariable ::Zoom::stats(rendered) \
	-width 5 -relief sunken -anchor c
    grid $T.lqueue $T.equeue -in $T.stats -sticky ew
    grid $T.lload $T.eload -in $T.stats -sticky ew
    grid $T.lretrieve $T.eretrieve -in $T.stats -sticky ew
    grid $T.lrendered $T.erendered -in $T.stats -sticky ew
    grid columnconfigure $T.stats 0 -weight 1
    grid columnconfigure $T.stats 5 -minsize 5

    # Buttons
    ::my::frame $T.buttons -borderwidth 2 -relief ridge
    ::ttk::button $T.buttons.print -text "Print" -command [list ::Print::Dialog zoom]
    ::ttk::button $T.buttons.save -text "Update" -command ::Zoom::Save -state disabled
    ::ttk::button $T.buttons.dismiss -text "Dismiss" -command ::Zoom::Close
    ::ttk::button $T.buttons.view -text "Google Maps" -command [list ::Zoom::Google zoom]

    grid x $T.buttons.print x $T.buttons.view x -pady 5 -sticky ew
    grid x $T.buttons.save x $T.buttons.dismiss x -pady 5 -sticky ew
    grid columnconfigure $T.buttons {0 2 4} -weight 1
    grid columnconfigure $T.buttons {1 3} -uniform a

    # Grid outer frames
    grid $T.main $T.ctrl -sticky news
    grid columnconfigure $T 0 -weight 1
    grid rowconfigure $T 0 -weight 1

    # Grid main window
    grid x $T.title x -in $T.main -sticky news -row 0
    grid $T.left $W $T.sb_y -in $T.main -sticky news
    grid ^ $T.sb_x x -in $T.main -sticky ew
    grid columnconfigure $T.main 1 -weight 1
    grid rowconfigure $T.main 1 -weight 1


    # Grid the control frame
    grid $T.data -in $T.ctrl -sticky news -pady 5
    grid $T.zgrid -in $T.ctrl -sticky news -pady 5
    grid $T.zlegend -in $T.ctrl -sticky news -pady 5
    grid $T.stats -in $T.ctrl -sticky news -pady 5
    grid rowconfigure $T.ctrl 100 -weight 1
    grid $T.buttons -in $T.ctrl -sticky news -row 101

    # Set up bindings
    bind $W <2> [bind Text <2>]			;# Enable dragging w/ <2>
    bind $W <B2-Motion> [bind Text <B2-Motion>]
    $W bind img <1> [bind $W <2>]
    $W bind img <B1-Motion> [bind $W <B2-Motion>]

    bind $W2 <2> [bind Text <2>]		;# Enable dragging w/ <2>
    bind $W2 <B2-Motion> [bind Text <B2-Motion>]
    $W2 bind img <1> [bind $W2 <2>]
    $W2 bind img <B1-Motion> [bind $W2 <B2-Motion>]
    if {$::state(su)} {
	catch {bind .zoom <Key-.> ::Zoom::Save&Close}
    }
    ::Zoom::DrawScale $T.left

    destroy .sr_popup
    menu .sr_popup -tearoff 0
    .sr_popup add command -label "Add New Route Point" -underline 0 \
	-command [list ::Zoom::RoutePoint add]
    .sr_popup add command -label "Delete this Route Point" -underline 0 \
	-command [list ::Zoom::RoutePoint delete]
    .sr_popup add command -label "Split Road at Point" -underline 0 \
	-command [list ::Zoom::RoutePoint "split"]
    .sr_popup add separator
    .sr_popup add command -label "Add Elevation" -underline 4 \
	-command [list ::Zoom::RoutePoint elevation]
    .sr_popup add command -label "Insert Waypoint" -underline 0 \
	-command [list ::Zoom::RoutePoint insert]
    .sr_popup add command -label "Create Arrow" -underline 0 \
	-command [list ::Arrow::Dialog $::Zoom::W "" {0 0}]
    .sr_popup add command -label "Google Maps" -underline 0 \
	-command [list ::Zoom::RoutePoint google]
    .sr_popup add separator
    .sr_popup add command -label "Delete All Waypoints" -underline 7 \
	-command [list ::Zoom::RoutePoint deleteall]
    if {$::state(su)} {
	.sr_popup add separator
	set txt "Save [string totitle $::Zoom::ZMAP(what)] Data"
	.sr_popup add command -label $txt -command ::Zoom::Save -underline 0
    }
    update
}
proc ::Zoom::Save&Close {} {
    ::Zoom::USGSAllWaypoints
    ::Zoom::Save
    #::Zoom::Close
    ::Save::SaveUserDataCmd 1
    #puts "::Zoom::Save&Close: dist: $::Zoom::RINFO(dist) north: $::Zoom::RINFO(north) south: $::Zoom::RINFO(south)"
}
##+##########################################################################
#
# ::Zoom::MakeRoadFrame -- draws the frame w/ road title, distance & climbing
#
proc ::Zoom::MakeRoadFrame {parent} {
    set PW $parent.road
    ::my::labelframe $PW -text "Road Data"

    set tw 8
    set a [list -width $tw -justify center -state readonly]

    ::my::label $PW.atitle -text "Data"
    ::my::label $PW.etitle -text "Est."

    ::my::entry $PW.title -textvariable ::Zoom::RINFO(title) -justify center
    ::my::label $PW.ldist -text "Distance" -anchor w
    ::my::entry $PW.edist -textvariable ::Zoom::RINFO(dist) -width $tw -justify center
    eval ::my::entry $PW.gdist -textvariable ::Zoom::RINFO(guess,dist) $a
    ::my::label $PW.lnorth -text "North climbing" -anchor w
    ::my::entry $PW.enorth -textvariable ::Zoom::RINFO(north) -width $tw -justify center
    eval ::my::entry $PW.gnorth -textvariable ::Zoom::RINFO(guess,north) $a
    ::my::label $PW.lsouth -text "South climbing" -anchor w
    ::my::entry $PW.esouth -textvariable ::Zoom::RINFO(south) -width $tw -justify center
    eval ::my::entry $PW.gsouth -textvariable ::Zoom::RINFO(guess,south) $a

    ::ttk::button $PW.save -text "Update" -command ::Zoom::Save
    ::ttk::button $PW.usgs -image ::img::star -command ::Zoom::USGSAllWaypoints
    bind $PW.usgs <Button-3> ::Zoom::Save&Close
    ::Balloon::Create $PW.usgs static usgs "Query USGS for all waypoint elevation" ""

    set ::Zoom::DS($PW,focus) $PW.edist

    grid $PW.title - - -sticky ew -pady 5 -padx 5
    grid $PW.ldist $PW.edist -sticky ew -padx 5 -row 2
    grid $PW.lnorth $PW.enorth -sticky ew -padx 5
    grid $PW.lsouth $PW.esouth -sticky ew -padx 5
    if {1 || $::Zoom::ZMAP(guessable)} {
	grid x $PW.atitle $PW.etitle -row 1
	grid $PW.gdist  -row 2 -column 2 -sticky ew -padx {0 5}
	grid $PW.gnorth -row 3 -column 2 -sticky ew -padx {0 5}
	grid $PW.gsouth -row 4 -column 2 -sticky ew -padx {0 5}
	grid $PW.usgs   -row 5 -column 2 -padx {0 5}
    }
    grid $PW.save - - -row 5 -pady 5
    grid columnconfigure $PW 0 -weight 1
}
##+##########################################################################
#
# ::Zoom::MakeNodeFrame -- draws the frame w/ node data
#
proc ::Zoom::MakeNodeFrame {parent} {
    set PW $parent.node
    ::my::labelframe $PW -text "Node Data"

    ::my::entry $PW.title -textvariable ::Zoom::RINFO(title) -justify center
    ::my::label $PW.lele -text "Elevation" -anchor w
    ::my::entry $PW.eele -textvariable ::Zoom::RINFO(ele) -width 20 -justify center
    ::my::label $PW.luele -text "USGS Elevation" -anchor w
    ::my::frame $PW.euele -borderwidth 2 -relief sunken
    ::my::label $PW.euele.v -textvariable ::Zoom::RINFO(usgs) \
	-background grey80 -anchor c \
	-relief sunken -borderwidth 0 -justify center
    ::ttk::button $PW.euele.star -image ::img::star -command ::Zoom::GoUSGS
    pack $PW.euele.v -side left -fill both -expand 1
    pack $PW.euele.star -side right

    set txt "Query USGS for elevation"
    ::Balloon::Create $PW.euele.star zoom usgs $txt $txt

    # set fg [$PW.title cget -fg]
    # foreach w [winfo child $PW] {
    #	catch {$w config -disabledforeground $fg}
    # }

    ::ttk::button $PW.save -text Update -command ::Zoom::Save -state disabled
    set ::Zoom::DS($PW,focus) $PW.eele

    grid $PW.title - -sticky ew -pady 5 -padx 5
    grid $PW.lele $PW.eele -sticky ew -padx 5
    grid $PW.luele $PW.euele -sticky ew -padx 5
    grid $PW.save - -pady 5
    grid columnconfigure $PW 0 -weight 1
}
##+##########################################################################
#
# ::Zoom::MakePOIFrame -- draws the frame w/ POI data
#
proc ::Zoom::MakePOIFrame {parent} {
    set PW $parent.poi
    ::my::labelframe $PW -text "POI Data"

    ::my::entry $PW.title -textvariable ::Zoom::RINFO(title) -justify center
    ::my::entry $PW.desc -textvariable ::Zoom::RINFO(desc) -justify center

    ::ttk::button $PW.save -text Update -state disabled -command ::Zoom::Save
    set ::Zoom::DS($PW,focus) $PW.title

    grid $PW.title - -sticky ew -pady 5 -padx 5
    grid $PW.desc - -sticky ew -pady 5 -padx 5
    grid $PW.save - -pady 5
    grid columnconfigure $PW 0 -weight 1
}
##+##########################################################################
#
# ::Zoom::MakeGEOFrame -- draws the frame w/ GEO data
#
proc ::Zoom::MakeGEOFrame {parent} {
    set PW $parent.geo
    ::my::labelframe $PW -text "Geocaching Data"

    ::my::entry $PW.title -textvariable ::Zoom::RINFO(title) -justify center

    ::ttk::button $PW.save -text Update -state disabled -command ::Zoom::Save
    set ::Zoom::DS($PW,focus) $PW.title

    grid $PW.title - -sticky ew -pady 5 -padx 5
    grid $PW.save - -pady 5
    grid columnconfigure $PW 0 -weight 1
}
##+##########################################################################
#
# ::Zoom::MakeRouteFrame -- draws the frame w/ track info
#
proc ::Zoom::MakeRouteFrame {parent {what route}} {
    set PW $parent.$what
    ::my::labelframe $PW -text "[string totitle $what] Data"

    ::my::entry $PW.title -textvariable ::Zoom::RINFO(title) -justify center
    ::my::label $PW.ldist -text "Distance" -anchor w
    ::my::entry $PW.edist -textvariable ::Zoom::RINFO(dist) -width 10 -justify center
    ::my::label $PW.lclimb -text "Climbing" -anchor w
    ::my::entry $PW.eclimb -textvariable ::Zoom::RINFO(climb) -width 10 -justify center
    ::my::label $PW.ldesc -text "Descending" -anchor w
    ::my::entry $PW.edesc -textvariable ::Zoom::RINFO(desc) -width 10 -justify center
    set ::Zoom::DS($PW,focus) $PW.edist

    ::ttk::button $PW.save -text "Update" -command ::Zoom::Save

    grid $PW.title - -sticky ew -pady 5 -padx 5
    grid $PW.ldist $PW.edist -sticky ew -padx 5
    grid $PW.lclimb $PW.eclimb -sticky ew -padx 5
    grid $PW.ldesc $PW.edesc -sticky ew -padx 5
    #grid $PW.save - -pady 5
    grid columnconfigure $PW 0 -weight 1
}
##+##########################################################################
#
# ::Zoom::MakeCoordsFrame -- draws the frame w/ user coordinates
#
proc ::Zoom::MakeCoordsFrame {parent} {
    set PW $parent.coords
    ::my::labelframe $PW -text "Coordinate Data"

    ::my::entry $PW.title -textvariable ::Zoom::RINFO(title) -justify center
    ::my::label $PW.llat -text "Latitude:"  -anchor w
    ::my::entry $PW.lat -textvariable ::Zoom::RINFO(lat) -justify center
    ::my::label $PW.llon -text "Longitude:" -anchor w
    ::my::entry $PW.lon -textvariable ::Zoom::RINFO(lon) -justify center

    ::ttk::button $PW.save -text Update -state disabled -command ::Zoom::Save
    set ::Zoom::DS($PW,focus) $PW.title

    grid $PW.title - -sticky ew -pady 5 -padx 5
    grid $PW.llat $PW.lat -sticky ew -padx 5
    grid $PW.llon $PW.lon -sticky ew -padx 5
    grid columnconfigure $PW 0 -weight 1
}
##+##########################################################################
#
# ::Zoom::DisplayReadOnly -- updates display for readonly mode
#
proc ::Zoom::DisplayReadOnly {} {
    set w ${::Zoom::T}.data
    set how [expr {$::Zoom::ZMAP(readonly) ? "disabled" : "normal"}]
    set how [expr {$::Zoom::ZMAP(readonly) ? "readonly" : "normal"}]
    ::Zoom::DisplayReadOnly2 $w $how
}
proc ::Zoom::DisplayReadOnly2 {WW how} {
    foreach w [winfo children $WW] {
	if {[string match "*data.road.g*" $w]} continue
	catch {$w config -state $how}
	::Zoom::DisplayReadOnly2 $w $how
    }
}
##+##########################################################################
#
# ::Zoom::GoUSGS -- initiates querying USGS for elevation of a node
#
proc ::Zoom::GoUSGS {} {
    variable RINFO

    set utm [lindex $RINFO(pts) 0 6]
    foreach {lat lon} [eval ::Data::utm2ll $utm] break
    set latlon [concat [int2lat $lat] [int2lat $lon]]
    set usgs [::USGS::Dialog $::Zoom::T $latlon]

    # First convert to external units
    set usgs [::Data::Convert $usgs climb]
    if {! [string is double -strict $usgs]} {
	set RINFO(usgs) $usgs
	return
    }

    set RINFO(usgs) [::Data::Label $usgs climb 3]
    if {$::Zoom::ZMAP(readonly)} return
    if {[string is double -strict $RINFO(ele)]} return
    set RINFO(ele) $usgs
}
##+##########################################################################
#
# ::Zoom::DrawScale -- creates our zoom buttons
#
proc ::Zoom::DrawScale {WW} {
    variable STATIC

    if {[lsearch [image names] ::img::plus] == -1} {
	image create bitmap ::img::plus -foreground white -background darkblue \
	    -data {
		#define plus_width 20
		#define plus_height 20
		static char plus_bits = {
		    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0xe0,
		    0x7f, 0x00, 0x70, 0xe0, 0x00, 0x38, 0xc0, 0x00, 0x18, 0x86,
		    0x01, 0x1c, 0x86, 0x03, 0x0c, 0x06, 0x03, 0xcc, 0x3f, 0x03,
		    0xcc, 0x3f, 0x03, 0x0c, 0x06, 0x03, 0x1c, 0x86, 0x03, 0x18,
		    0x86, 0x01, 0x38, 0xc0, 0x01, 0x70, 0xe0, 0x00, 0xe0, 0x7f,
		    0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	    } -maskdata {
		#define mask_width 20
		#define mask_height 20
		static char mask_bits = {
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	    }
	image create bitmap ::img::minus -foreground white \
	    -background darkblue -data {
		#define minus_width 20
		#define minus_height 20
		static char minus_bits = {
		    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0xe0,
		    0x7f, 0x00, 0x70, 0xe0, 0x00, 0x38, 0xc0, 0x00, 0x18, 0x80,
		    0x01, 0x1c, 0x80, 0x03, 0x0c, 0x00, 0x03, 0xcc, 0x3f, 0x03,
		    0xcc, 0x3f, 0x03, 0x0c, 0x00, 0x03, 0x1c, 0x80, 0x03, 0x18,
		    0x80, 0x01, 0x38, 0xc0, 0x01, 0x70, 0xe0, 0x00, 0xe0, 0x7f,
		    0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	    } -maskdata {
		#define mask_width 20
		#define mask_height 20
		static char mask_bits = {
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	    }
	image create photo ::img::button -width 18 -height 6
    }

    ::tk::label $WW.zin -text "Zoom\nIn" -font {{MS Sans Serif} 6 bold} -bg beige \
	-activebackground darkblue
    grid $WW.zin -row 1 -sticky s
    ::tk::button $WW.bp -image ::img::plus -bg darkblue -takefocus 0 \
	-activebackground darkblue -command {::Zoom::NewMag -1}
    ::Balloon::Create $WW.bp zoom plus "Zoom in by 2x" ""
    grid  $WW.bp -pady 2 -row 2
    for {set i -2} {$i < 10} {incr i} {
	::tk::radiobutton $WW.b$i \
	    -bg lightblue \
	    -image ::img::button \
	    -command [list ::Zoom::NewMag 0] \
	    -overrelief groove \
	    -variable ::Zoom::DS(mag) \
	    -value $i \
	    -activebackground darkblue \
	    -indicatoron 0 \
	    -takefocus 0 \
	    -selectcolor darkblue
	set bmsg [lindex $STATIC(mags) [expr {$i+2}]]
	::Balloon::Create $WW.b$i zoom b$i "Zoom $bmsg" ""
	grid $WW.b$i -pady 2 -row [expr {$i+3+2}]
	if {$i <= 0} {
	    canvas $WW.b${i}_cover -bd 0 -highlightthickness 0 -bg beige
	    place $WW.b${i}_cover -in $WW.b$i -bordermode outside -x 0 -y 0 \
		-relheight 1 -relwidth 1
	}
    }
    ::tk::button $WW.bm -image ::img::minus -bg darkblue \
	-activebackground darkblue -takefocus 0 -command {::Zoom::NewMag 1}
    grid $WW.bm -pady 2
    ::Balloon::Create $WW.bm zoom minus "Zoom out by 2x" ""
    ::tk::label $WW.zout -text "Zoom\nOut" -font [$WW.zin cget -font] -bg beige \
	-activebackground darkblue
    grid $WW.zout -pady {0 20}

    foreach w {topo aerial urban} \
	msg {{View topo map} {View aerial photograph} \
		 "View urban photograph\n(not available everywhere)"} {
	::tk::radiobutton $WW.$w -text [string totitle $w] \
	    -command ::Zoom::NewTheme \
	    -font [$WW.zin cget -font] \
	    -indicatoron 0 \
	    -relief raised \
	    -activeforeground white \
	    -activebackground darkblue \
	    -selectcolor darkblue \
	    -fg white \
	    -bg lightblue \
	    -takefocus 0 \
	    -variable ::Zoom::DS(theme) \
	    -value $w
	::Balloon::Create $WW.$w zoom $w $msg ""
	grid $WW.$w -pady 2 -sticky ew -padx 5
    }
    ::Zoom::NewTheme
}
##+##########################################################################
#
# ::Zoom::SwapNodeRoad -- swaps the node info and the road info frames
#
proc ::Zoom::SwapNodeRoad {what} {
    set parent ${::Zoom::T}.data
    set w [pack slaves $parent]			;# Who is there now
    set w2 "$parent.$what"			;# Who should be there
    focus $::Zoom::DS($w2,focus)
    catch {$::Zoom::DS($w2,focus) icursor end}

    if {$w eq $w2} return
    pack forget $w

    if {[winfo exists $w2]} {
	pack $w2 -side top -fill both -expand 1
    }
}
##+##########################################################################
#
# ::Zoom::StartMapFetch -- puts all cells into appropriate queues
#
proc ::Zoom::StartMapFetch {} {
    variable ZMAP
    variable FETCH

    array unset FETCH
    set FETCH(q,visible) [set FETCH(q,core) [set FETCH(q,all) {}]]
    set FETCH(aid) ""

    foreach cell $ZMAP(cells) {
	foreach {XX YY} $cell break
	set FETCH(status,$XX,$YY) 0		;# Mark as not fetched

	if {[::Zoom::IsCellVisible $XX $YY]} {
	    lappend FETCH(q,visible) $cell
	}
	if {[lsearch $ZMAP(core) $cell] > -1} {
	    lappend FETCH(q,core) $cell
	}
	lappend FETCH(q,all) $cell
    }
}
##+##########################################################################
#
# ::Zoom::Expose -- called when window scrolls, sets up after event to handle it
#
proc ::Zoom::Expose {} {
    variable FETCH

    after cancel $FETCH(aid)
    set FETCH(aid) [after 200 ::Zoom::_Expose]
}
##+##########################################################################
#
# ::Zoom::_Expose -- called when window scrolls, updates visible queue
#
proc ::Zoom::_Expose {} {
    variable FETCH
    variable ZMAP

    if {! $ZMAP(ready)} {			;# For BIG zooms, this gets
	::Zoom::Expose				;# called too early
	return
    }
    set new {}
    foreach cell $FETCH(q,all) {
	foreach {XX YY} $cell break
	if {$FETCH(status,$XX,$YY) != 0} continue ;# Already being fetched
	if {! [::Zoom::IsCellVisible $XX $YY]} continue	;# Off screen
	lappend new $cell
    }
    set FETCH(q,visible) $new
    if {$new ne {}} {after idle ::Zoom::RunAllQueues}
}
##+##########################################################################
#
# ::Zoom::IsCellVisible -- return true if any part of a cell block is visible
#
proc ::Zoom::IsCellVisible {XX YY} {
    variable SCREEN
    foreach {cl ct cr cb} [::Zoom::CellBox $XX $YY] break

    if {$ct >= $SCREEN(b) || $cb <= $SCREEN(t) \
	    || $cr <= $SCREEN(l) || $cl >= $SCREEN(r)} { return 0}
    return 1
}
proc ::Zoom::DistanceFromVisible {XX YY} {
    variable SCREEN
    foreach {cl ct cr cb} [::Zoom::CellBox $XX $YY] break

    set dist 0
    if {$cl >= $SCREEN(r)} { set dist [expr {$dist + ($cr - $SCREEN(r))}] }
    if {$cr <= $SCREEN(l)} { set dist [expr {$dist - ($cl - $SCREEN(l))}] }
    if {$ct >= $SCREEN(b)} { set dist [expr {$dist + ($cb - $SCREEN(b))}] }
    if {$cb <= $SCREEN(t)} { set dist [expr {$dist - ($ct - $SCREEN(t))}] }

    return $dist
}
proc ::Zoom::bar {} {
    foreach {t l b r} $::Zoom::ZMAP(bbox) break
    for {set row $t} {$row >= $b} {incr row -1} {
	set dr [expr {$t - $row}]
	for {set col $l} {$col <= $r} {incr col} {
	    set dc [expr {$col - $l}]
	    set viz [::Zoom::IsCellVisible $col $row]
	    set dist [::Zoom::DistanceFromVisible $col $row]
	    set dist [format "%3d" $dist]
	    puts -nonewline "($dr,$dc) $viz,$dist  "
	}
	puts ""
    }
}
##+##########################################################################
#
# ::Zoom::GetFilename -- returns name of where to store the map file
#
proc ::Zoom::GetFilename {XX YY} {
    variable STATIC
    variable ZMAP

    set fname "${XX}_${YY}_$ZMAP(zone).jpg"
    set dirname [file join $STATIC(cache) $ZMAP(theme) $ZMAP(mag) $XX]
    if {! [file isdirectory $dirname]} {
	file mkdir $dirname
	if {! [file isdirectory $dirname]} {
	    WARN "Can't create directory '$dirname'"
	    set ZMAP(nofetch) 1
	    return ""
	}
    }
    set fname [file join $dirname $fname]
    return $fname
}
proc ::Zoom::GetIName {XX YY} {
    set fname [::Zoom::GetFilename $XX $YY]
    set iname "::zoom::[file rootname [file tail $fname]]"
    return $iname
}
##+##########################################################################
#
# ::Zoom::GetURL -- return the url needed to fetch a particular map
#
proc ::Zoom::GetURL {XX YY} {
    variable STATIC
    variable ZMAP

    set arg "T=$STATIC(rtheme,$ZMAP(theme))&S=$ZMAP(mag)&X=$XX&y=$YY"
    append arg "&Z=$ZMAP(zone)"
    set url "$STATIC(url2)?$arg"
    return $url
}
##+##########################################################################
#
# ::Zoom::doneCmd -- callback routine that is called when a map page arrives
#
proc ::Zoom::doneCmd {token cookie} {
    if {[::http::status $token] ne "ok"} return ;# Some kind of failure

    foreach {sid fname XX YY} $cookie break
    if {$sid != $::Zoom::ZMAP(sid)} return	;# Wrong session

    # Check for valid image: could be error message

    # Save image off to a file
    set fout [open $fname w]
    fconfigure $fout -translation binary
    puts -nonewline $fout [::http::data $token]
    close $fout

    after idle ::Zoom::PutImage $XX $YY [list $fname] web
}
##+##########################################################################
#
# ::Zoom::PutImage -- displays a image in a file at a given location
#
proc ::Zoom::PutImage {XX YY fname whence} {
    variable W
    variable ZMAP
    variable FETCH
    variable stats

    if {! [winfo exists $W]} return
    # perhaps skip rendering of non-visible, non-core cells

    if {! [::Zoom::Ok2Render $XX $YY]} {	;# DON'T DISPLAY IT!!!
	set FETCH(status,$XX,$YY) 0		;# Mark as unqueued
	::Zoom::Status $XX $YY discarded
	return
    }

    set FETCH(status,$XX,$YY) 2			;# Mark as drawn
    ::Zoom::Status $XX $YY $whence
    incr stats(rendered)
    lappend ZMAP(rendered) [list $XX $YY]

    set iname [::Zoom::GetIName $XX $YY]
    if {[lsearch [image names] $iname] == -1} {
	set n [catch {image create photo $iname -file $fname}]
	if {$n} {
	    set fname2 ${fname}.bad
	    file rename -force $fname $fname2
	    INFO "Bad image file $fname2"
	    set FETCH(status,$XX,$YY) 0		;# Mark as unqueued
	    ::Zoom::Status $XX $YY discarded
	    return
	}
    }
    foreach {x y} [::Zoom::Chunk2canvas $XX $YY] break
    $W create image $x $y -image $iname -tag [list img img_$XX,$YY] -anchor sw
    $W raise road
    $W raise node
    $W raise geo
    $W raise rtept
    $W raise trackpoint
    if {$ZMAP(mag) > 13} { $W lower rtept }
    $W raise milepost
    $W raise arrow
    $W raise BOX ; $W lower dash
    update idletasks
}
proc ::Zoom::MakeGrayscale {img} {
    set w [image width $img]
    set h [image height $img]
    image create photo ::zoom::tmp -width $w -height $h
    ::zoom::tmp config -data [$img data -format jpeg -grayscale]
    $img blank
    $img copy ::zoom::tmp
    image delete ::zoom::tmp
}
##+##########################################################################
#
# ::Zoom::Ok2Render -- determines if it is okay to render this cell.
# If we're over the max allowed, then skip if not visible or else
# kick out some other non-visible cell
#
proc ::Zoom::Ok2Render {XX YY} {
    variable W
    variable ZMAP
    variable STATIC
    variable FETCH

    set n [llength $ZMAP(rendered)]
    #if {$n < $STATIC(maxRendered)} { puts "$XX,$YY: enough room $n" }
    if {$n < $STATIC(maxRendered)} { return 1 }	;# Enough room
    #if {! [::Zoom::IsCellVisible $XX $YY]} { puts "$XX,$YY: offscreen" }
    if {! [::Zoom::IsCellVisible $XX $YY]} { return 0 }	;# Offscreen, ignore

    set idx [::Zoom::FindFurthestAway]
    foreach {xx yy} [lindex $ZMAP(rendered) $idx] break
    set ZMAP(rendered) [lreplace $ZMAP(rendered) $idx $idx]
    set iname [::Zoom::GetIName $xx $yy]
    $W delete img_$xx,$yy
    image delete $iname
    set FETCH(status,$xx,$yy) 0			;# Mark as unqueued
    ::Zoom::Status $xx $yy discarded

    #puts "$XX,$YY: kicking out $xx,$yy => $::Zoom::FETCH(status,$xx,$yy)"

    return 1
}
##+##########################################################################
#
# ::Zoom::FindFurthestAway -- returns rendered cell furthest
# away from the visible area. Uses cartesian distance from
# visible area; better(?) would be linear from core.
#
proc ::Zoom::FindFurthestAway {} {
    variable ZMAP

    set worst 0
    set dist 0
    set idx -1
    foreach cell $ZMAP(rendered) {
	incr idx
	set d [eval ::Zoom::DistanceFromVisible $cell]
	if {$d > $dist} {
	    set dist $d
	    set worst $idx
	}
    }
    return $worst
}
##+##########################################################################
#
# Status -- displays status of a cell and its fetching state
# PGS how: queued pending cancel timeout failure done
# zoom how: cache web
#
proc ::Zoom::Status {XX YY how} {
    variable W
    variable W2
    variable stats
    variable COLORS

    if {! [winfo exists $W]} return
    $W itemconfig cell$XX,$YY -fill $COLORS($how)
    $W2 itemconfig cell$XX,$YY -fill $COLORS($how)

    if {$how eq "queued"} {
	incr stats(queued)
    } elseif {$how eq "pending"} {
	incr stats(queued) -1
	incr stats(loading)
    } elseif {$how eq "done"} {
	incr stats(loading) -1
	incr stats(retrieved)
    } elseif {$how eq "failure" || $how eq "cancel"} {
	incr stats(loading) -1
    }
}
##+##########################################################################
#
# ::Zoom::statusCmd -- status callback for Parallel Get URL package
#
proc ::Zoom::statusCmd {id how cookie} {
    foreach {sid . XX YY} $cookie break
    if {$sid != $::Zoom::ZMAP(sid)} return
    ::Zoom::Status $XX $YY $how
}
##+##########################################################################
#
# ::Zoom::GetOneMap -- does the work to make one map appear
#
proc ::Zoom::GetOneMap {XX YY} {
    variable ZMAP
    variable FETCH

    set fname [::Zoom::GetFilename $XX $YY]
    if {$fname eq ""} return

    if {! $ZMAP(nocache) && [file exists $fname]} { ;# Is it in the cache?
	::Zoom::PutImage $XX $YY $fname cache
    } else {
	if {$ZMAP(nofetch)} return
	set url [::Zoom::GetURL $XX $YY]
	set cookie [list $ZMAP(sid) $fname $XX $YY]
	::PGU::Add $url $cookie ::Zoom::doneCmd ::Zoom::statusCmd
	set FETCH(status,$XX,$YY) 1
    }
}
##+##########################################################################
#
# ::Zoom::RunOneQueue -- gets all the maps in a given queue
#
proc ::Zoom::RunOneQueue {which max} {
    variable FETCH

    set cnt 0
    foreach cell $FETCH(q,$which) {
	if {$cnt >= $max} break
	foreach {XX YY} $cell break
	if {$FETCH(status,$XX,$YY) != 0} continue
	::Zoom::GetOneMap $XX $YY
	incr cnt
    }
    set FETCH(q,$which) [lrange $FETCH(q,$which) $cnt end]
    return $cnt
}
##+##########################################################################
#
# ::Zoom::RunAllQueues -- empties the visible and/or core queues
#
proc ::Zoom::RunAllQueues {} {
    variable FETCH
    variable STATIC

    set qlen [lindex [::PGU::Statistics] 0]
    set n [expr {$STATIC(maxFetch) - $qlen}]

    set cnt [::Zoom::RunOneQueue visible $n]
    incr cnt [::Zoom::RunOneQueue core [expr {$n - $cnt}]]
    after idle ::PGU::Launch
    return $cnt
}
##+##########################################################################
#
# ::Zoom::canvas2utm -- converts from canvas into utm coordinates
#
proc ::Zoom::canvas2utm {x y} {
    variable ZMAP

    set mult [expr {int(100 * pow(2,$ZMAP(mag)-9))}]

    set eX [expr {$x / 200.0 + $ZMAP(o,x)}]
    set eY [expr {$ZMAP(o,y) - $y / 200.0}]
    set north [expr {$eY * $mult}]
    set east [expr {$eX * $mult}]
    set zone $ZMAP(zone)

    return [list $north $east $zone]
}
##+##########################################################################
#
# ::Zoom::DoPopupMenu -- puts up the right-click popup menu
#
proc ::Zoom::DoPopupMenu {x y what {who ""}} {
    variable W
    variable DS
    variable ZMAP

    set DS(popup,cxy) [list [$W canvasx $x] [$W canvasy $y]]
    set DS(popup,what) $what
    set DS(popup,who) $who

    # Short circuit shortcuts
    if {$what eq "add" || $what eq "delete"} {
	::Zoom::RoutePoint $what
	return
    }

    # 0 = new route point
    # 1 = delete
    # 2 = split
    # 3
    # 4 = elevation
    # 5 = insert waypoint
    # 6 = arrow
    # 7 = google
    # 8
    # 9 = delete all
    # 10
    # 11 = save

    set isRtept [expr {$what eq "rtept"}]
    set notRtept [expr {$what ne "rtept"}]
    set isMap [expr {$what eq "map"}]
    set ss(0) disabled ; set ss(1) normal

    .sr_popup entryconfig 0 -state $ss($notRtept)
    .sr_popup entryconfig 1 -state $ss($isRtept)
    .sr_popup entryconfig 2 -state $ss($notRtept)
    .sr_popup entryconfig 4 -state $ss($isRtept)
    .sr_popup entryconfig 5 -state $ss($notRtept)
    if {$what eq "arrow"} {
	.sr_popup entryconfig 6 -label "Update Arrow" -state normal \
	    -command [list ::Arrow::Dialog $Zoom::W $who]
    } else {
	.sr_popup entryconfig 6 -label "Create Arrow" -state $ss($isMap) \
	    -command [list ::Arrow::Dialog $::Zoom::W "" $DS(popup,cxy)]
    }
    .sr_popup entryconfig 7 -state normal
    .sr_popup entryconfig 9 -state normal

    if {$ZMAP(readonly)} {
	.sr_popup entryconfig 0 -state disabled
	.sr_popup entryconfig 1 -state disabled
	.sr_popup entryconfig 4 -state disabled
	.sr_popup entryconfig 5 -state disabled
	.sr_popup entryconfig 9 -state disabled
    }
    tk_popup .sr_popup [winfo pointerx $W] [winfo pointery $W] \
	[expr {$what eq "road" ? 0 : ""}]
}
proc ::Zoom::old___DoPopupMenu {x y what {who ""}} {
    variable W
    variable DS

    set DS(popup,cxy) [list [$W canvasx $x] [$W canvasy $y]]
    set DS(popup,what) $what
    set DS(popup,who) $who
    if {$what eq "go"} {
	::Zoom::RoutePoint add
	return
    }
    if {$what eq "delete"} {
	::Zoom::RoutePoint delete
	return
    }

    set ss(0) disabled ; set ss(1) normal
    if {$::Zoom::ZMAP(readonly)} { set ss(1) $ss(0)}
    .sr_popup entryconfig 0 -state $ss([string equal "road"  $what])
    .sr_popup entryconfig 1 -state $ss([string equal "rtept" $what])
    .sr_popup entryconfig 3 -state $ss([string equal "rtept" $what])

    tk_popup .sr_popup [winfo pointerx $W] [winfo pointery $W] \
	[expr {$what eq "road" ? 0 : ""}]
}
##+##########################################################################
#
# RoutePoint -- handles adding or deleting route points
#
proc ::Zoom::RoutePoint {what} {
    variable RINFO
    variable DS

    if {$what eq "delete"} {
	set RINFO(pts) [lreplace $RINFO(pts) $DS(popup,who) $DS(popup,who)]
	::Zoom::IsModified 1
	::Zoom::DrawPoints
	::Zoom::GuessDistance
	::Zoom::GuessClimbing
    } elseif {$what eq "add" || $what eq "insert"} {
	foreach {idx seg} [::Zoom::FindSplit] break
	if {$what eq "insert"} {
	    set xy [eval ::Data::NearestPointOnLine $DS(popup,cxy) $seg]
	    set utm [eval ::Zoom::canvas2utm $xy]
	} else {
	    set utm [eval ::Zoom::canvas2utm $DS(popup,cxy)]
	}

	set pt [list {} ? 0 0 routepoint $RINFO(who) $utm added]
	set RINFO(pts) [linsert $RINFO(pts) $idx $pt]
	::Zoom::IsModified 1
	::Zoom::DrawPoints
	::Zoom::GuessDistance
	::Zoom::GuessClimbing
    } elseif {$what eq "elevation"} {
	::Zoom::UpdateRoutePoint $DS(popup,who)
	::Zoom::GuessClimbing
    } elseif {$what eq "split"} {
	#::Zoom::Close
	set utm [eval ::Zoom::canvas2utm $DS(popup,cxy)]
	set ::state(popup,what) "zoom"
	set ::state(popup,who) $RINFO(who)
	set ::state(popup,latlon) [eval ::Data::utm2ll $utm]
	::Edit::CreateSplit
    } elseif {$what eq "google"} {
	set utm [eval ::Zoom::canvas2utm $DS(popup,cxy)]
	set ll [eval ::Data::utm2ll $utm]
	::Zoom::Google zoompoint $ll
    } elseif {$what eq "deleteall"} {
	set RINFO(pts) [list [lindex $RINFO(pts) 0] [lindex $RINFO(pts) end]]
	::Zoom::IsModified 1
	::Zoom::DrawPoints
	::Zoom::GuessDistance
	::Zoom::GuessClimbing
    }
}
##+##########################################################################
#
# ::Zoom::IsModified -- called whenever modified status changes
#
proc ::Zoom::IsModified {onoff args} {
    set s [expr {$onoff ? "normal" : "disabled"}]

    foreach w [winfo child ${::Zoom::T}.data] {
	$w.save config -state $s
	if {[winfo exists $w.usgs]} {
	    $w.usgs config -state $s
	}
    }
    .sr_popup entryconfig 9 -state $s
    ${::Zoom::T}.buttons.save config -state $s
}
##+##########################################################################
#
# ::Zoom::FindSplit -- finds which leg the split point should be made on
#
proc ::Zoom::FindSplit {} {
    variable W
    variable DS

    foreach {cx cy} $DS(popup,cxy) break

    set xy [$W coords road]
    set best 0
    set dist 999999
    set seg {}
    for {set i 0} {$i+2 < [llength $xy]} {incr i 2} {
	foreach {x0 y0 x1 y1} [lrange $xy $i [expr {$i+3}]] break
	set d [::Data::DistanceToLine $cx $cy $x0 $y0 $x1 $y1]
	if {$d < $dist} {
	    set dist $d
	    set best $i
	    set seg [list $x0 $y0 $x1 $y1]
	}
    }
    set best [expr {($best / 2) + 1}]
    return [list $best $seg]
}
##+##########################################################################
#
# ::Zoom::UpdateRoutePoint -- dialog to add elevation to a route point
#
proc ::Zoom::UpdateRoutePoint {idx} {
    variable RINFO
    global nnode

    unset -nocomplain nnode
    set lat [int2lat [lindex $RINFO(pts) $idx 2]]
    set lon [int2lat [lindex $RINFO(pts) $idx 3]]
    set nnode(latlon) [concat $lat $lon]
    foreach {lat lon} [::Display::PrettyLat $lat $lon] break

    set txt "Add Route Point Elevation"
    set nnode(wtitle) "$::state(progname) $txt"
    set nnode(title)  "$txt\nLatitude $lat\nLongitude $lon"
    set nnode(l0) Elevation
    set nnode(e0) [lindex $RINFO(pts) $idx 1]
    set nnode(t0) 1
    set nnode(l1) "USGS Elevation"
    set nnode(e1) "?"
    set nnode(t1) 8
    ::Edit::NewDlg "Route Point" 2 $idx
    # Calls Edit::AddRoutePoint when done
}
##+##########################################################################
#
# ::Edit::AddRoutePoint -- called from ::Zoom::UpdateRoutePoint's dialog
#
proc ::Edit::AddRoutePoint {idx} {
    global nnode

    set elev "?"
    if {[string is double -strict $nnode(e0)]} {
	set elev $nnode(e0)
    }
    lset ::Zoom::RINFO(pts) $idx 1 $elev
    ::Zoom::IsModified 1
    destroy .nnode
    ::Zoom::DrawPoints
    ::Zoom::GuessClimbing
}
##+##########################################################################
#
# ::Zoom::SortCells -- sorts list of cells by closeness to given cell
#
proc ::Zoom::SortCells {ox oy cells} {
    set all {}
    foreach cell $cells {
	foreach {x y} $cell break
	set dist [expr {($x - $ox)*($x - $ox) + ($y - $oy) * ($y - $oy)}]
	lappend all [list $cell $dist]
    }
    set all [lsort -real -index 1 $all]
    set cells {}
    foreach cell $all { lappend cells [lindex $cell 0]}
    return $cells
}
##+##########################################################################
#
# Save -- saves the current road into <zone dir>/user.nodes
#
proc ::Zoom::Save {} {
    variable RINFO
    variable DS
    global state roads nnode poi

    ::Data::MarkModified $RINFO(what) $RINFO(who)
    if {$RINFO(what) eq "road"} {
	set rid $RINFO(who)
	set ll {}
	set elevs {}
	foreach pt [lrange $RINFO(pts) 1 end-1] {
	    foreach {name elev lat lon type who utm} $pt break
	    if {$lat == 0} {			;# It got moved
		foreach {lat lon} [eval ::Data::utm2ll $utm] break
	    }
	    eval lappend ll [int2lat $lat] [int2lat $lon]
	    lappend elevs $elev
	}
	if {[llength $ll] == 1} {set ll {}}	;# No xy data

	# Store north, dist & south but get from our guess if bad
	foreach what {north dist south} idx {2 3 4} {
	    if {[::BadMath::IsBad $RINFO($what)]} {
		set RINFO($what) "$RINFO(guess,$what)+?"
	    }
	    lset roads($rid) $idx $RINFO($what)
	}
	lset roads($rid) 6 $RINFO(title)	;# Road name
	lset roads($rid) 8 $ll			;# XY data
	lset roads($rid) 9 $elevs		;# Z data
	lset roads($rid) 11 zoom		;# Data source
	::Data::ReProcessOneRoad $rid
	::Zoom::IsModified 0
	::Route::StatRoute 1
	return
    }

    if {$RINFO(what) eq "node"} {
	set nnode(e0) $RINFO(title)		;# Put into Edit's global array
	set nnode(e1) $RINFO(ele)
	set nnode(e2) $RINFO(usgs)
	set utm [lindex $RINFO(pts) 0 6]
	foreach {lat lon} [eval ::Data::utm2ll $utm] break
	set nnode(latlon) [list $lat 0 0 $lon 0 0]
	::Edit::AddNode $RINFO(who)
	::Zoom::IsModified 0
	return
    }

    if {$RINFO(what) eq "poi"} {
	set utm [lindex $RINFO(pts) 0 6]
	foreach {lat lon} [eval ::Data::utm2ll $utm] break
	lset poi($RINFO(who)) 1 $RINFO(title)
	lset poi($RINFO(who)) 2 $lat
	lset poi($RINFO(who)) 3 $lon
	lset poi($RINFO(who)) 6 [::Display::pos2canvas root $lat $lon]
	::Display::DrawPOI $RINFO(who)
	::Zoom::IsModified 0
	return
    }
    if {$RINFO(what) eq "geo"} {
	set utm [lindex $RINFO(pts) 0 6]
	foreach {lat lon} [eval ::Data::utm2ll $utm] break
	lset ::GPS::wpts($RINFO(who)) 0 $lat
	lset ::GPS::wpts($RINFO(who)) 1 $lon
	lset ::GPS::wpts($RINFO(who)) 3 $RINFO(title)
	lset ::GPS::wpts($RINFO(who)) 6 [::Display::pos2canvas root $lat $lon]
	::GPS::DrawWpts g 0
	::Zoom::IsModified 0
    }
}
##+##########################################################################
#
# ::Zoom::Google -- brings up google maps at a specific lat/lon
# NB. google doesn't supply any marker on the map yet
#
proc ::Zoom::Google {what {who ?}} {
    variable ZMAP
    variable google

    if {$what eq "zoom" && $ZMAP(what) eq "road"} { ;# Called from w/i zoom
	set what $::Zoom::ZMAP(what)
	set who $::Zoom::ZMAP(who)
    } elseif {$what eq "popup"} {
	set what $::state(popup,what)
	set who $::state(popup,who)
    }
    set what [string tolower $what]
    set last $google(last)
    set google(last) [list $what $who]

    set to ""
    set mid ""
    if {$what eq "node"} {
	foreach {. . lat lon} $::nodes($who) break
	set from "$lat+-$lon"
    } elseif {$what eq "zoom"} {
	set utm [lindex $::Zoom::RINFO(pts) 0 6]
	foreach {lat lon} [eval ::Data::utm2ll $utm] break
	set from "$lat+-$lon"
    } elseif {$what eq "poi"} {
	foreach {. . lat lon} $::poi($who) break
	set from "$lat+-$lon"
    } elseif {$what eq "geo"} {
	foreach {lat lon} $::GPS::wpts($who) break
	set from "$lat+-$lon"
    } elseif {$what eq "coords"} {
	foreach {lat lon} [::Coords::Where] break
	set lat [eval lat2int $lat]
	set lon [eval lat2int $lon]
	set from "$lat+-$lon"
    } elseif {$what eq "map" || $what eq "embellishment"} {
	foreach {x y} $::state(popup) break
	foreach {. . . . lat lon} [::Display::canvas2pos $x $y] break
	set from "$lat+-$lon"
    } elseif {$what eq "zoompoint"} {
	foreach {lat lon} $who break
	set from "$lat+-$lon"
    } elseif {$what eq "road"} {
	foreach {nid1 nid2} $::roads($who) break
	foreach {. . lat lon} $::nodes($nid1) break
	set from "$lat+-$lon"
	foreach {. . lat lon} $::nodes($nid2) break
	set to "$lat+-$lon"

	# If repeating google map road, then put in a midpoint
	if {$last eq [list $what $who]} {
	    set xy [lindex $::roads($who) 8]
	    set len [expr {[llength $xy] / 6}]
	    if {$len > 0} {
		set n [expr {($len/2) * 6}]
		set lat3 [lrange $xy $n [expr {$n+2}]]
		set lon3 [lrange $xy [expr {$n+3}] [expr {$n+5}]]
		set lat [eval lat2int $lat3]
		set lon [eval lat2int $lon3]
		set mid "$lat+-$lon"
	    }
	}
    } elseif {$what eq "wpt"} {
	foreach {lat lon} $::GPS::wpts($who) break
	set from "$lat+-$lon"
    } else {
	puts "ERROR: unknown item for zoom google: '$what' '$who'"
	return
    }

    if {$to eq ""} {
	set url "http://maps.google.com/maps?q=$from"
    } elseif {$mid eq ""} {
	set url "http://maps.google.com/maps?saddr=$from&daddr=$to"
    } else {
	set url "http://maps.google.com/maps?saddr=$from&daddr=$mid+to:$to"
    }
    WebPage $url
    return $url
}
##+##########################################################################
#
# ::Zoom::USGSAllWaypoints -- gets the USGS elevation for all waypoints
#
proc ::Zoom::USGSAllWaypoints {} {
    variable W
    variable RINFO

    set who {}
    for {set i 0} {$i < [llength $RINFO(pts)]} {incr i} {
	set elev [lindex $RINFO(pts) $i 1]
	if {[string is double -strict $elev] && $elev > 0} continue
	lappend who $i
    }
    if {$who eq {}} return

    # Post dialog box for all queries
    set dlg [::USGS::_MakeWaitDialog [winfo toplevel $W]]
    after idle [list ::Zoom::_USGSAllWaypoints2 $dlg $who]
    DoGrab $dlg $dlg
    ::Zoom::GuessClimbing
}
##+##########################################################################
#
# ::Zoom::_USGSAllWaypoints2 -- helper for ::Zoom::USGSAllWaypoints
#
proc ::Zoom::_USGSAllWaypoints2 {dlg who} {
    variable RINFO

    set cnt 0
    foreach idx $who {
	incr cnt
	if {! [winfo exists $dlg]} break

	foreach {. . lat lon . . utm} [lindex $RINFO(pts) $idx] break
	if {$lat == 0} {			;# In utm
	    foreach {lat lon} [eval ::Data::utm2ll $utm] break
	    lset RINFO(pts) $idx 2 $lat
	    lset RINFO(pts) $idx 3 $lon
	}
	#set lat [lindex $RINFO(pts) $idx 2]
	#set lon [lindex $RINFO(pts) $idx 3]
	set latlon [concat [int2lat $lat] [int2lat $lon]]
	set ::USGS::S(msg) "Querying waypoint $cnt of [llength $who]"

	set usgs [::USGS::Query "" $latlon]
	if {[string is double -strict $usgs]} {
	    lset RINFO(pts) $idx 1 $usgs
	}
	update
    }
    ::Zoom::IsModified 1
    ::Zoom::DrawPoints
    destroy $dlg
}

proc ::Zoom::Elevs {} {
    package require Plotchart
    variable RINFO

    unset -nocomplain X
    unset -nocomplain Y
    set X {}
    set Y {}
    for {set i 0} {$i < [llength $RINFO(pts)]} {incr i} {
	set elev [lindex $RINFO(pts) $i 1]
	if {! [string is double -strict $elev]} continue
	lappend X $i
	lappend Y $elev
    }
    set y_sort [lsort -real $Y]
    set ys [::Plotchart::determineScale [lindex $y_sort 0] [lindex $y_sort end]]
    set xs [::Plotchart::determineScale [lindex $X 0] [lindex $X end]]
    lset xs 2 1

    set W .elevs
    if {! [winfo exists $W]} {
	destroy W
	toplevel $W
	wm transient $W .
	::ttk::button $W.replot -text "Replot" -command ::Zoom::Elevs
	::ttk::button $W.ok -text "Dismiss" -command [list destroy $W]
	set w [expr {.8 * [winfo screenwidth .]}]
	canvas $W.c -width $w -bd 0 -highlightthickness 0
	pack $W.c -expand 1 -fill both -side top
	pack $W.replot $W.ok -side left -expand 1 -pady 10
    } else {
	raise $W
	$W.c config -width [winfo width $W.c] -height [winfo height $W.c]
    }
    $W.c delete all
    set s [::Plotchart::createXYPlot $W.c $xs $ys]
    foreach x $X y $Y {
	$s plot series1 $x $y
    }
    $W.c itemconfig data -tag series1 -width 2
    set xy0 [::Plotchart::coordsToPixel $W.c [lindex $X 0] [lindex $Y 0]]
    set xy1 [::Plotchart::coordsToPixel $W.c [lindex $X end] [lindex $Y end]]

    $W.c create line [concat $xy0 $xy1] -tag a -fill green -width 2
}
## EON ZOOM
## BON CHOOSEFONT
##+##########################################################################
#
# ::ChooseFont::ChooseFont -- Displays the choose font dialog
#
proc ::ChooseFont::ChooseFont {{defaultFont ""}} {
    variable S

    destroy $S(W)
    toplevel $S(W) -padx 10 -pady 10
    ::Display::TileBGFix $S(W)
    wm title $S(W) "KLIMB Font Chooser"
    wm protocol $S(W) WM_DELETE_WINDOW [list ::ChooseFont::Done 0]

    ::my::label $S(W).font -text "Font:"
    ::my::label $S(W).style -text "Font style:"
    ::my::label $S(W).size -text "Size:"
    ::my::entry $S(W).efont -textvariable ::ChooseFont::S(font) ;# -state disabled
    ::my::entry $S(W).estyle -textvariable ::ChooseFont::S(style) ;# -state disabled
    ::my::entry $S(W).esize -textvariable ::ChooseFont::S(size) -width 0 \
	-validate key -validatecommand {string is double %P}

    ::ttk::scrollbar $S(W).sbfonts -command [list $S(W).lfonts yview]
    listbox $S(W).lfonts -listvariable ::ChooseFont::S(fonts) -height 7 \
	-yscroll [list $S(W).sbfonts set] -height 7 -exportselection 0
    #::Display::TileBGFix $S(W).lfonts
    listbox $S(W).lstyles -listvariable ::ChooseFont::S(styles) -height 7 \
	-exportselection 0
    #::Display::TileBGFix $S(W).lstyles
    ::ttk::scrollbar $S(W).sbsizes -command [list $S(W).lsizes yview]
    listbox $S(W).lsizes -listvariable ::ChooseFont::S(sizes) \
	-yscroll [list $S(W).sbsizes set] -width 6 -height 7 -exportselection 0
    #::Display::TileBGFix $S(W).lsizes

    bind $S(W).lfonts <<ListboxSelect>> [list ::ChooseFont::Click font]
    bind $S(W).lstyles <<ListboxSelect>> [list ::ChooseFont::Click style]
    bind $S(W).lsizes <<ListboxSelect>> [list ::ChooseFont::Click size]

    set WE $S(W).effects
    ::my::labelframe $WE -text "Effects"
    ::ttk::checkbutton $WE.strike -variable ::ChooseFont::S(strike) \
	-text Strikeout -command [list ::ChooseFont::Click strike]
    ::ttk::checkbutton $WE.under -variable ::ChooseFont::S(under) \
	-text Underline -command [list ::ChooseFont::Click under]

    ::ttk::button $S(W).ok -text OK -command [list ::ChooseFont::Done 1]
    ::ttk::button $S(W).cancel -text Cancel -command [list ::ChooseFont::Done 0]

    grid $S(W).font - x $S(W).style - x $S(W).size - x -sticky w
    grid $S(W).efont - x $S(W).estyle - x $S(W).esize - x $S(W).ok -sticky ew
    grid $S(W).lfonts $S(W).sbfonts x \
	$S(W).lstyles - x \
	$S(W).lsizes $S(W).sbsizes x \
	$S(W).cancel -sticky news
    grid config $S(W).cancel -sticky n -pady 5
    grid columnconfigure $S(W) {2 5 8} -minsize 10
    grid columnconfigure $S(W) {0 3 6} -weight 1

    grid $WE.strike -sticky w -padx 10
    grid $WE.under -sticky w -padx 10
    grid columnconfigure $WE 1 -weight 1
    grid $WE - x -sticky news -row 100 -column 0

    set WS $S(W).sample
    ::my::labelframe $WS -text "Sample"
    ::my::label $WS.fsample
    ::my::label $WS.fsample.sample -text "AaBbYyZz" -anchor c \
	-borderwidth 2 -relief sunken
    set S(sample) $WS.fsample.sample
    pack $WS.fsample -fill both -expand 1 -padx 10 -pady 10 -ipady 15
    pack $WS.fsample.sample -fill both -expand 1
    pack propagate $WS.fsample 0

    grid rowconfigure $S(W) 2 -weight 1
    grid rowconfigure $S(W) 99 -minsize 30
    grid $WS - - - - -sticky news -row 100 -column 3
    grid rowconfigure $S(W) 101 -minsize 30

    ::Data::UniqueTrace ::ChooseFont::S(size)  ::ChooseFont::Tracer
    ::Data::UniqueTrace ::ChooseFont::S(style) ::ChooseFont::Tracer
    ::Data::UniqueTrace ::ChooseFont::S(font)  ::ChooseFont::Tracer
    ::ChooseFont::Init $defaultFont
    tkwait window $S(W)
    return $S(result)
}
##+##########################################################################
#
# ::ChooseFont::Done -- called when exiting the choose font dialog
#
proc ::ChooseFont::Done {ok} {
    foreach var {size style font} {
	::Data::UniqueTrace ::ChooseFont::S($var)
    }

    if {! $ok} {set ::ChooseFont::S(result) ""}	;# Cancel, so clear the result
    destroy $::ChooseFont::S(W)
}
##+##########################################################################
#
# ::ChooseFont::Init -- initializes variables to a default font
#
proc ::ChooseFont::Init {{defaultFont ""}} {
    variable S

    if {$S(first) || $defaultFont ne ""} {
	if {$defaultFont eq ""} {
	    set defaultFont [[::tk::entry .___e] cget -font]
	    destroy .___e
	}
	array set F [font actual $defaultFont]
	set S(font) $F(-family)
	set S(size) $F(-size)
	set S(strike) $F(-overstrike)
	set S(under) $F(-underline)
	set S(style) "Regular"
	if {$F(-weight) eq "bold" && $F(-slant) eq "italic"} {
	    set S(style) "Bold Italic"
	} elseif {$F(-weight) eq "bold"} {
	    set S(style) "Bold"
	} elseif {$F(-slant) eq "italic"} {
	    set S(style) "Italic"
	}

	set S(first) 0
    }

    ::ChooseFont::Tracer a b c
    ::ChooseFont::Show
}
##+##########################################################################
#
# ::ChooseFont::Click -- handles selecting in a listbox
#
proc ::ChooseFont::Click {who} {
    variable S

    if {$who eq "font"} {
	set S(font) [$S(W).lfonts get [$S(W).lfonts curselection]]
    } elseif {$who eq "style"} {
	set S(style) [$S(W).lstyles get [$S(W).lstyles curselection]]
    } elseif {$who eq "size"} {
	set S(size) [$S(W).lsizes get [$S(W).lsizes curselection]]
    }
    ::ChooseFont::Show
}
##+##########################################################################
#
# ::ChooseFont::Tracer -- handles typing in a font name, style or size.
#
proc ::ChooseFont::Tracer {var1 var2 op} {
    variable S

    set bad 0
    set nstate normal
    # Make selection in each listbox
    foreach var {font style size} {
	set value [string tolower $S($var)]
	$S(W).l${var}s selection clear 0 end
	set n [lsearch -exact $S(${var}s,lcase) $value]
	$S(W).l${var}s selection set $n
	if {$n != -1} {
	    set S($var) [lindex $S(${var}s) $n]
	    $S(W).e$var icursor end
	    $S(W).e$var selection clear
	} else {                                ;# No match, try prefix
	    # Size is weird: valid numbers are legal but don't display
	    # unless in the font size list
	    set n [lsearch -glob $S(${var}s,lcase) "$value*"]
	    set bad 1
	    if {$var ne "size" || ! [string is double -strict $value]} {
		set nstate disabled
	    }
	}
	$S(W).l${var}s see $n
    }
    if {! $bad} ::ChooseFont::Show
    $S(W).ok config -state $nstate
}
##+##########################################################################
#
# ::ChooseFont::Show -- displays the currently selected font
#
proc ::ChooseFont::Show {} {
    variable S

    set S(result) [list $S(font) $S(size)]
    if {$S(style) eq "Bold"} { lappend S(result) bold }
    if {$S(style) eq "Italic"} { lappend S(result) italic }
    if {$S(style) eq "Bold Italic"} { lappend S(result) bold italic}
    if {$S(strike)} { lappend S(result) overstrike}
    if {$S(under)} { lappend S(result) underline}

    $S(sample) config -font $S(result)
}
## EON CHOOSEFONT
## BON WEATHER
##+##########################################################################
#
# ::Weather::Toggle -- Toggles showing or destroying the Weather Dialog
#
proc ::Weather::Toggle {} {
    if {! $::state(weather)} {
	destroy $::Weather::W
    } else {
	::Weather::Dialog region
    }
}
##+##########################################################################
#
# ::Weather::Dialog -- Creates dialog for current weather forecast
#
proc ::Weather::Dialog {what args} {
    variable S

    if {! [::Data::CanDo weather]} {
	.m.view entryconfigure "Weather Forecast..." -state disabled
	return
    }

    if {$what eq "node"} {
	set nid [lindex $args 0]
	foreach {. . lat lon} $::nodes($nid) break
	set lon [expr {-$lon}]
    } elseif {$what eq "region"} {
	foreach {lat0 lon0 lat1 lon1} [::Display::GetBounds] break
	set lat [expr {($lat0+$lat1)/2}]
	set lon [expr {($lon0+$lon1)/2}]
	set lon [expr {-$lon}]
    }
    set S(lat) $lat
    set S(lon) $lon
    set n [::Weather::Go $lat $lon]
    if {! $n} {return [WARN $S(status)]}
    ::Weather::_Dialog
}
##+##########################################################################
#
# ::Weather::CanDo -- Makes sure all the packages needed for weather are loaded
#
proc ::Weather::CanDo {{noWarn 0}} {
    global state

    if {[info exists state(can,weather)]} { return "" }

    set state(can,weather) 0			;# Assume we can't
    set emsg ""
    if {! [::Data::CanDo internet]} {
	set emsg "The weather feature requires the http package"
    } elseif {! [::Data::CanDo tdom]} {
	set emsg "The weather feature requires the tdom package"
    } elseif {! [::Data::CanDo jpeg]} {
	set emsg "The weather feature requires the Img package"
    }
    if {$emsg ne ""} {
	if {! $noWarn} { WARN $emsg }
	return $emsg
    }
    set state(can,weather) 1
    return ""
}
##+##########################################################################
#
# ::Weather::_Dialog -- creates actual dialog once XML has been processed
#
proc ::Weather::_Dialog {} {
    variable S
    variable W
    variable FORECAST

    set WB $W.body
    set WBTN $W.buttons
    set parent .
    set wtitle "NOAA Weather Forecast"
    set title "$wtitle\n$::state(region,pretty2)\n$FORECAST(when)"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::noaa noaa.gif]
    set ::state(weather) 1
    wm transient $W $parent
    wm protocol $W WM_DELETE_WINDOW ::Weather::_Close

    ::ttk::button $WBTN.cancel -text Close -command ::Weather::_Close
    bind .noaa <Control-w> ::Weather::_Close
    ::Display::GridChildren $WBTN 0

    set WNB $WB.nb
    ttk::notebook $WNB -padding 6
    ttk::notebook::enableTraversal $WNB
    pack $WNB -side top -fill both -expand 1
    set WFC $WNB.s1
    ::ttk::frame $WFC -pad 10
    $WNB add $WFC -text "Forecast"
    ::Weather::DrawForecast $WFC
    set WTMP $WNB.s2
    canvas $WTMP -bd 0 -highlightthickness 0 -width 600 -height 350
    $WNB add $WTMP -text "Temperatures"
    after idle [list ::Weather::Temp::Go $WTMP $S(lat) $S(lon)]

    ::Display::CenterWindow $W $parent
    wm deiconify $W
}
##+##########################################################################
#
# ::Weather::DrawForecast -- Draws our forecast display in frame $WB
#
proc ::Weather::DrawForecast {WB} {
    variable FORECAST

    # Fill in weather dialog
    set row 0
    set col 0
    set first 1
    foreach id $FORECAST(ids) {
	if {$FORECAST($id,summary) eq "?"} continue
	if {$FORECAST($id,summary) eq "?"} break
	set tname $FORECAST($id,tname)

	set WF $WB.col$id
	::my::frame $WF

	::my::label $WF.name -text $tname -font boldFont
	::my::label $WF.icon -relief ridge -image \
	    [::Weather::DownloadIcon $FORECAST($id,icon) $WF.icon]

	if {[regexp -nocase "night" $tname]} {
	    set txt "Low [::Data::TempConvert $FORECAST($id,min)]\xB0"
	    set isNight 1
	} else {
	    set txt "High [::Data::TempConvert $FORECAST($id,max)]\xB0"
	    set isNight 0
	}
	append txt "\n$FORECAST($id,rain)%"
	append txt "\n$FORECAST($id,summary)"
	::my::label $WF.txt -text $txt -wraplength 100 -anchor c -justify c

	# If first item is night, then push next item to next column
	if {$first && ($tname eq "Early Morning" || $isNight)} {
	    set row 1
	}
	grid $WF -row $row -column $col -sticky news
	grid columnconfigure $WB $col -uniform a -weight 1
	eval pack [winfo child $WF] -side top
	update

	if {[incr row] > 1} {
	    incr col
	    set row 0
	}
	set first 0
    }
}
##+##########################################################################
#
# ::Weather::_Close -- Cleans up after the weather dialog
#
proc ::Weather::_Close {} {
    variable W
    set ::state(weather) 0
    destroy $W
}
##+##########################################################################
#
# ::Weather::Go -- Gets weather data and parses it
#
proc ::Weather::Go {lat lon} {
    variable S

    set url [::Weather::GetUrl $lat $lon]

    set parent .
    set wtitle "Querying NOAA Weather Forecast"
    set title "$wtitle\n$::state(region,pretty2)"
    set icon [list ::img::noaa noaa.gif]

    # Repeat twice because NOAA is flaky at times
    set n 0
    for {set i 0} {$i < 2} {incr i} {
	set token [::URL::GetURL $url $parent $wtitle $title $icon]

	set ncode [::http::ncode $token]
	if {$ncode != 200} {
	    ::http::cleanup $token
	    set S(status) "Bad response from NOAA: $ncode"
	    continue
	}

	set S(xml) [::http::data $token] ; list
	::http::cleanup $token

	set n [::Weather::ParseNOAAXML]
	if {$n} break
    }
    return $n
}
##+##########################################################################
#
# ::Weather::GetUrl -- Returns url to the weather webserver
#
proc ::Weather::GetUrl {lat lon} {
    variable S

    set startdate [clock format [clock scan now] -format "%Y-%m-%d"]
    set url $S(url)
    append url "?lat=$lat&lon=$lon&format=$S(format)&startDate=$startdate"
    append url "&numDays=$S(days)&Submit=Submit"
    set S(url,actual) $url

    return $url
}
##+##########################################################################
#
# ::Weather::ParseNOAAXML -- extracts info out of NOAA forecast XML
#
proc ::Weather::ParseNOAAXML {} {
    variable S
    variable W

    set n [catch {dom parse $S(xml) doc}]
    if {$n} {
	set S(status) "Bad xml reply from NOAA"
	# see S(xml) and S(url,actual)
	return 0
    }
    set root [$doc documentElement]
    if {[$root nodeName] ne "dwml"} {
	set S(status) "Bad reply from NOAA\n\nroot node is '[$root nodeName]'"
	unset doc
	return 0
    }
    ::Weather::ReadTimeLayouts $root
    ::Weather::GetWeather $root
    ::Weather::GetTemperatures $root
    ::Weather::GetPrecipitation $root
    ::Weather::GetIcons $root

    ::Weather::Normalize

    unset doc
    return 1
}
##+##########################################################################
#
# ::Weather::ReadTimeLayouts -- extracts time interval info
#
proc ::Weather::ReadTimeLayouts {root} {
    variable NOAA

    unset -nocomplain NOAA

    set dnodes [$root selectNodes /dwml/data/time-layout]
    foreach node $dnodes {
	set key [[$node selectNodes layout-key/text()] data]
	set NOAA($key,summary) [$node getAttribute summarization "???"]

	set starts [$node selectNodes start-valid-time]
	set ends [$node selectNodes end-valid-time]
	set cnt -1
	foreach start $starts end $ends {
	    incr cnt

	    set name ""
	    set etime ""
	    if {[$start hasAttribute period-name]} {
		set name [$start getAttribute period-name "???"]
	    }
	    set stime [[$start firstChild] data]
	    if {$end ne ""} {
		set etime [[$end firstChild] data]
	    }

	    set NOAA($key,$cnt,name) $name
	    set NOAA($key,$cnt,start) $stime
	    set NOAA($key,$cnt,end) $etime
	}
    }
}
##+##########################################################################
#
# ::Weather::GetWeather -- extracts weather summary
#
proc ::Weather::GetWeather {root} {
    variable NOAA

    array unset NOAA *weather*
    set node [$root selectNodes /dwml/data/parameters/weather]

    set key [$node getAttribute time-layout]
    set NOAA(weather,key) $key

    set cnt -1
    foreach value [$node selectNodes weather-conditions] {
	incr cnt
	set NOAA($key,$cnt,weather,summary) \
	    [$value getAttribute weather-summary "?"]
    }
}
##+##########################################################################
#
# ::Weather::GetTemperatures -- Extracts min and max temperature info
#
proc ::Weather::GetTemperatures {root} {
    variable NOAA

    array unset NOAA *temp*
    set dnodes [$root selectNodes /dwml/data/parameters/temperature]
    foreach node $dnodes {
	set type [$node getAttribute type]
	set units [$node getAttribute units]
	set key [$node getAttribute time-layout]
	set NOAA(temp,$type,key) $key
	set NOAA(temp,$type,units) $units

	set vnodes [$node selectNodes value]
	for {set cnt 0} {$cnt < [llength $vnodes]} {incr cnt} {
	    set vnode [lindex $vnodes $cnt]
	    set temp "?"
	    if {[$vnode hasChildNodes]} {
		set temp [[$vnode firstChild] data]
	    }
	    set NOAA($key,$cnt,temp,$type) $temp
	}
    }
}
##+##########################################################################
#
# ::Weather::GetPrecipitation -- Extracts probability of rain info
#
proc ::Weather::GetPrecipitation {root} {
    variable NOAA

    array unset NOAA *rain*
    set node [$root selectNodes /dwml/data/parameters/probability-of-precipitation]

    set units [$node getAttribute units]
    set key [$node getAttribute time-layout]
    set NOAA(rain,key) $key
    set NOAA(rain,units) $units

    set vnodes [$node selectNodes value]
    for {set cnt 0} {$cnt < [llength $vnodes]} {incr cnt} {
	set vnode [lindex $vnodes $cnt]
	set rain "?"
	if {[$vnode hasChildNodes]} {
	    set rain [[$vnode firstChild] data]
	}
	set NOAA($key,$cnt,rain) $rain
    }
}
##+##########################################################################
#
# ::Weather::GetIcons -- Extracts weather icon url
#
proc ::Weather::GetIcons {root} {
    variable NOAA

    set node [$root selectNodes /dwml/data/parameters/conditions-icon]
    set key [$node getAttribute time-layout]
    set NOAA(icon,key) $key

    set dnodes [$node selectNodes icon-link]
    for {set cnt 0} {$cnt < [llength $dnodes]} {incr cnt} {
	set url ""
	set inode [lindex $dnodes $cnt]
	if {[$inode hasChildNodes]} {
	    set url [[$inode firstChild] data]
	}
	set NOAA($key,$cnt,icon) $url
    }
}
##+##########################################################################
#
# ::Weather::Normalize -- Puts all XML data into FORECAST array
#
proc ::Weather::Normalize {} {
    variable NOAA
    variable FORECAST

    unset -nocomplain FORECAST

    set key $NOAA(weather,key)
    set key2 $NOAA(temp,maximum,key)
    set key3 $NOAA(temp,minimum,key)

    set names [lsort -dictionary [array names NOAA $key,*,weather,summary]]
    foreach arr $names {
	set id [lindex [split $arr ","] 1]
	set id2 [expr {$id/2}]

	lappend FORECAST(ids) $id
	set FORECAST($id,summary) $NOAA($key,$id,weather,summary)
	set FORECAST($id,tname) $NOAA($key,$id,name)
	set FORECAST($id,start) $NOAA($key,$id,start)
	set FORECAST($id,icon) $NOAA($key,$id,icon)
	set FORECAST($id,rain) $NOAA($key,$id,rain)
	set FORECAST($id,max) $NOAA($key2,$id2,temp,maximum)
	set FORECAST($id,min) $NOAA($key3,$id2,temp,minimum)
    }
    set when $FORECAST([lindex $FORECAST(ids) 0],start)
    set ticks [clock scan "[string range $when 0 9] [string range $when 11 18]"]
    set pretty [clock format $ticks -format "%b %d, %Y %l:%M %p"]
    set FORECAST(when) $pretty
}
##+##########################################################################
#
# ::Weather::DownloadIcon -- Makes icon image for weather, downloading if needed
#
proc ::Weather::DownloadIcon {url widget} {
    if {$url eq ""} {return ::img::noaa}
    set tail [file tail $url]
    set tail2 [file join $::state(idir) noaa $tail]
    set sname [file rootname [file tail $url]]
    set iname ::img::noaa::$sname

    if {[lsearch [image names] $iname] == -1} {
	if {[file exists $tail2]} {
	    image create photo $iname -file $tail2
	} else {
	    image create photo $iname -width 55 -height 58
	    $iname copy ::img::noaa
	    ::http::geturl $url -command \
		[list ::Weather::DownloadIcon_Callback $iname $tail $widget]
	}
    }

    return $iname
}
##+##########################################################################
#
# ::Weather::DownloadIcon_Callback -- http callback for downloading icons
#
proc ::Weather::DownloadIcon_Callback {iname tail widget token} {
    set ncode [::http::ncode $token]

    if {[::http::ncode $token] != 200} {
	::http::cleanup $token
	#error "bad http ncode for $iname"
	return
    }
    $iname config -data [::http::data $token]
    $widget config -image $iname
    ::http::cleanup $token

    set noaaDir [file join $::state(idir) noaa]
    set fname [file join $noaaDir $tail]

    if {[file exists $fname]} return

    if {! [file isdirectory $noaaDir]} {
	catch {file mkdir $noaaDir}
    }
    if {! [file isdirectory $noaaDir]} return
    #catch { $iname write $tail }
    $iname write $fname -format jpeg
    INFO "downloaded and saved $tail"
}
## EON WEATHER
## BON WEATHER::TEMPS
##+##########################################################################
#
# ::Weather::Temp::Go -- Gets NOAA temperature info and displays in
# canvas $W
#
proc ::Weather::Temp::Go {W lat lon} {
    variable S

    set n [::Weather::Temp::GetNOAATemp $lat $lon]
    if {$n} {
	::Weather::Temp::GetPlotData
	::Weather::Temp::DrawTempGraph $W
    } else {
	::Weather::Temp::ErrorMessage $W $S(status)
    }
}
##+##########################################################################
#
# ::Weather::Temp::DrawTempGraph -- Draws temperature graph in canvas $W
#
proc ::Weather::Temp::DrawTempGraph {W} {

    if {! [winfo exists $W]} {
	canvas $W -width 700 -bg yellow -bd 2 -relief ridge -highlightthickness 0
	pack $W -side top -fill both -expand 1
	bind $W <Configure> [list ::Weather::Temp::DrawTempGraph $W]
    } else {
	$W delete all
	::Weather::Temp::GetScaling $W
	::Weather::Temp::DrawAxis $W
	::Weather::Temp::PlotTemps $W
    }

}
##+##########################################################################
#
# ::Weather::Temp::PlotTemps -- Draws temperature line and data points
#
proc ::Weather::Temp::PlotTemps {W} {
    variable PLOT

    set xy [::Weather::Temp::Pos2Canvas $PLOT(xy)]
    $W create line $xy
    foreach {x y} $xy {
	set box [::Display::MakeBox [list $x $y] 5]
        $W create oval $box -fill red -outline red
    }
}
##+##########################################################################
#
# ::Weather::Temp::GetScaling -- Determine pos2canvas scaling info
#
proc ::Weather::Temp::GetScaling {W} {
    variable PLOT
    variable M

    set w [winfo width $W]
    set h [winfo height $W]
    if {$w < 5} {
	set w [winfo reqwidth $W]
	set h [winfo reqheight $W]
    }
    set w2 [expr {$w - $M(lm) - $M(rm)}]
    set h2 [expr {$h - $M(tm) - $M(bm)}]
    set PLOT(sx) [expr {$w2 / double($PLOT(x,max)-$PLOT(x,min))}]
    set PLOT(sy) [expr {$h2 / double($PLOT(y,max)-$PLOT(y,min))}]
    set PLOT(ox) $M(lm)
    set PLOT(oy) [expr {$h - $M(bm)}]
}
##+##########################################################################
#
# ::Weather::Temp::Pos2Canvas -- Converts time,temperature position to canvas
#
proc ::Weather::Temp::Pos2Canvas {args} {
    variable PLOT

    if {[llength $args] == 1} { set args [lindex $args 0] }
    set xy {}
    foreach {x y} $args {
	set xx [expr {$PLOT(ox) + $PLOT(sx)*($x - $PLOT(x,min))}]
	set yy [expr {$PLOT(oy) - $PLOT(sy)*($y - $PLOT(y,min))}]
	lappend xy $xx $yy
    }
    return $xy
}
##+##########################################################################
#
# ::Weather::Temp::DrawAxis -- Draws background grid, axis and labels
#
proc ::Weather::Temp::DrawAxis {W} {
    variable PLOT
    variable M

    set xy [::Weather::Temp::Pos2Canvas $PLOT(x,max) $PLOT(y,max) $PLOT(x,min) $PLOT(y,min)]
    lassign $xy x1 y1 x0 y0
    $W create rect $xy -fill lightblue

    # Y axis and labels
    set x0 [expr {$PLOT(ox)-5}] 		;# Left end of tick mark
    for {set y $PLOT(y,min)} {$y <= $PLOT(y,max)} {incr y $PLOT(y,tick)} {
	set yy [lindex [Pos2Canvas $PLOT(x,min) $y] 1]
	$W create text $x0 $yy -text "$y\xB0 " -anchor e
	$W create line $x0 $yy $x1 $yy
    }
    if {32 >= $PLOT(y,min) && 32 <= $PLOT(y,max)} {
	set yy [lindex [::Weather::Temp::Pos2Canvas $PLOT(x,min) 32] 1]
	$W create line $PLOT(ox) $yy $x1 $yy -fill red -width 2 -dash 1
    }

    # X axis and labels
    set day -1
    for {set x $PLOT(x,min)} {$x <= $PLOT(x,max)} {incr x $PLOT(x,tick)} {
	incr day
	set xx [lindex [::Weather::Temp::Pos2Canvas $x $PLOT(y,min)] 0]

        set ticks [expr {$PLOT(basetime) + int($day)*60*60*24}]
        set n [$W create text $xx $y0 -anchor n -text [clock format $ticks -format "%a"]]
	if {$x == 0} { $W itemconfig $n -anchor nw}

	$W create line $xx $y0 $xx $y1
	set x2 [expr {$x+12}]			;# Noon
	if {$x2 <= $PLOT(x,max)} {
	    set xx [lindex [::Weather::Temp::Pos2Canvas $x2 $PLOT(y,min)] 0]
	    $W create line $xx $y0 $xx $y1 -fill black -dash 1 -width 1
	}
    }
}
##+##########################################################################
#
# ::Weather::Temp::GetNOAATemp -- Gets and parses NOAA temperature XML data
#
proc ::Weather::Temp::GetNOAATemp {lat lon {XML ""}} {
    variable S

    if {$XML ne ""} {
        set xml $XML
    } else {
        set xml [::Weather::Temp::GetTempForecastXML $lat $lon]
	if {$xml eq ""} {return 0}
    }
    set S(xml) $xml

    set n [catch {dom parse $xml doc}]
    if {$n} {
	set S(status) "Error: Bad xml reply from NOAA"
	# see S(xml) and S(url)
	return 0
    }
    set root [$doc documentElement]
    if {[$root nodeName] ne "dwml"} {
	set S(status) "Error: Bad reply from NOAA\n\nroot node is '[$root nodeName]'"
	unset doc
	return 0
    }
    ::Weather::Temp::ReadTimeLayouts $root
    ::Weather::Temp::GetTemperatures $root

    unset doc
    return 1
}
##+##########################################################################
#
# ::Weather::Temp::GetTempForecastXML -- Fetches NOAA temperature xml data
#
proc ::Weather::Temp::GetTempForecastXML {lat lon} {
    variable S

    set LAT $lat
    set LON $lon
    set BEGINDATE [clock format [clock scan now] -format "%Y-%m-%d"]
    set ENDDATE [clock format [clock scan "now + $S(days) days"] -format "%Y-%m-%d"]

    set params [subst -nobackslashes -nocommands $S(url,temp,parameters)]
    set S(url) "$S(url,temp)$params"

    #set token [::http::geturl $S(url)]
    set token [::URL::GetUrlFollowRedirects $S(url)]
    ::http::wait $token

    set ncode [::http::ncode $token]
    if {$ncode != 200} {
	::http::cleanup $token
	set S(status) "Error: Bad response from NOAA: $ncode"
	return ""
    }

    set xml [::http::data $token] ; list
    ::http::cleanup $token

    return $xml
}
##+##########################################################################
#
# ::Weather::Temp::ReadTimeLayouts -- Parses time info from NOAA temperature xml data
#
proc ::Weather::Temp::ReadTimeLayouts {root} {
    variable WEATHER

    unset -nocomplain WEATHER

    set nodes [$root selectNodes /dwml/data/time-layout]
    foreach node $nodes {
        set key [[$node selectNodes layout-key/text()] data]
        set WEATHER($key,summary) [$node getAttribute summarization "???"]

        set starts [$node selectNodes start-valid-time]
        set cnt -1
        foreach start $starts {
            incr cnt

            set name ""
            if {[$start hasAttribute period-name]} {
                set name [$start getAttribute period-name "???"]
            }
            set stime [[$start firstChild] data]
            set WEATHER($key,$cnt,name) $name
            set WEATHER($key,$cnt,start) $stime
        }
    }
}
##+##########################################################################
#
# ::Weather::Temp::GetTemperatures -- Parses temperature from NOAA xml data
#
proc ::Weather::Temp::GetTemperatures {root} {
    variable WEATHER
    variable S

    array unset WEATHER *temp*
    set nodes [$root selectNodes /dwml/data/parameters/temperature]
    foreach node $nodes {
        set type [$node getAttribute type]
        set units [$node getAttribute units]
        set key [$node getAttribute time-layout]
        set WEATHER(temp,$type,key) $key
        set WEATHER(temp,$type,units) $units

        set vnodes [$node selectNodes value]
        for {set cnt 0} {$cnt < [llength $vnodes]} {incr cnt} {
            set vnode [lindex $vnodes $cnt]
            set temp "?"
            if {[$vnode hasChildNodes]} {
                set temp [[$vnode firstChild] data]
            }
            set WEATHER($key,$cnt,temp,$type) $temp
        }
    }
}
##+##########################################################################
#
# ::Weather::Temp::GetPlotData -- Consolidates all temperature data
#
proc ::Weather::Temp::GetPlotData {} {
    variable PLOT
    variable WEATHER

    unset -nocomplain PLOT
    set key $WEATHER(temp,hourly,key)
    set basetime 0

    set X {}
    set Y {}
    set xy {}
    foreach arr [lsort -dictionary [array names WEATHER $key,*,temp,hourly]] {
        set idx [lindex [split $arr ","] 1]
        set ticks [::Weather::Temp::ScanTime $WEATHER($key,$idx,start)]
        if {$idx == 0} {
            set basetime [::Weather::Temp::ScanTime \
			      [string range $WEATHER($key,$idx,start) 0 9]]
        }
	set temp [::Data::TempConvert $WEATHER($key,$idx,temp,hourly)]
	lappend xy [expr {($ticks - $basetime)/60/60}] $temp
	lappend X [expr {($ticks - $basetime)/60/60}]
        lappend Y $temp
    }
    ;# Compute Y axis
    set y_sort [lsort -real $Y]
    set ys [::Weather::Temp::determineScale [lindex $y_sort 0] [lindex $y_sort end]]

    set min 0
    set max [lindex $X end]
    set delta [expr {$max - $min}]
    if {$delta/24 != $delta/24.0} { set max [expr {$min + 24*(1+$delta/24)}]}
    set xs [list $min $max 24]

    set Xticks {}
    foreach {a b c} $xs break
    while {$a <= $b} {
        lappend Xticks $a
        incr a $c
    }
    set Yticks {}
    foreach {a b c} $ys break
    while {$a <= $b} {
        lappend Yticks $a
        incr a $c
    }

    set PLOT(xy) $xy
    lassign $xs PLOT(x,min) PLOT(x,max) PLOT(x,tick)
    lassign $ys PLOT(y,min) PLOT(y,max) PLOT(y,tick)
    set PLOT(YText) $WEATHER(temp,hourly,units)
    set PLOT(basetime) $basetime
}
##+##########################################################################
#
# ::Weather::Temp::determineScale -- Determine axis scale (from Plotchart package)
#
proc ::Weather::Temp::determineScale { xmin xmax {inverted 0} } {
    # From Plotchart::determineScale
    set dx [expr {abs($xmax-$xmin)}]

    if { $dx == 0.0 } {
	if { $xmin == 0.0 } {
	    return [list -0.1 0.1 0.1]
	} else {
	    set dx [expr {0.2*abs($xmax)}]
	    set xmin [expr {$xmin-0.5*$dx}]
	    set xmax [expr {$xmin+0.5*$dx}]
	}
    }

    #
    # Very small ranges (relatively speaking) cause problems
    # The range must be at least 1.0e-8
    #
    if { $dx < 0.5e-8*(abs($xmin)+abs($xmax)) } {
	set xmean [expr {0.5*($xmin+$xmax)}]
	set dx    [expr {1.0e-8*$xmean}]
	set xmin  [expr {$xmean - 0.5*$dx}]
	set xmax  [expr {$xmean + 0.5*$dx}]
    }

    #
    # Determine the factor of 10 so that dx falls within the range 1-10
    #
    set expon  [expr {int(log10($dx))}]
    set factor [expr {pow(10.0,$expon)}]

    set dx     [expr {$dx/$factor}]

    foreach {limit step} {1.4 0.2 2.0 0.5 5.0 1.0 10.0 2.0} {
	if { $dx < $limit } {
	    break
	}
    }

    set fmin    [expr {$xmin/$factor/$step}]
    set fmax    [expr {$xmax/$factor/$step}]
    #  if { abs($fmin) > 1.0e10 } {
    #      set fmin [expr {$fmin > 0.0 ? 1.0e10 : -1.0e10}]
    #  }
    #  if { abs($fmax) > 1.0e10 } {
    #      set fmax [expr {$fmax > 0.0 ? 1.0e10 : -1.0e10}]
    #  }
    set nicemin [expr {$step*$factor*wide($fmin)}]
    set nicemax [expr {$step*$factor*wide($fmax)}]

    if {$nicemax < $xmax} {
	set nicemax [expr {$nicemax+$step*$factor}]
    }
    if {$nicemin > $xmin} {
	set nicemin [expr {$nicemin-$step*$factor}]
    }
    set nicemin [expr {int($nicemin)}]
    set nicemax [expr {int($nicemax)}]

    if { !$inverted } {
	return [list $nicemin $nicemax [expr {int($step*$factor)}]]
    } else {
	return [list $nicemax $nicemin [expr {int(-$step*$factor)}]]
    }
}
##+##########################################################################
#
# ::Weather::Temp::ScanTime -- Converts time string to seconds
#
proc ::Weather::Temp::ScanTime {when} {
    #2007-01-25T19:00:00-05:00
    set ticks [clock scan "[string range $when 0 9] [string range $when 11 18]"]
    return $ticks
}
##+##########################################################################
#
# ::Weather::Temp::ErrorMessage -- Displays an error message
#
proc ::Weather::Temp::ErrorMessage {W emsg} {
    if {! [winfo exists $W]} return
    $W delete all
    set x [expr {[winfo width $W]/2}]
    set y [expr {[winfo height $W]/2}]
    $W create text $x $y -fill red -font bigBold -text $emsg
}
## EON WEATHER::TEMPS
## BON MILEPOST
##+##########################################################################
#
# ::MilePost::Go -- Displays all mileposts along the route
#
proc ::MilePost::Go {w} {
    global state msg

    ::MilePost::Clear $w
    if {! $state(milepost)} return

    set stepSize $state(m,interval)
    if {$stepSize eq "Auto"} {
	set stepSize 1
	if {$msg(dist2) > 10} { set stepSize 5 }
	if {$msg(dist2) > 40} { set stepSize 10 }
    }

    ::Trace::GetData [expr {$w eq ".c" ? "root" : "zoom"}]
    for {set i $stepSize} {$i < $msg(dist2)} {incr i $stepSize} {
	set miles [::Data::RConvert $i dist]
	foreach {x y .} [::Trace::Mile2Canvas $miles] break
	::MilePost::MakeMilePost $w $x $y $i
    }
}
##+##########################################################################
#
# ::MilePost::MakeMilePost -- creates one milepost marker
#
proc ::MilePost::MakeMilePost {w x y txt} {
    global state

    set sz $state(m,size)
    set font $state(m,font)
    if {$w eq ".zoom.c"} {
	set sz [expr {1.5*$state(m,size)}]
	foreach {family size} $state(m,font) break
	set font [list $family [expr {round(1.5*$size)}] bold]
    }

    set y0 [expr {$y - 3*$sz}]
    set y1 [expr {$y - 4}]
    set x1 [expr {$x+2}]
    set x2 [expr {$x-2}]

    set xy [::Display::MakeBox [list $x $y0] $sz]
    set xy2 [::Display::RegularPolygon $xy -sides 100 -start -60 -extent -300]
    set xy3 [concat $x $y $x $y1 $xy2 $x $y1 $x $y]
    $w create polygon $xy3 -tag milepost -outline black -fill $state(m,color)
    $w create text $x $y0 -tag milepost -text $txt -font $font
}
##+##########################################################################
#
# ::MilePost::Clear -- Clears all mileposts
#
proc ::MilePost::Clear {w} {
    if {[winfo exists $w]} {
	$w delete milepost
    }
}
## EON MILEPOST
## BON RINFO
##+##########################################################################
#
# ::RInfo::Dialog -- draws the region info dialog
#
proc ::RInfo::Dialog {} {
    variable RI

    ::RInfo::GetInfo				;# Fill in the values

    set W .rInfo
    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Route Information"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::bigInfo bigInfo.gif]
    wm protocol $W WM_DELETE_WINDOW ::RInfo::CloseDialog

    ::ttk::button $WBTN.dismiss -text Dismiss -command ::RInfo::CloseDialog
    ::Display::GridChildren $WBTN 0

    # Title
    set WT $WB.title
    ::my::frame $WT
    ::my::label $WT.title -text "Route Title:"
    ::my::entry $WT.etitle -textvariable ::route(title) -justify center
    pack $WT.title -side left
    pack $WT.etitle -side left -fill x -expand 1

    # Size data
    set WS $WB.size
    ::my::labelframe $WS -text "Vitals"
    ::my::label $WS.a0 -text "Distance:" -anchor w -width 15
    ::my::label $WS.a1 -textvariable ::RInfo::RI(dist)
    ::my::label $WS.b0 -text "Climbing:" -anchor w -width 15
    ::my::label $WS.b1 -textvariable ::RInfo::RI(climb)
    ::my::label $WS.c0 -text "Descending:" -anchor w -width 15
    ::my::label $WS.c1 -textvariable ::RInfo::RI(desc)
    grid columnconfigure $WS 0 -minsize 20
    grid columnconfigure $WS 2 -weight 1
    grid columnconfigure $WS 4 -minsize 5
    grid x $WS.a0 $WS.a1 -sticky ew
    grid x $WS.b0 $WS.b1 -sticky ew
    grid x $WS.c0 $WS.c1 -sticky ew

    # Extreme points
    set WX $WB.ext
    ::my::labelframe $WX -text "Extremes"
    ::my::label $WX.a0 -text "High Point:" -anchor w -width 15
    ::my::label $WX.a1 -textvariable ::RInfo::RI(max) -width 9
    ::ttk::button $WX.a2 -image ::img::star \
	-command [list ::RInfo::Locate max,data]
    ::my::label $WX.b0 -text "Low Point:" -anchor w -width 15
    ::my::label $WX.b1 -textvariable ::RInfo::RI(min)
    ::ttk::button $WX.b2 -image ::img::star \
	-command [list ::RInfo::Locate min,data]
    ::my::label $WX.c0 -text "Biggest Climb:" -anchor w -width 15
    ::my::label $WX.c1 -textvariable ::RInfo::RI(up)
    ::ttk::button $WX.c2 -image ::img::star \
	-command [list ::RInfo::Locate up,data]
    ::my::label $WX.d0 -text "Biggest Descent:" -anchor w -width 15
    ::my::label $WX.d1 -textvariable ::RInfo::RI(down)
    ::ttk::button $WX.d2 -image ::img::star \
	-command [list ::RInfo::Locate down,data]
    ::my::label $WX.e0 -text "Remotest:" -anchor w -width 15
    ::my::label $WX.e1 -textvariable ::RInfo::RI(remote)
    ::ttk::button $WX.e2 -image ::img::star \
	-command [list ::RInfo::Locate remote,data]
    grid columnconfigure $WX 0 -minsize 20
    grid columnconfigure $WX 2 -weight 1
    grid columnconfigure $WX 4 -minsize 5
    grid x $WX.a0 $WX.a1 $WX.a2 -sticky ew
    grid x $WX.b0 $WX.b1 $WX.b2 -sticky ew
    grid x $WX.c0 $WX.c1 $WX.c2 -sticky ew
    grid x $WX.d0 $WX.d1 $WX.d2 -sticky ew
    grid x $WX.e0 $WX.e1 $WX.e2 -sticky ew

    # Annotations
    set WA $WB.ann
    ::my::labelframe $WA -text "Annotations"
    ::ttk::checkbutton $WB.postit -variable ::Postit::Details(onoff) \
	-text "Add Annotations" -command [list ::RInfo::Postit $WA]
    grid columnconfigure $WA 0 -minsize 20
    grid columnconfigure $WA 3 -weight 1
    grid rowconfigure $WA 1000 -weight 1
    grid $WB.postit -in $WA -sticky w

    set buttons {rnames "Road Names" rdist "Road distances"
	rclimb "Road climbing"	nnames "Node names" nelev "Node Altitudes"
    }
    set s [expr {$::Postit::Details(onoff) ? "normal" : "disabled"}]
    foreach {var lbl} $buttons {
	::ttk::checkbutton $WA.$var -text $lbl \
	    -variable ::Postit::Details($var) \
	    -command ::Postit::DoRoute -state $s
	grid $WA.$var -padx 20 -sticky w
    }

    # Calories
    set WC $WB.cal
    ::Power::GUI $WC 1

    set WF $WB.buttons
    ::my::frame $WF
    ::ttk::button $WF.refresh -text Refresh -command ::RInfo::Refresh?
    ::ttk::button $WF.fav -text "Add to Favorites" -command ::Favorites::AppendRoute
    ::Display::GridChildren $WF 0

    grid columnconfigure $WB 1 -pad 0
    grid columnconfigure $WB 0 -weight 1
    grid forget $WS $WX $WA
    grid $WT - - -sticky ew -pady {5 15}
    grid $WS $WC $WA -sticky news -padx 5
    grid $WX ^ ^ -sticky news -padx 5
    grid $WF - - -sticky ew -padx 5

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::RInfo::Refresh? -- updates route info dialog if it exists
#
proc ::RInfo::Refresh? {} {
    if {[winfo exists .rInfo]} {
	::RInfo::GetInfo
	::Power::Refresh
    }
}
##+##########################################################################
#
# ::RInfo::CloseDialog -- cleans up our Info dialog
#
proc ::RInfo::CloseDialog {} {
    destroy .rInfo
    ::RInfo::Clear
    ::Power::Clear
}
##+##########################################################################
#
# ::RInfo::Clear -- clears all RInfo's droppings on the maps
#
proc ::RInfo::Clear {} {
    if {[winfo exists .c]} {
	.c delete rhill_up rhill_down
	::Display::HighlightNode2 -1
    }
    if {[winfo exists .pro.c]} { .pro.c delete rhill_up rhill_down }
}
##+##########################################################################
#
# ::RInfo::GetInfo -- extracts information about the current route
#
proc ::RInfo::GetInfo {} {
    variable RI
    global msg route roads nodes

    .c delete rhill_up rhill_down
    if {[winfo exists .pro.c]} { .pro.c delete rhill_up rhill_down }
    ::Display::HighlightNode2 -1

    ::RInfo::GetHillInfo
    set RI(dist) $msg(dist)
    set RI(climb) $msg(climb)
    set RI(desc) $msg(desc)

    set data [::Route::GetXYZ]
    set max [set min ?]
    if {$data ne {}} {
	set max [set min [lindex $data 0 7]]
    }
    set maxIdx [set minIdx 0]
    set home [lrange [lindex $data 0] 2 3]
    set dist 0
    set distIdx 0

    for {set i 0} {$i < [llength $data]} {incr i} {
	set ll [lrange [lindex $data $i] 2 3]
	set far [eval ::Data::Distance $home $ll]
	if {$far > $dist} {
	    set dist $far
	    set distIdx $i
	}

	set alt [lindex $data $i 1]
	if {[::BadMath::IsBad $alt]} continue
	if {$alt > $max} {
	    set max $alt
	    set maxIdx $i
	} elseif {$alt < $min} {
	    set min $alt
	    set minIdx $i
	}
    }
    set RI(max) [::Data::Units $max climb 0 2]
    set RI(max,data) [lindex $data $maxIdx]
    set RI(min) [::Data::Units $min climb]
    set RI(min,data) [lindex $data $minIdx]
    set RI(remote) [::Data::Units [Round1 $dist] dist 0 2]
    set RI(remote,data) [lindex $data $distIdx]
}
##+##########################################################################
#
# ::RInfo::GetHillInfo -- gets route hill information
#
proc ::RInfo::GetHillInfo {} {
    variable RI

    ::Hills::GrindTrack route			;# Put route into GPS track
    ::Hills::FindHills route 0 0

    set up 0
    set upData {}
    set down 0
    set downData {}
    foreach hill $::Hills::Hills(hills) {
	foreach {id low high delta dist sslope} $hill break
	if {$low <= $high && $delta > $up} {
	    set up $delta
	    set upData $id
	} elseif {$low >= $high && $delta > $down} {
	    set down $delta
	    set downData $id
	}
    }
    set RI(up) [::Data::Units $up climb 0 2]
    set RI(up,data) [list up $upData]
    set RI(down) [::Data::Units $down climb 0 2]
    set RI(down,data) [list down $downData]
}
##+##########################################################################
#
# ::RInfo::Locate -- highlights a position or hill specified
# by info stored in the RI(*,data) array
#
proc ::RInfo::Locate {who} {
    variable RI

    if {[llength $RI($who)] == 2} {		;# Hill
	foreach {dir id} $RI($who) break
	::Hills::DoOneHill $id rhill_$dir
	::Hills::SeeHill rhill_$dir
    } elseif {[llength $RI($who)] >= 4} {
	foreach {. . lat lon} $RI($who) break
	foreach {x y} [::Display::pos2canvas root $lat $lon] break
	set xy [::Display::ToCenter [list $x $y]]
	::Display::HighlightNode2 $xy
    }
}
##+##########################################################################
#
# ::RInfo::Postit -- toggles route annotations
#
proc ::RInfo::Postit {W} {
    ::Postit::DoRoute
    set s [expr {$::Postit::Details(onoff) ? "normal" : "disabled"}]
    foreach w [winfo child $W] {
	$w config -state $s
    }
}
## EON RINFO
## BON POWER
##+##########################################################################
#
# ::Power::Dialog -- Puts up our calorie calculator dialog
#
proc ::Power::Dialog {} {
    variable W

    set ::Power::W .cal
    destroy $W

    set WB $W.body
    set WBC $WB.c
    set WBTN $W.buttons
    set wtitle "$::state(progname) Calorie Calculator"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::calories calories.gif]
    wm protocol $W WM_DELETE_WINDOW ::Power::_TearDown

    ::ttk::button $WBTN.cancel -text Dismiss -command ::Power::_TearDown
    ::Display::GridChildren $WBTN 0

    ::Power::GUI $WBC 0
    pack $WBC -side top -fill both -expand 1
    ::Power::_ToggleTrace 1

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Power::_TearDown -- Cleans up the calorie calculator dialog
#
proc ::Power::_TearDown {} {
    catch {image delete ::img::calories}
    ::Power::Clear
    destroy $::Power::W
}
##+##########################################################################
#
# ::Power::GUI -- Displays calorie info into a supplied widget name
#
proc ::Power::GUI {w fixedRoute} {
    variable D
    variable U

    ::Power::Init
    set ::Power::w $w
    ::my::labelframe $w -text "Calorie Calculator" -pad {.1i 0}
    ::my::label $w.ldist -text "Distance"
    ::my::entry $w.edist -textvariable ::Power::D(dist) -width 6 -justify c \
	-validate key -validatecommand {string is double %P}
    if {$fixedRoute} { $w.edist config -state disabled }
    ::my::label $w.udist -textvariable ::Power::U(dist)
    ::my::label $w.lelev -text "Elevation gain"
    ::my::entry $w.eelev -textvariable ::Power::D(elev) -width 6 -justify c \
	-validate key -validatecommand {string is double %P}
    if {$fixedRoute} {$w.eelev config -state disabled}
    ::my::label $w.uelev -textvariable ::Power::U(climb)
    ::my::label $w.lhuman -text "Weight"
    ::my::entry $w.ehuman -textvariable ::Power::D(human) -width 6 -justify c \
	-validate key -validatecommand {string is double %P}
    ::my::label $w.uhuman -textvariable ::Power::U(weight)
    ::my::label $w.lbike -text "Bike weight"
    ::my::entry $w.ebike -textvariable ::Power::D(bike) -width 6 -justify c \
	-validate key -validatecommand {string is double %P}
    ::my::label $w.ubike -textvariable ::Power::U(weight)
    ::my::label $w.lwind -text "Headwind"
    ::my::entry $w.ewind -textvariable ::Power::D(headwind) -width 6 -justi c \
	-validate key -validatecommand {string is double %P}
    ::my::label $w.uwind -textvariable ::Power::U(speed)
    ::my::label $w.lposition -text "Riding position"
    ::ttk::combobox $w.eposition -values $::Power::FrontalArea(labels) \
	-width 8 -takefocus 0 \
	-state readonly -textvariable ::Power::D(position)


    grid $w.ldist $w.edist $w.udist -sticky w
    grid $w.lelev $w.eelev $w.uelev -sticky w
    grid $w.lhuman $w.ehuman $w.uhuman -sticky w
    grid $w.lbike $w.ebike $w.ubike -sticky w
    grid $w.lwind $w.ewind $w.uwind -sticky w
    grid $w.lposition $w.eposition - -sticky w


    ::ttk::separator $w.sep
    array unset ::Power::D speed,*
    ::my::frame $w.cal
    ::my::label $w.cal.title -text "Calories burned"
    grid $w.sep - - -sticky ew -pady .1i
    grid $w.cal - -sticky ew
    grid $w.cal.title - - - -sticky ew

    set speeds [expr {$::state(units,external) eq "metric" ? \
			$::Power::kphs : $::Power::mphs}]
    foreach speed $speeds {
	::my::label $w.cal.l$speed -text "@ $speed"
	::my::label $w.cal.u$speed -textvariable ::Power::U(speed)
	::my::label $w.cal.v$speed -anchor c -textvariable \
	    ::Power::D(speed,$speed,$U(speed))
	set D(speed,$speed,$U(speed)) "?"
	grid x $w.cal.l$speed $w.cal.u$speed $w.cal.v$speed -sticky we
    }
    grid columnconfigure $w.cal 0 -minsize .1i
    grid columnconfigure $w.cal 3 -weight 1

    ::Power::_ToggleTrace 1
    ::Power::Refresh
}
##+##########################################################################
#
# ::Power::Init -- Initializes GUI values from configurable values
# taking care to put things into external units
#
proc ::Power::Init {} {

    set reapplyTrace [::Power::_ToggleTrace 0]

    set ::Power::U(dist) [lindex [split [::Data::Label 1 dist 1] " "] 1]
    set ::Power::U(climb) [lindex [split [::Data::Label 1 climb 1] " "] 1]
    set ::Power::U(weight) [lindex [split [::Data::Label 1 weight 1] " "] 1]
    set ::Power::U(speed) "[string index $::Power::U(dist) 0]ph"

    set ::Power::D(human) [::Data::Convert $::state(calorie,human) weight]
    set ::Power::D(bike) [::Data::Convert $::state(calorie,bike) weight]
    set ::Power::D(position) $::state(calorie,position)
    set ::Power::D(headwind) 0
    set ::Power::D(temperature) $::state(calorie,temp,centigrade)
    set ::Power::D(dist) $::msg(dist2)
    set ::Power::D(elev) 0
    if {[llength $::route(nodes)] > 1} {
	set start [lindex $::nodes([lindex $::route(nodes) 0]) 1]
	set end [lindex $::nodes([lindex $::route(nodes) end]) 1]
	set elev [::BadMath::Real [::BadMath::Sub $end $start]]
	set ::Power::D(elev) [::Data::Convert $elev climb]
    }
    if {$reapplyTrace} {
	::Power::_ToggleTrace 1
    }
}
##+##########################################################################
#
# ::Power::Clear -- Handles tear down of our GUI
#
proc ::Power::Clear {} {
    ::Power::_ToggleTrace 0
}
##+##########################################################################
#
# ::Power::_ToggleTrace -- Turns on or off tracing of Power::D
#
proc ::Power::_ToggleTrace {onoff} {
    ;# Don't use ::Data::UniqueTrace because we need to return wasTracing
    set wasTracing 0
    foreach tr [trace vinfo ::Power::D] {
	eval trace vdelete ::Power::D $tr
	set wasTracing 1
    }
    if {$onoff} {
	trace variable ::Power::D w ::Power::_Tracer
    }
    return $wasTracing
}
##+##########################################################################
#
# ::Power::Refresh -- Updates GUI
#
proc ::Power::Refresh {} {
    ::Power::Init
    ::Power::_Tracer a b c
}
##+##########################################################################
#
# ::Power::_Tracer -- Does the magic of updating GUI
#
proc ::Power::_Tracer {var1 var2 op} {
    variable D
    global msg

    if {! [winfo exists $::Power::w]} return
    ::Power::_ToggleTrace 0
    set valid [::Power::_GetCalories]
    ::Power::_ToggleTrace 1
    if {! $valid} return
    if {$var2 eq "human"} {
	set ::state(calorie,human) [::Data::RConvert $D(human) weight]
    } elseif {$var2 eq "bike"} {
	set ::state(calorie,bike)  [::Data::RConvert $D(bike) weight]
    }
}
##+##########################################################################
#
# ::Power::_ComputeA2 -- Computes the quadractic air resistance term
# based on frontal area and air density which is based on temperature.
#
proc ::Power::_ComputeA2 {temperatureC pos} {
    variable C
    variable AirDensity
    variable FrontalArea

    set idx [expr {30 + int(round($temperatureC))}]
    if {$idx < 0} {set idx 0}
    if {$idx >= [llength $AirDensity]} { set idx end }
    set D_a [lindex $AirDensity $idx]

    set A2 [expr {($C(coeffAirResistance) * $D_a / 2.0) * $FrontalArea($pos)}]
    return $A2
}
##+##########################################################################
#
# ::Power::_GetCalories -- Massages user values into internal units
# and computes calories for each speed requested.
#
proc ::Power::_GetCalories {} {
    variable D

    set isValid [string is double -strict $D(human)]
    set isValid [expr {$isValid && [string is double -strict $D(bike)]}]
    set isValid [expr {$isValid && [string is double -strict $D(headwind)]}]
    set isValid [expr {$isValid && [string is double -strict $D(dist)]}]
    set isValid [expr {$isValid && [string is double -strict $D(elev)]}]

    # Convert into internal units and get gradient
    if {$isValid} {
	set human [::Data::RConvert $D(human) weight]
	set bike [::Data::RConvert $D(bike) weight]
	set headwind [::Data::RConvert $D(headwind) dist]
	set temperatureC $::Power::D(temperature)

	set dist [::Data::RConvert $D(dist) dist]
	set elev [::Data::RConvert $D(elev) climb]
	set gradient 0
	if {$dist != 0} {
	    set gradient [expr {$elev / 5280.0 / $dist}]
	}
    }

    # Get calories for each speed requested
    foreach arr [array names D speed,*] {
	if {! $isValid} {
	    set D($arr) "?"
	    continue
	}
	foreach {. speed units} [split $arr ","] break
	set minutes [expr {$D(dist) * 60.0 / $speed}]
	set mph [::Data::RConvert $speed dist]
	set D($arr) [comma [::Power::_Calories $minutes $mph $human $bike \
				$gradient $headwind $temperatureC $D(position)]]
    }
    return $isValid
}
##+##########################################################################
#
# ::Power::_Calories -- Simplified version of Ken Roberts and Mark Grennan's
# bikepower program: http://www.grennan.com/BikePower/. It keeps constant
# air temperature, rolling resistanced, efficiency, metabolism rate
#
# Units: pounds and mph
#
proc ::Power::_Calories {minutes velocity humanWeight bikeWeight gradient \
			headwind temperatureC bikePosition} {
    variable C
    variable P
    variable V

    set verbose [expr {[info exists ::Power::debug] && $::Power::debug}]

    set P(A1) 0.0
    set P(A2) [::Power::_ComputeA2 $temperatureC $bikePosition]

    set P(velocity) [expr {$C(mOs_per_miOhr) * $velocity}] ;# meters/second
    set P(weight,cyclist) [expr {$C(Nt_per_lb) * $humanWeight}]	;# Newtons
    set P(weight,machine) [expr {$C(Nt_per_lb) * $bikeWeight}]	;# Newtons
    set P(gradient) $gradient			;# Sine of angle (but tangent ok)
    set P(headwind) [expr {$C(mOs_per_miOhr) * $headwind}] ;# meters/second

    set P(efficiency,human) $::state(calorie,efficiency,human) ;# Efficiency of human in cycling
    set P(efficiency,drivetrain) $::state(calorie,efficiency,drivetrain) ;# Transmission efficiency of drivetrain
    set P(rollingResistance) $::state(calorie,rollingResistance) ;# Coefficient of rolling friction

    # Start calculating
    set V(weight) [expr {$P(weight,cyclist) + $P(weight,machine)}]
    set V(BM_rate) [expr {$C(BM_rate) * $C(kg_per_Nt) * $P(weight,cyclist)}]

    if {$verbose} {
	puts [format "Grade of hill = %5.1f%%" [expr {100.0 * $P(gradient)}]]
	puts [format "Headwind      = %4.1f mph" \
		  [expr {$P(headwind) / $C(mOs_per_miOhr)}]]
	puts [format "Weight: cylist %5.1f + machine %4.1f = total %5.1f lb" \
		  [expr {$P(weight,cyclist) / $C(Nt_per_lb)}] \
		  [expr {$P(weight,machine) / $C(Nt_per_lb)}] \
		  [expr {$V(weight) / $C(Nt_per_lb)}]]
	puts [format "Rolling friction coeff = %6.4f" $P(rollingResistance)]
	puts [format "BM rate = %5.2f" $C(BM_rate)]
	puts [format "Air resistance coeff = (%6.4f, %g)" $P(A2) $P(A1)]
	puts [format "Efficiency: transmission = %5.1f%% human = %4.1f%%" \
		  [expr {100.0 * $P(efficiency,drivetrain)}] \
		  [expr {100.0 * $P(efficiency,human)}]]
	puts ""
    }

    ;# Calculate the force (+/-) of the air
    set VH [expr {$P(velocity) + $P(headwind)}]
    set V(force,air) [expr {$P(A2) * $VH * $VH + $P(A1) * $VH}]
    if {$VH < 0} { set V(force,air) [expr {-$V(force,air)}]}

    ;# Calculate the force of rolling restance
    set V(force,rolling) [expr {$P(rollingResistance) * $V(weight)}]

    ;# Calculate the force (+/-) of the grade
    set V(force,gradient) [expr {$P(gradient) * $V(weight)}]

    ;# Calculate the total force
    set V(force,total) [expr {$V(force,air) + $V(force,rolling) \
				  + $V(force,gradient)}]
    ;# Calculate Power in Watts
    set V(power) [expr {$P(velocity)*$V(force,total)/$P(efficiency,drivetrain)}]

    ;# Calculate calories and drivetrain loss
    if {$V(power) > 0} {
	set V(powerConsumption) \
	    [expr {$V(power) / $P(efficiency,human) + $V(BM_rate)}]
	set V(powerLoss) [expr {(1.0 - $P(efficiency,drivetrain)) * $V(power)}]
    } else {
	set V(powerConsumption) $V(BM_rate)
	set V(powerLoss) 0.0
    }

    set V(calHour) [expr {$V(powerConsumption) / $C(Watts_per_CalOhr)}]
    set V(calories) [expr {int(round($V(calHour) * $minutes / 60.0))}]
    if {$verbose} {
	set hdr "  mph  F_lb   P_a  P_r   P_g  P_t    P    "
	append hdr "hp   heat   BM     C    Cal/hr"
	set fmt "%5.1f  %4.1f  %4.0f %4.0f %5.0f %4.0f %5.0f "
	append fmt "%5.2f %5.0f  %3.0f  %5.0f   %5.0f"
	puts $hdr
	puts [format $fmt \
		  [expr {$P(velocity) / $C(mOs_per_miOhr)}] \
		  [expr {$V(force,total) / $C(Nt_per_lb)}] \
		  [expr {$P(velocity) * $V(force,air)}] \
		  [expr {$P(velocity) * $V(force,rolling)}] \
		  [expr {$P(velocity) * $V(force,gradient)}] \
		  $V(powerLoss) \
		  $V(power) \
		  [expr {$V(power) / $C(Watts_per_horsepower)}] \
		  [expr {$V(powerConsumption) - ($V(BM_rate) - $V(power))}] \
		  $V(BM_rate) \
		  $V(powerConsumption) \
		  $V(calHour) \
		 ]
    }
    return $V(calories)
}
## EON POWER
## BON GOOGLE
##+##########################################################################
#
# ::Google::Dialog -- brings up the Google Earth dialog
#
proc ::Google::Dialog {} {
    variable GE

    set ifile googleearth.gif
    if {[::Data::CanDo png]} {
	set ifile googleearth2.png
    }
    #set ifile ../images2/google_earth2.gif ;# 48x48

    set W .earth
    set WB $W.body
    set WBC $WB.c
    set WBTN $W.buttons
    set wtitle "$::state(progname) 3D -- Google Earth"
    set title "$::state(progname) 3D\nGoogle Earth"
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::gearth $ifile]
    wm protocol $W WM_DELETE_WINDOW ::Google::_TearDown

    ::ttk::button $WBTN.ok -text OK -command ::Google::Go
    ::ttk::button $WBTN.cancel -text Dismiss -command ::Google::_TearDown
    ::Display::GridChildren $WBTN 2

    set GE(title) $::route(title)
    if {$GE(title) eq ""} {
	set GE(title) [clock format [clock seconds] -format "%b %d, %Y"]
    }
    ::my::label $WB.title -text "Route Title"
    ::my::entry $WB.etitle -textvariable ::Google::GE(title) -justify c
    ::ttk::checkbutton $WB.markers -text "Show markers" -variable ::Google::GE(markers)

    ::ttk::radiobutton $WB.egoogle -text "View with Google Earth" \
	-variable ::Google::GE(action) -value googleearth
    ::ttk::radiobutton $WB.mgoogle -text "View with Google Maps" \
	-variable ::Google::GE(action) -value googlemaps
    ::ttk::radiobutton $WB.save -text "Save to disk" \
	-variable ::Google::GE(action) -value save
    if {! [::Data::CanDo googleearth]} {
	$WB.egoogle config -state disabled
	set ::Google::GE(action) save
	set ::Google::GE(action) googlemaps
    }
    if {! [::Data::CanDo webPage]} {
	$WB.mgoogle config -state disabled
	set ::Google::GE(action) save
    }

    grid $WB.title $WB.etitle -sticky ew
    grid $WB.markers - -sticky w -pady {0 10} -padx 20
    grid $WB.egoogle - -sticky w -padx 20
    grid $WB.mgoogle - -sticky w -padx 20
    grid $WB.save - -sticky w -padx 20
    grid columnconfigure $WB 1 -weight 1

    ::Display::CenterWindow $W
    wm deiconify $W
    wm resizable $W 1 1
}
##+##########################################################################
#
# ::Google::Go -- Handles action from Google Earth dialog
#
proc ::Google::Go {} {
    variable saveName
    variable GE

    if {$GE(title) ne ""} {
	set ::route(title) $GE(title)
    }
    if {$GE(action) eq "googlemaps"} {
	destroy .earth ; update
	::Google::GoGoogleMaps
	return
    }

    if {$GE(action) eq "googleearth"} {
	set fname [::Data::GetTempFile .kml]
    } else {
	set types {{{Google Earth Files} {.kml}} {{All Files} *}}
	set fname [tk_getSaveFile -defaultextension ".kml" \
		       -title "$::state(progname) Google Earth" \
		       -initialdir [file dirname $saveName] \
		       -initialfile [file tail $saveName] \
		       -filetypes $types]
	if {$fname eq ""} {
	    return 0
	}
    }
    set XML [::Google::MakeXML $GE(title)] ; list
    set n [catch {set fout [open $fname w]} emsg]
    if {$n} {
	WARN $emsg
	return
    }
    puts -nonewline $fout $XML
    close $fout
    destroy .earth ; update
    if {$GE(action) eq "googleearth"} {
	::Google::RunGoogleEarth $fname
    }
}
##+##########################################################################
#
# ::Google::_TearDown -- cleans up from Google Earth dialog
#
proc ::Google::_TearDown {} {
    # Clean up temp files
    destroy .earth
}
##+##########################################################################
#
# ::Google::MakeXML -- creates KML xml from current route
#  see http://feedvalidator.org/
#
proc ::Google::MakeXML {title} {
    variable XML
    variable TEMPLATE

    set XML $TEMPLATE(doc,pre)
    ::Google::_AppendNodes
    ::Google::_AppendRoute $title
    append XML $TEMPLATE(doc,post)

    set XML [::XML::Indent $XML]
    return $XML
}
##+##########################################################################
#
# ::Google::_AppendNodes -- adds nodes to our KML data
#
proc ::Google::_AppendNodes {} {
    variable XML
    variable TEMPLATE
    variable GE
    global route nodes

    unset -nocomplain seen
    set nlist $route(nodes)
    if {! $GE(markers)} {			;# Keep only start and end
	set nlist [list [lindex $nlist 0] [lindex $nlist end]]
    }

    append XML $TEMPLATE(point,pre)
    set idx -1
    foreach nid $nlist {
	incr idx
	if {[info exists seen($nid)]} continue
	set turn [lindex $route(turns) $idx]
	if {$turn eq "O"} continue
	set seen($nid) 1

	foreach {desc alt lat lon} $nodes($nid) break
	regexp {[A-Za-z0-9]+} [string map {n {} N {}} $nid] name
	set lon "-$lon"
	append XML [subst -nobackslashes -nocommands $TEMPLATE(point,item)]
    }
    append XML $TEMPLATE(point,post)
}
##+##########################################################################
#
# ::Google::_AppendRoute -- appends route to our KML data
#
proc ::Google::_AppendRoute {{snippet ""}} {
    variable XML
    variable TEMPLATE

    set snippet [string trim $snippet]
    set routeID "Route 1"
    append XML [subst -nobackslashes -nocommands $TEMPLATE(path,pre)]
    foreach datum [::Route::GetXYZ] {
	foreach {. . lat lon} $datum break
	set lon "-$lon"
	append XML [subst -nobackslashes -nocommands $TEMPLATE(path,item)]
    }
    append XML $TEMPLATE(path,post)
}
##+##########################################################################
#
# ::Google::RunGoogleEarth -- Invokes Google Earth and passes it our route
#
proc ::Google::RunGoogleEarth {fname} {
    if {$::state(windows)} {
	set cmd [auto_execok cmd]			;# Works better than 4dos
	if {$cmd ne ""} {
	    catch {exec $cmd /c start $fname}
	} else {
	    catch {eval exec [auto_execok start] [list $fname]}
	}
    } else {
	set cmd [auto_execok googleearth]
	catch {exec {*}$cmd $fname &}
    }
}
##+##########################################################################
#
# ::Google::GoGoogleMaps -- front end to viewing route in google maps
#
proc ::Google::GoGoogleMaps {{which route}} {
    variable who $which

    set fname [::Data::GetTempFile .htm]
    ::Google::CreateRoutePage $fname

    set fname2 [file nativename $fname]
    regsub -all {\\} $fname2 / fname2
    set url "file:///$fname2"
    WebPage $url
}
##+##########################################################################
#
# ::Google::CreateRoutePage -- creates our HTML for google maps
#
proc ::Google::CreateRoutePage {outname} {
    variable who

    set tname [file join $::state(pdir) $::Google::templateName]
    if {! [file readable $tname]} {
	set fname [file nativename [file normalize $tname]]
	WARN "Google maps HTLM template file missing:\n$fname"
	return
    }
    set template [::Data::ReadAllText $tname]

    set mtxt [::Google::GetRouteMarkers]
    set rtxt [::Google::GetRoute]
    set ztxt [::Google::GetZoneInfo]

    if {$who eq "route"} {
	set stxt "var dist = '$::msg(dist)';\n"
	append stxt "    var climb = '$::msg(climb)';\n"
	append stxt "    var desc = '$::msg(desc)';\n"
    } else {
	set stxt "var dist = '$::Tracks::distance';\n"
	append stxt "    var climb = '$::Tracks::climbs';\n"
	append stxt "    var desc = '$::Tracks::descends';\n"
    }
    append stxt "    var year = '[clock format [clock seconds] -format %Y]';\n"
    set ttxt ""
    if {$::route(title) ne ""} {
	set ttxt "<h1>[::Data::HTMLSafe $::route(title)]</h1>"
    }
    set html [string map [list "SUBSTITUTE_NODES_HERE" $mtxt] $template]
    set html [string map [list "SUBSTITUTE_ROUTE_HERE" $rtxt] $html]
    set html [string map [list "SUBSTITUTE_STATS_HERE" $stxt] $html]
    set html [string map [list "SUBSTITUTE_TITLE_HERE" $ttxt] $html]
    set html [string map [list "SUBSTITUTE_ZONE_HERE" $ztxt] $html]

    set fout [open $outname w]
    puts -nonewline $fout $html
    close $fout
}
##+##########################################################################
#
# ::Google::GetRoute -- creates javascript variables for our route
#
proc ::Google::GetRoute {} {
    variable who

    foreach {r g b} [winfo rgb . $::state(r,1,0,color)] break
    set clr [format "#%02X%02X%02X" [expr {$r*255/65535}] \
		[expr {$g*255/65535}] [expr {$b*255/65535}]]

    set txt ""
    append txt "var rClr = '$clr';\n"
    append txt "    var rWidth = $::state(r,1,0,width);\n"
    append txt "    var route = \[\n"
    if {$who eq "route"} {
	set xyz [::Route::GetXYZ]
    } else {
	set xyz [::GPS::GetXYZ $who]
    }
    foreach datum $xyz {
	foreach {. . lat lon} $datum break
	append txt "        new GLatLng($lat,-$lon),\n"
    }
    append txt "    ]\n";
    return $txt
}
##+##########################################################################
#
# ::Google::GetRouteMarkers -- creates javascript variables for our nodes
#
proc ::Google::GetRouteMarkers {} {
    variable GE
    variable who
    global route nodes

    if {$who ne "route"} {
	return [::Google::GetGPSRouteMarkers]
    }

    unset -nocomplain visited
    set nlist $route(nodes)
    if {! $GE(markers)} {			;# Keep only start and end
	set nlist [list [lindex $nlist 0] [lindex $nlist end]]
    }

    set txt "var markers = \[\n"
    set idx -1
    foreach nid $nlist {
	incr idx
	if {[info exists visited($nid)]} continue
	set turn [lindex $route(turns) $idx]
	if {$turn eq "O"} continue

	set visited($nid) 1

	foreach {name elev lat lon} $nodes($nid) break
	append name "<br>Elevation: [::Data::Label $elev climb 1 2]"
	append name "<br>[string trim [::Route::Turnings $nid]]"
	set name [string map {' \\'} $name]

	append txt "    { 'lat': $lat,\n"
	append txt "      'lon': -$lon,\n"
	append txt "      'name': '$name'},\n"
    }
    append txt "    ]\n"
    return $txt
}
proc ::Google::GetGPSRouteMarkers {} {
    set txt "var markers = \[\n"
    foreach {lat lon name} [::GPS::GetStartWpts $::Google::who] break
    if {$lat ne "?"} {
	append txt "    { 'lat': $lat,\n"
	append txt "      'lon': -$lon,\n"
	append txt "      'name': '$name'},\n"
    }

    foreach arr [array names ::GPS::wpts w,*] {
	foreach {lat lon name} $::GPS::wpts($arr) break
	set name [string map {' \\'} $name]
	append txt "    { 'lat': $lat,\n"
	append txt "      'lon': -$lon,\n"
	append txt "      'name': '$name'},\n"
    }
    append txt "    ]\n"
    return $txt
}
##+##########################################################################
#
# ::Google::GetZoneInfo -- Assembles zone and region info
#
proc ::Google::GetZoneInfo {} {
    global state

    set ztxt [::Data::HTMLSafe "$state(zone) Zone"]
    append ztxt "<br>\n" [::Data::HTMLSafe $state(region,pretty2)]
    return $ztxt
}
## EON GOOGLE
## BON ATLAS
##+##########################################################################
#
# ::Atlas::Toggle -- Shows or hides the ridemap dialog
#
proc ::Atlas::Toggle {} {
    if {$::state(atlas)} {
	::Atlas::Dialog
    } else {
	::Atlas::Dismiss
    }
}
##+##########################################################################
#
# ::Atlas::CanDo -- See how much of atlas we can do. If we don't
# have xphoto, we can still do atlas but w/o rotation.
#
proc ::Atlas::CanDo {{quiet 0}} {
    if {[info exists ::state(can,atlas)]} { return $::state(can,atlas)}
    if {$::state(macosx)} {
        WARN "This feature does not work on OS X"
	set ::state(can,atlas) 0
	return 0
    }

    set n1 [::Data::CanDo grabWindow]
    set n2 [::Data::CanDo sframe]
    if {! $n1 || ! $n2} {
	WARN "This feature requires the img::window and scrolled window packages"
	set ::state(can,atlas) 0
	return 0
    }
    set ::state(can,atlas) 1
    set n [::Data::CanDo xphoto]
    if {! $n && ! $quiet} {
	set emsg "Missing the xphoto package.\n\n"
	append emsg "The feature will still work but\n"
	append emsg "without being able to rotate\nthe selection."
	WARN $emsg
    }
    return $::state(can,atlas)
}
##+##########################################################################
#
# ::Atlas::Dialog -- Puts up the Atlas dialog
#
proc ::Atlas::Dialog {} {
    variable WIN
    variable S

    set n [::Data::CanDo atlas]
    if {! $n} {
	.bbar.atlas config -state disabled
	set ::state(atlas) 0
	return
    }
    ::Atlas::Init
    set WIN(maps) [expr {[winfo exists .zoom.c] ? ".zoom.c" : ".c"}]

    set W $WIN(top)
    if {[winfo exists $W]} {
	::Atlas::Begin
	return
    }

    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Route Atlas"
    set title $wtitle

    ::Display::MakeDialogBox $W $wtitle $title [list ::img::rMap atlas.gif]
    wm transient $W {}
    wm protocol $W WM_DELETE_WINDOW ::Atlas::Dismiss
    wm resizable $W 1 1
    ::Atlas::DoMenus

    ::ttk::button $WBTN.print -text "Print" -command ::Atlas::Print
    ::ttk::button $WBTN.save -text "Save" -command ::Atlas::Save
    ::ttk::button $WBTN.help -text "Help" -command [list ::Help::Help "Route Atlas"]
    ::ttk::button $WBTN.hide -text "Dismiss" -command ::Atlas::Dismiss
    ::Display::GridChildren $WBTN 1
    grid forget $WBTN.print
    set WIN(print) $WBTN.print
    set WIN(save) $WBTN.save

    ;#T TODO: scrolledframe tile enable
    set WIN(show) [::scrolledframe::XYScrolledframe $WB.show 410 110]

    ::my::frame $WB.buttons
    ::ttk::button $WB.buttons.snap -text "Take Snap Shot" -command ::Atlas::GetImg
    ::ttk::button $WB.buttons.clean -text "Delete All" -command ::Atlas::DeleteAll
    set WIN(dbutton) $WB.buttons.clean
    pack $WB.buttons -side bottom -fill x
    pack $WB.show -side top -fill both -expand 1
    eval pack [winfo child $WB.buttons] -side left -expand 1 -pady {{10 0}}

    ::Atlas::EmptyMap
    ::Atlas::ResizeDialog
    ::Atlas::Begin
}
##+##########################################################################
#
# ::Atlas::DoMenus -- Add a menu to our dialog
#
proc ::Atlas::DoMenus {} {
    set W $::Atlas::WIN(top)
    menu $W.m -tearoff 0
    $W configure -menu $W.m
    $W.m add cascade -menu $W.m.img -label "Image" -underline 0

    set imageMenus {
	{"&Snap Shot" ::Atlas::GetImg }
	{"Add &Profile" {::Atlas::GetProfileImg}}
	{"Add &User Image" {::Atlas::GetUserImg}}
    }
    ::Display::BuildMenu $W.m.img $imageMenus
    $W.m.img config -postcommand ::Atlas::MenuPostCommand
}
##+##########################################################################
#
# ::Atlas::MenuPostCommand -- Enables or disables adding Profile image
#
proc ::Atlas::MenuPostCommand {} {
    set W $::Atlas::WIN(top)
    set how [expr {[winfo exists .pro] ? "normal" : "disabled"}]
    $W.m.img entryconfig "Add Profile" -state $how
}
##+##########################################################################
#
# ::Atlas::ResizeDialog -- Resizes the dialog--because we use a
# scrolled window which doesn't automatically grow the parent window
#
proc ::Atlas::ResizeDialog {} {
    variable WIN
    variable S

    if {[winfo exists $WIN(show).empty]} {
	set w [$WIN(show).empty cget -width]
	incr w 6
	set h [$WIN(show).empty cget -height]
	incr h 6
    } else {
	set w 0
	set h 0
	for {set i 1} {[winfo exist $WIN(show).$i]} {incr i} {
	    #incr h [winfo height $WIN(show).$i]
	    incr h [image height $S($i,img)]
	    incr h 30				;# Text and border
	    incr h [expr {$i > 1 ? 10 : 0}]	;# Inter map spacing
	    set w1 [image width $S($i,img)]
	    incr w1 31				;# Buttons and border
	    set w [Max $w $w1]
	}
    }
    set w [Min $w 1000]
    set h [Min $h 800]
    [winfo parent $WIN(show)] config -width $w -height $h
}
##+##########################################################################
#
# ::Atlas::SeeBottom -- Makes sure we can see the newly added map
#
proc ::Atlas::SeeBottom {w} {
    variable WIN
    update idletasks
    [winfo parent $WIN(show)] yview moveto 1
    [winfo parent $WIN(show)] xview moveto 0
    ::tk::TabToWindow $w
}
##+##########################################################################
#
# ::Atlas::Reparent -- Switches clipbox between main and zoom windows
#
proc ::Atlas::Reparent {} {
    variable WIN
    if {! $::state(atlas)} return

    if {[winfo exists .zoom.c]} {		;# Move to zoom window
	if {$WIN(maps) eq ".zoom.c"} return
	$WIN(maps) delete BOX
	set WIN(maps) .zoom.c
	::Atlas::Begin
    } else {
	if {$WIN(maps) eq ".c"} return
	set WIN(maps) .c
	::Atlas::Begin
    }
}
##+##########################################################################
#
# ::Atlas::Begin -- Figures out size of clipbox and draws it
#
proc ::Atlas::Begin {} {
    variable WIN

    if {! [winfo ismapped $WIN(top)]} {
	::Display::RightWindow $WIN(top) $WIN(maps)
	wm deiconify $WIN(top)
    }

    set x [$WIN(maps) canvasx 100]
    set y [$WIN(maps) canvasy 100]
    set len [expr {[winfo width $WIN(maps)] - 150}]

    set pw [expr {612 - 2*20}]			;# PDF page width w/ margins
    if {$len > $pw} { set len $pw}
    ::ClipBox::Go $WIN(maps) [list $x $y] 7 $len 200
}
##+##########################################################################
#
# ::Atlas::Dismiss -- Hides the atlas dialog instead of destroying it
#
proc ::Atlas::Dismiss {} {
    if {[winfo exists $::Atlas::WIN(top)]} {
	wm withdraw $::Atlas::WIN(top)
    }
    if {[winfo exists $::Atlas::WIN(maps)]} {
	$::Atlas::WIN(maps) delete BOX
    }
    set ::state(atlas) 0
}
##+##########################################################################
#
# ::Atlas::GetImg -- Grabs clipbox and adds to our dialog
#
proc ::Atlas::GetImg {} {
    variable WIN
    set img [::ClipBox::Snapshot $WIN(maps)]
    ::Atlas::AddImg $img
}
##+##########################################################################
#
# ::Atlas::GetProfileImg -- Grabs profile image and adds to atlas
#
proc ::Atlas::GetProfileImg {} {
    set img [::Profile::MakeImage]
    if {$img eq ""} return
    catch { raise .atlas .pro }
    ::Atlas::AddImg $img "KLIMB Route Profile"
}
##+##########################################################################
#
# ::Atlas::GetUserImg -- Asks users for an image and add it to the atlas
#
proc ::Atlas::GetUserImg {} {
    variable userFile

    set types {}
    if {[::Data::CanDo png]} {lappend types {"PNG Files" ".png"}}
    if {$::state(can,jpeg)} {lappend types {"JPEG Files" ".jpg"}}
    lappend types {"GIF Files" ".gif"}
    set ext [lindex $types 0 1]
    set fname [tk_getOpenFile -filetypes $types -defaultextension $ext \
		   -title "$::state(progname) Atlas Image Load" \
		   -initialdir [file dirname $userFile]]
    if {$fname eq ""} return
    set n [catch {set img [image create photo -file $fname]} emsg]
    if {$n} {
	WARN "ERROR: $emsg"
	return
    }
    set userFile $fname
    set txt [file rootname [file tail $fname]]
    ::Atlas::AddImg $img $txt
}
##+##########################################################################
#
# ::Atlas::AddImg -- Adds image to our dialog
#
proc ::Atlas::AddImg {img {txt ""}} {
    variable S
    variable WIN

    destroy $WIN(show).empty

    set id [incr S(cnt)]
    set w $WIN(show).$id
    ::my::frame $w
    ::my::frame $w.left
    ::my::frame $w.right -borderwidth 2 -relief solid
    grid $w -sticky w -pady [list [expr {$id > 1 ? 10 : 0}] 0]
    grid $w.left $w.right

    ::tk::button $w.left.up -image ::bmp::up -takefocus 0 \
	-command [list ::Atlas::Swap up $id]
    ::tk::button $w.left.x -image ::bmp::x -bg red -takefocus 0 \
	-command [list ::Atlas::DeleteRow $id]
    ::tk::button $w.left.down -image ::bmp::down -takefocus 0 \
	-command [list ::Atlas::Swap down $id]
    eval pack [winfo child $w.left] -side top -pady 2 -padx 5

    set S($id,img) $img
    set S($id,txt) "<label for this map>"
    if {$txt ne ""} {
	set S($id,txt) $txt
    } elseif {$WIN(maps) eq ".c"} {
	set S($id,txt) [::Route::GetAtlasText $S($id,txt)]
    }
    set w [::Atlas::OneImage $w.right $img $id]
    ::Atlas::ResizeDialog
    ::ClipBox::MoveForward $WIN(maps)
    ::Atlas::DoButtons

    ::Atlas::SeeBottom $w

    return
}
##+##########################################################################
#
# ::Atlas::Init -- Initializes atlas package
#
proc ::Atlas::Init {} {
    if {[lsearch [image names] ::bmp::up] > -1} return

    font create rmapFont -family Helvetica -size 10 -weight bold

    image create bitmap ::bmp::up -data {
	#define up_width 11
	#define up_height 11
	static char up_bits = {
	    0x00, 0x00, 0x20, 0x00, 0x70, 0x00, 0xf8, 0x00, 0xfc, 0x01, 0xfe,
	    0x03, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00
	}
    }
    image create bitmap ::bmp::down -data {
	#define down_width 11
	#define down_height 11
	static char down_bits = {
	    0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0xfe,
	    0x03, 0xfc, 0x01, 0xf8, 0x00, 0x70, 0x00, 0x20, 0x00, 0x00, 0x00
	}
    }
    image create bitmap ::bmp::x -foreground white -data {
	#define X_width 11
	#define X_height 11
	static char X_bits = {
	    0x04, 0x01, 0x8e, 0x03, 0xdf, 0x07, 0xfe, 0x03, 0xfc, 0x01, 0xf8,
	    0x00, 0xfc, 0x01, 0xfe, 0x03, 0xdf, 0x07, 0x8e, 0x03, 0x04, 0x01
	}
    }
}
##+##########################################################################
#
# ::Atlas::EmptyMap -- Puts up helpful message for the empty dialog
#
proc ::Atlas::EmptyMap {} {
    variable S
    variable WIN

    if {$S(cnt) == 0} {
	::tk::label $WIN(show).empty -image ::img::blank -borderwidth 2 \
	    -relief solid \
	    -width 400 -height 100 -font {Helvetica 12 bold} -compound center \
	    -text "Empty Atlas"
	pack $WIN(show).empty -side top -fill both -expand 1
	::Atlas::DoButtons
    }
}
##+##########################################################################
#
# ::Atlas::OneImage -- Adds one image to our dialog
#
proc ::Atlas::OneImage {w img id} {
    variable S

    set S($id,w) $w.img
    ::tk::label $w.img -image $img -bd 0
    ::tk::label $w.id -text "MAP $id" -font rmapFont -anchor e
    ::tk::entry $w.txt -font rmapFont -justify c -bd 0 \
	-textvariable ::Atlas::S($id,txt)
    $w.id config -bg [$w.txt cget -bg]
    pack $w.img -side top -fill both -expand 1
    pack $w.id -side right
    pack $w.txt -side left -fill both -expand 1

    return $w.txt
}
##+##########################################################################
#
# ::Atlas::SwapRows -- Swaps two specific rows in our dialog
#
proc ::Atlas::SwapRows {row1 row2} {
    variable S

    set txt $S($row1,txt)
    set S($row1,txt) $S($row2,txt)
    set S($row2,txt) $txt

    set img $S($row1,img)
    set S($row1,img) $S($row2,img)
    set S($row2,img) $img
    $S($row1,w) config -image $S($row1,img)
    $S($row2,w) config -image $S($row2,img)
}
##+##########################################################################
#
# ::Atlas::Swap -- Swaps a row up or down
#
proc ::Atlas::Swap {dir which} {
    set other [expr {$dir eq "up" ? $which-1 : $which+1}]
    ::Atlas::SwapRows $which $other
}
##+##########################################################################
#
# ::Atlas::DeleteRow -- Deletes a row from our dialog
#
proc ::Atlas::DeleteRow {which} {
    variable S
    variable WIN

    for {set row $which} {$row < $S(cnt)} {incr row} {
	::Atlas::SwapRows $row [expr {$row+1}]
    }
    destroy $WIN(show).$S(cnt)
    image delete $S($S(cnt),img)
    array unset S $S(cnt),*
    incr S(cnt) -1
    ::Atlas::DoButtons
    if {$S(cnt) == 0} ::Atlas::EmptyMap
    ::Atlas::ResizeDialog
}
##+##########################################################################
#
# ::Atlas::DeleteAll -- Deletes all rows
#
proc ::Atlas::DeleteAll {} {
    variable S
    variable WIN

    while {$S(cnt) > 0} {
	::Atlas::DeleteRow $S(cnt)
    }
}
##+##########################################################################
#
# ::Atlas::DoButtons -- Enables/disables image buttons as needed
#
proc ::Atlas::DoButtons {} {
    variable S
    variable WIN

    $WIN(dbutton) config -state [expr {$S(cnt) == 0 ? "disabled" : "normal"}]
    $WIN(print) config -state [expr {$S(cnt) == 0 ? "disabled" : "normal"}]
    $WIN(save) config -state [expr {$S(cnt) == 0 ? "disabled" : "normal"}]

    if {$S(cnt) == 0} return
    for {set i 1} {$i <= $S(cnt)} {incr i} {
	$WIN(show).$i.left.up config -state normal
	$WIN(show).$i.left.down config -state normal
    }
    $WIN(show).1.left.up config -state disabled
    $WIN(show).$S(cnt).left.down config -state disabled
}
##+##########################################################################
#
# ::Atlas::Print -- Stub for printing
#
proc ::Atlas::Print {} {
    tk_messageBox -message "Not yet implemeted" \
	-title "KLIMB Route Atlas Print"
}
##+##########################################################################
#
# ::Atlas::Save -- Handles saving our route atlas
#
proc ::Atlas::Save {} {
    variable fileName

    set types {
	{"Web Page" {.html .htm}}
    }
    set ext .html
    if {[::Data::CanDo pdf4tcl]} {
	set types {
	    {"PDF Files" .pdf}
	    {"Web Page" {.html .htm}}
	}
	set ext .pdf
    }

    set fname [tk_getSaveFile -defaultextension $ext -filetypes $types \
		   -title "$::state(progname) Save Route Atlas" \
		   -initialdir [file dirname $fileName] \
		   -initialfile [file tail [file rootname $fileName]]]
    if {$fname eq ""} return
    set fileName $fname
    if {[file extension $fname] eq ".pdf"} {
	::Atlas::SavePDF $fname
    } else {
	::Atlas::SaveHTML $fname
    }
}
##+##########################################################################
#
# ::Atlas::SaveHTML -- Saves atlas as HTML
#
proc ::Atlas::SaveHTML {fname} {
    variable S

    set when [clock format [clock seconds] -format "%b %d, %Y"]
    set year [clock format [clock seconds] -format "%Y"]

    set fout [open $fname w]
    puts $fout "<html>\n<head><title>KLIMB Route Atlas, $when</title></head>"
    puts $fout "<body>"
    puts $fout "<table>"
    puts $fout "<tr><td align='center'>"
    puts $fout "  <font size=36><strong>KLIMB Route Atlas</strong></font>"
    set title [string trim $::route(title)]
    if {$title eq ""} {
	set title [clock format [clock seconds] -format "%b %d, %Y"]
    }
    puts $fout "  <br><font size=28 color='red'><strong>"
    puts $fout "[::Data::HTMLSafe $title]</strong></font>"

    puts $fout "</td></tr>"

    for {set i 1} {$i <= $S(cnt)} {incr i} {
	set iname "[file root $fname]_image_$i.jpg"
	$S($i,img) write $iname -format jpeg

	set itag "<img src='[file tail $iname]' align='left' border='1' alt='MAP $i' "
	append itag "width='[image width $S($i,img)]' "
	append itag "height='[image height $S($i,img)]'>"

	puts $fout "<tr><td>"
	puts $fout "  <table style='border: 1px solid black' cellspacing='0'>"
	puts $fout "  <tr><td colspan='2'>\n    $itag\n  </td></tr>"
	puts $fout "    <tr><td align='center'>$S($i,txt)</td>"
	puts $fout "    <td align='right'><strong>MAP $i</strong></td></tr>"
	puts $fout "  </table><br>"
	puts $fout "</td></tr>\n"
    }
    puts $fout "<tr><td style='border-top: 1px solid navy; font-size: 80%; padding-top: 1em;' align='right'>"
    puts $fout "created with <a href='http://www.klimb.org'>www.klimb.org<br>"
    puts $fout "<font color='#6f6f6f' size=-1>&copy;$year Keith Vetter"
    puts $fout "</td></tr>\n"
    puts $fout "</table>"
    puts $fout "</body></html>"
    close $fout
}
##+##########################################################################
#
# ::Atlas::SavePDF -- Saves atlas as PDF
#
proc ::Atlas::SavePDF {fname} {
    variable PDF
    variable S
    global route

    if {! [::Data::CanDo pdf4tcl]} {
	WARN "requires pdf4tcl package (should never get here)"
	return
    }

    # Figure out landscape or portrait
    set landscape 0 ; set pw 612 ; set ph 792	;# Assume portrait
    for {set i 1} {$i <= $S(cnt)} {incr i} {
	set iw [image width $S($i,img)]
	if {$iw > $pw} {			;# Need landscape mode
	    set landscape 1
	    foreach {pw ph} [list $ph $pw] break
	    break
	}
    }
    set PDF(ph) $ph
    set copyright \xa9
    set year [clock format [clock seconds] -format "%Y"]

    pdf4tcl::new mypdf -compress 1 -paper letter -landscape $landscape

    set x $PDF(rMargin)
    set y $ph
    set pageNum 0
    for {set i 1} {$i <= $S(cnt)} {incr i} {
	set y2 [expr {$y+[image height $S($i,img)]+$PDF(fontSize)+$PDF(imgPad)}]
	if {$y2 > $ph} {
	    incr pageNum
	    mypdf endPage
	    mypdf startPage
	    set y 40				;# Baseline of title string
	    mypdf setFont $PDF(titleSize) "Helvetica-Bold"
	    ::Atlas::_DrawTextAt mypdf DrawTextAt [expr {$pw/2}] $y "KLIMB Route Atlas" center
	    incr y 20
	    if {[info exists route(title)] && $route(title) ne ""} {
		incr y 10
		mypdf setFont $PDF(title2Size) "Helvetica-Bold"
		::Atlas::_DrawTextAt mypdf DrawTextAt [expr {$pw/2}] $y "$route(title)" center
		incr y 20
	    }

	    mypdf setFont $PDF(footerSize) "Helvetica"
	    ::Atlas::_DrawTextAt mypdf DrawTextAt [expr {$pw/2}] [expr {$ph-2-$PDF(footerSize)}] \
		"Page $pageNum" center
	    ::Atlas::_DrawTextAt mypdf DrawTextAt [expr {$pw-10}] [expr {$ph-2-$PDF(footerSize)}] \
		"www.klimb.org $copyright $year" right
	}

	set y [::Atlas::PDFOneImage mypdf $x $y $i \
		   $S($i,img) $S($i,txt) "MAP $i "]
	incr y 10
    }
    mypdf endPage
    mypdf write -file $fname
    mypdf cleanup
}
##+##########################################################################
#
# ::Atlas::_DrawTextAt -- pdf4tcl 0.7 changed eh drawTextAt function
# replacing the last argument and inverting the meaning of Y
#
proc ::Atlas::_DrawTextAt {mypdf cmd x y str {align left}} {
    variable PDF

    set version [package present pdf4tcl]
    if {[package vsatisfies $version 0.7]} {
	$mypdf DrawTextAt $x [expr {$PDF(ph) - $y}] $str $align
	# (alternatively)
	# $mypdf setTextPosition $x $y
	# $mypdf text $str -align $align
    } else {
	$mypdf drawTextAt $x $y $str -align $align
    }
}
##+##########################################################################
#
# ::Atlas::PDFOneImage -- Adds one image to our pdf output
#
proc ::Atlas::PDFOneImage {mypdf x y id img txt1 txt2} {
    variable PDF

    set jpegFile [::Data::GetTempFile .jpg]
    $img write $jpegFile -format jpeg

    set iw [image width $img]
    set ih [image height $img]

    set x1 [expr {$x + $iw}]
    set xm [expr {$x + $iw/2}]
    set y1 [expr {$y + $ih + $PDF(fontSize)}]
    set y2 [expr {$y1 + $PDF(imgPad)}]

    $mypdf addJpeg $jpegFile $id
    file delete $jpegFile
    $mypdf putImage $id $x $y

    $mypdf setFont $PDF(fontSize) "Helvetica-Bold"
    ::Atlas::_DrawTextAt $mypdf DrawTextAt $xm $y1 $txt1 center
    ::Atlas::_DrawTextAt $mypdf DrawTextAt [expr {$x1-4}] $y1 $txt2 right

    $mypdf setLineStyle 2
    $mypdf line $x $y $x1 $y
    $mypdf line $x1 $y $x1 $y2
    $mypdf line $x1 $y2 $x $y2
    $mypdf line $x $y2 $x $y
    return $y2
}
## EON ATLAS
## BON CLIPBOX
##+##########################################################################
#
# ::ClipBox::Go -- creates the initial instance of our clipping box
#
proc ::ClipBox::Go {W p0 angle width height} {
    variable P
    set P(can,angle) [::Data::CanDo xphoto]
    set P(0) $p0
    set P(a,deg) [expr {$P(can,angle) ? $angle : 0}]
    set P(w) $width
    set P(h) $height

    $W delete BOX
    $W create poly -tag {BOX dash} -fill {} -width 2 -outline black -dash -
    $W lower dash
    $W create poly -tag {BOX clip} -fill cyan -stipple gray50 \
	-width 2 -outline black -dash -
    if {$P(can,angle)} {
	$W create poly -tag {BOX corner} -outline black -fill {} -width 2
    }
    $W create poly -tag {BOX width} -fill black
    $W create poly -tag {BOX height} -fill black
    $W create text -100 -100 -text "N" -font {Helvetica 20 bold} -fill red \
	-anchor s -tag {BOX north northText}
    $W create line -100 -100 -200 -200 -width 5 -tag {BOX north northLine} \
	-fill red -arrow first -arrowshape {25 25 6}

    foreach tag {clip corner width height} {
	$W bind $tag <1> [list ::ClipBox::MouseDown %W $tag %x %y]
	$W bind $tag <B1-Motion> [list ::ClipBox::MouseMove %W $tag %x %y]
	$W bind $tag <ButtonRelease-1>  [list ::ClipBox::MouseUp %W]
	$W bind $tag <Enter> [list ::ClipBox::MouseEnter %W $tag]
	$W bind $tag <Leave> [list ::ClipBox::MouseLeave %W $tag]

	$W bind $tag <3> [list ::ClipBox::MouseDown %W corner %x %y]
	$W bind $tag <B3-Motion> [list ::ClipBox::MouseMove %W corner %x %y]
	$W bind $tag <ButtonRelease-3>  [list ::ClipBox::MouseUp %W]
    }
    ::ClipBox::DrawAtlas $W
}
##+##########################################################################
#
# ::ClipBox::DrawAtlas -- repositions all elements of our clipbox
#
proc ::ClipBox::DrawAtlas {W} {
    foreach {xy xy2} [::ClipBox::GetBoxCoords] break
    foreach {bxy wxy hxy} [::ClipBox::GetSmallBoxCoords] break
    foreach {top bot} [::ClipBox::NorthArrow] break
    $W coords clip $xy
    $W coords dash $xy2
    $W coords corner $bxy
    $W coords width $wxy
    $W coords height $hxy
    $W coords northText $top
    $W coords northLine [concat $top $bot]
}
##+##########################################################################
#
# GetBoxCoords -- given topleft corner, width, height and angle
# returns coordinates of the box
#
proc ::ClipBox::GetBoxCoords {} {
    variable P

    set w $P(w)
    set h $P(h)
    set a $P(a,deg)

    set a [expr {$a * acos(-1) / 180}]		;# Radians

    foreach {x0 y0} $P(0) break
    set x1 [expr {$x0 + $w*cos($a)}]
    set y1 [expr {$y0 + $w*sin($a)}]
    set P(1) [list $x1 $y1]

    set top [::Data::VSub $P(1) $P(0)]
    set left [::Data::VNormalTo $top $h]
    set P(3) [::Data::VAdd $P(0) $left]
    set P(2) [::Data::VAdd $P(3) $top]

    set xy [concat $P(0) $P(1) $P(2) $P(3)]

    set offset 5
    set nTop  [::Data::VReScale $top 1]
    set nLeft [::Data::VReScale $left 1]
    set p0 [::Data::VAdd $P(0) $nTop -$offset]
    set p0 [::Data::VAdd $p0 $nLeft -$offset]
    set p1 [::Data::VAdd $p0 $nTop [expr {$w + 2*$offset}]]
    set p3 [::Data::VAdd $p0 $nLeft [expr {$h + 2*$offset}]]
    set p2 [::Data::VAdd $p3 $nTop [expr {$w + 2*$offset}]]
    set xy2 [concat $p0 $p1 $p2 $p3]

    return [list $xy $xy2]
}
##+##########################################################################
#
# GetSmallBoxCoords -- returns coords for rotate box and two sizing boxes
#
proc ::ClipBox::GetSmallBoxCoords {} {
    variable P
    variable M

    # Assumes P(0-3) are correct
    set top  [::Data::VSub $P(1) $P(0)]
    set left [::Data::VSub $P(3) $P(0)]
    set nTop  [::Data::VReScale $top 1]
    set nLeft [::Data::VReScale $left 1]

    set c2 $P(2)
    set c1 [::Data::VAdd $c2 $nLeft -$M(cornerSize)]
    set c0 [::Data::VAdd $c1 $nTop -$M(cornerSize)]
    set c3 [::Data::VAdd $c0 $nLeft $M(cornerSize)]
    set cxy [concat $c0 $c1 $c2 $c3]

    # Width adjust box
    set w [::Data::VAdd $P(1) $left .5]
    set rSize2 [expr {$M(resizeSize)/2.0}]
    set w1 [::Data::VAdd $w $nLeft -$rSize2]
    set w0 [::Data::VAdd $w1 $nTop -$M(resizeSize)]
    set w3 [::Data::VAdd $w0 $nLeft $M(resizeSize)]
    set w2 [::Data::VAdd $w3 $nTop $M(resizeSize)]
    set wxy [concat $w0 $w1 $w2 $w3]

    # Height adjust box
    set h [::Data::VAdd $P(3) $top .5]
    set h2 [::Data::VAdd $h $nTop $rSize2]
    set h1 [::Data::VAdd $h2 $nLeft -$M(resizeSize)]
    set h0 [::Data::VAdd $h1 $nTop -$M(resizeSize)]
    set h3 [::Data::VAdd $h0 $nLeft $M(resizeSize)]
    set hxy [concat $h0 $h1 $h2 $h3]

    return [list $cxy $wxy $hxy]
}
##+##########################################################################
#
# NorthArrow -- computes where north compass arrow should be positioned
#
proc ::ClipBox::NorthArrow {} {
    variable P

    while {$P(a,deg) > 180} { set P(a,deg) [expr {$P(a,deg) - 360}] }
    while {$P(a,deg) < -180} { set P(a,deg) [expr {$P(a,deg) + 360}] }

    set cornerOffset 35
    set fudgeFactor {0 15}
    set arrowLength {0 150}

    set dir [expr {$P(a,deg) >= 0 ? 1 : -1}]
    if {($P(a,deg) >= 0 && $P(a,deg) <= 90) || $P(a,deg) < -90} {
	set bisect [::Data::VBisect $P(1) $P(0) $P(3)]
	set pt $P(0)
    } else {
	set bisect [::Data::VBisect $P(2) $P(3) $P(0)]
	set pt $P(3)
    }
    set pt1 [::Data::VAdd $pt $bisect $cornerOffset]
    set top [::Data::VAdd $pt1 $fudgeFactor]
    set bot [::Data::VAdd $top $arrowLength $dir]
    if {$dir == -1} {foreach {top bot} [list $bot $top] break}
    return [list $top $bot]
}
##+##########################################################################
#
# ::ClipBox::MouseEnter -- Handles mousing around our clipbox
#
proc ::ClipBox::MouseEnter {W who} {
    variable M
    if {[info exists M(cursor,$who)]} {
	$W config -cursor $M(cursor,$who)
    }
}
##+##########################################################################
#
# ::ClipBox::MouseLeave -- Handles mousing around our clipbox
#
proc ::ClipBox::MouseLeave {W who} {
    variable M
    if {$M(mousing)} return			;# Mouse down, don't change
    $W config -cursor {}
}
##+##########################################################################
#
# ::ClipBox::MouseDown -- Handles mousing around our clipbox
#
proc ::ClipBox::MouseDown {W who x y} {
    variable M
    variable P

    if {$who eq "corner" && ! $P(can,angle)} return

    set M(xy) [list [$W canvasx $x] [$W canvasy $y]]
    set M(mousing) 1
    if {$who eq "corner"} {
	$W config -cursor $M(cursor,corner)
	::ClipBox::FourCorners $W

	# Create pivot
	foreach {X Y} $P(0) break
	set xy [list [expr {$X-10}] [expr {$Y-10}] [expr {$X+10}] [expr {$Y+10}]]
	$W create oval $xy -tag {BOX pivot} -fill black
	::ClipBox::MouseMove $W $who $x $y
    }
}
##+##########################################################################
#
# ::ClipBox::MouseUp -- Handles mousing around our clipbox
#
proc ::ClipBox::MouseUp {W} {
    variable M
    set M(mousing) 0
    $W delete pivot
    $W config -cursor {}
}
##+##########################################################################
#
# ::ClipBox::MouseMove -- Handles mousing around our clipbox
#
proc ::ClipBox::MouseMove {W who x y} {
    variable M
    variable P

    set x [$W canvasx $x]
    set y [$W canvasy $y]
    if {$who eq "corner"} {
	if {! $P(can,angle)} return
	::ClipBox::MouseSpin $W $who $x $y
    } elseif {$who eq "width" || $who eq "height"} {
	::ClipBox::MouseResize $W $who $x $y
    } else {
	foreach {bx by} $M(xy) break
	set M(xy) [list $x $y]
	set dx [expr {$x - $bx}]
	set dy [expr {$y - $by}]
	$W move BOX $dx $dy
	::ClipBox::FourCorners $W
	::ClipBox::Onscreen $W
    }
}
##+##########################################################################
#
# MouseSpin -- rotates clipbox to keep mouse point on the main diagonal
#
proc ::ClipBox::MouseSpin {W who x y} {
    variable P

    set v [::Data::VReScale [::Data::VSub [list $x $y] $P(0)] 1]
    set n [::Data::VDot [list 1 0] $v]
    set a1 [expr {acos($n)}]
    if {[lindex $v 1] < 0} { set a1 [expr {-$a1}] } ;# Quadrant check
    set a2 [expr {atan2($P(h), $P(w))}]
    set a3 [expr {$a1 - $a2}]
    set P(a,deg) [expr {$a3 * 180 / acos(-1)}]

    # If rotation is close to 90, then lock it into it
    foreach deg {-270 -180 -90 0 90 180 270} {
	if {abs($P(a,deg) - $deg) < 2} { set P(a,deg) $deg }
    }
    ::ClipBox::DrawAtlas $W
    ::ClipBox::Onscreen $W
}
##+##########################################################################
#
# MouseResize -- resizes clipbox vertically or horizontally
#
proc ::ClipBox::MouseResize {W who x y} {
    variable P
    variable M

    ::ClipBox::FourCorners $W
    set top  [::Data::VSub $P(1) $P(0)]
    set left [::Data::VSub $P(3) $P(0)]
    set nTop  [::Data::VReScale $top 1]
    set nLeft [::Data::VReScale $left 1]

    if {$who eq "width"} {
	set p0 [::Data::VAdd $P(0) $left .5]
	set v [::Data::VSub [list $x $y] $p0]
	set w [::Data::VDot $nTop $v]

	if {$w < $M(minWidth)} return
	set P(w) $w
    } else {
	set p0 [::Data::VAdd $P(0) $top .5]
	set v [::Data::VSub [list $x $y] $p0]
	set h [::Data::VDot $nLeft $v]

	if {$h < $M(minHeight)} return
	set P(h) $h
    }
    ::ClipBox::DrawAtlas $W
    ::ClipBox::Onscreen $W
}
##+##########################################################################
#
# ::ClipBox::Onscreen -- figures out if clipbox is off the screen at all
#
proc ::ClipBox::Onscreen {W} {
    variable P

    if {[$W find withtag clip] eq {}} { return 1}
    foreach {x0 y0 x1 y1 x2 y2 x3 y3} [$W coords clip] break
    set l [expr {round([Min $x0 $x1 $x2 $x3])}]
    set r [expr {round([Max $x0 $x1 $x2 $x3])}]
    set t [expr {round([Min $y0 $y1 $y2 $y3])}]
    set b [expr {round([Max $y0 $y1 $y2 $y3])}]

    set cx0 [$W canvasx 0]
    set cy0 [$W canvasy 0]
    set cx1 [expr {$cx0 + [winfo width $W]}]
    set cy1 [expr {$cy0 + [winfo height $W]}]

    set onscreen 1
    if {$l < $cx0 || $t < $cy0 || $r > $cx1 || $b > $cy1} {
	set onscreen 0
    }
    $W itemconfig clip -fill $P(clr,$onscreen)
    return $onscreen
}
##+##########################################################################
#
# ::ClipBox::PointOnscreen -- Determines if a given point is still on the screen
#
proc ::ClipBox::PointOnscreen {W pt} {
    foreach {x y} $pt break
    set cx0 [$W canvasx 0]
    set cy0 [$W canvasy 0]
    set cx1 [expr {$cx0 + [winfo width $W]}]
    set cy1 [expr {$cy0 + [winfo height $W]}]

    return [expr {$x >= $cx0 && $x <= $cx1 && $y >= $cy0 && $y <= $cy1}]
}
##+##########################################################################
#
# FourCorners -- fills in our data structures with clipbox's corners
#
proc ::ClipBox::FourCorners {W} {
    variable P
    foreach idx {0 1 2 3} {x y} [$W coords clip] {
	set P($idx) [list $x $y]
    }
}
##+##########################################################################
#
# GetAtlasSizes -- computes parameters needed to crop, rotate
# and crop again the image
#
proc ::ClipBox::GetAtlasSizes {W} {
    variable P

    ::ClipBox::FourCorners $W
    foreach {x0 y0} $P(0) {x1 y1} $P(1) {x2 y2} $P(2) {x3 y3} $P(3) break
    set l [expr {round([Min $x0 $x1 $x2 $x3])}]
    set r [expr {round([Max $x0 $x1 $x2 $x3])}]
    set t [expr {round([Min $y0 $y1 $y2 $y3])}]
    set b [expr {round([Max $y0 $y1 $y2 $y3])}]
    #set P(bbox) [list $l $t $r $b]
    set P(bbox) [::ClipBox::World2Canvas $W $l $t $r $b]

    set dy [expr {$y1 - $y0}]
    set dx [expr {$x1 - $x0}]
    set dx2 [expr {$x3 - $x0}]
    set dy2 [expr {$y3 - $y0}]

    # Question: use values from p or recompute from coordinates???

    set P(a,rad) [expr {atan2($dy,$dx)}]
    set P(a,deg) [expr {$P(a,rad)*180/acos(-1)}]
    set P(w) [expr {round(hypot($dx,$dy))}]
    set P(h) [expr {round(hypot($dx2,$dy2))}]

    # R0 is topleft corner in the rotated image
    # R1 is bottomright corner in the rotated image
    set P(rx0) [expr {abs(round($dy2 * sin($P(a,rad))))}]
    set P(ry0) [expr {abs(round($dx * sin($P(a,rad))))}]
    set P(rx1) [expr {$P(rx0) + $P(w)}]
    set P(ry1) [expr {$P(ry0) + $P(h)}]
}
##+##########################################################################
#
# World2Canvas -- translates world coordinates into canvas ones
#
proc ::ClipBox::World2Canvas {W args} {
    set x0 [$W canvasx 0]
    set y0 [$W canvasy 0]
    set result {}
    foreach {x y} $args {
	set x [expr {round($x - $x0)}]
	set y [expr {round($y - $y0)}]
	lappend result $x $y
    }
    return $result
}
##+##########################################################################
#
# Snapshot -- extracts content of the clipbox, with the proper
# cropping and rotating.
#
proc ::ClipBox::Snapshot {W} {
    variable P

    # Hide everything except compass north and an outline box
    ::Display::HideToplevels 1
    raise [winfo toplevel $W]
    $W lower BOX ; $W raise north ; $W raise dash
    $W lower rtept ;# Zoom window
    update idletasks

    ::ClipBox::GetAtlasSizes $W
    set snap [image create photo -data $W]
    $W raise rtept ; $W raise BOX ; $W raise north ; $W lower dash
    ::Display::HideToplevels 0

    set crop [eval ::ClipBox::SafeCrop $snap $P(bbox)]
    image delete $snap

    if {$P(a,deg) == 0 || ! $P(can,angle)} {
	return $crop
    }

    set rot [image create photo]
    set chop [image create photo]
    $rot copy $crop -rotate $P(a,deg)
    $chop copy $rot -from $P(rx0) $P(ry0) $P(rx1) $P(ry1)

    image delete $crop
    image delete $rot

    return $chop
}
##+##########################################################################
#
# ::ClipBox::MoveForward -- Moves clipbox forward afters napping (if room)
#
proc ::ClipBox::MoveForward {W} {
    variable P

    return
    if {! [::ClipBox::PointOnscreen $W $P(1)]} return
    set v [::Data::VSub $P(1) $P(0)]
    set p [::Data::VAdd $P(1) $v .5]
    if {! [::ClipBox::PointOnscreen $W $p]} return

    set P(0) $P(1)
    ::ClipBox::DrawAtlas $W
}
##+##########################################################################
#
# SafeCrop -- crops image handling off image coordinates
#
proc ::ClipBox::SafeCrop {cimg left top right bottom} {
    set w [image width $cimg]
    set h [image height $cimg]

    set pad(l) [expr {$left < 0 ? -$left : 0}]
    set left [Max $left 0]
    set pad(t) [expr {$top < 0 ? -$top : 0}]
    set top [Max $top 0]
    set pad(r) [expr {$right > $w ? $right-$w : 0}]
    set right [Min $right $w]
    set pad(b) [expr {$bottom > $h ? $bottom-$h : 0}]
    set bottom [Min $bottom $h]

    set crop [image create photo]
    $crop copy $cimg -from $left $top $right $bottom
    set pimg [::ClipBox::PadImage $crop $pad(l) $pad(t) $pad(r) $pad(b)]

    return $pimg
}
##+##########################################################################
#
# PadImage -- adds requested borders to the image
#
proc ::ClipBox::PadImage {img left top right bottom} {
    if {$left == 0 && $top == 0 && $right == 0 && $bottom == 0} {return $img}

    set w [expr {[image width $img] + $left + $right}]
    set h [expr {[image height $img] + $top + $bottom}]

    set tmp [image create photo -width $w -height $h]
    $tmp put yellow -to 0 0 $w $h
    $tmp copy $img -to $left $top
    image delete $img
    return $tmp
}
##+##########################################################################
#
# ::ClipBox::IsPointInside -- determines if a point is in
# our clipbox. Used to figure out a better caption.
#
proc ::ClipBox::IsPointInside {x y} {
    variable P

    foreach {a b} {1 0  2 1  3 2  0 3} {
	set v [::Data::VSub $P($a) $P($b)]
	set v2 [::Data::VSub [list $x $y] $P($b)]
	set n [::Data::VDot $v $v2]
	if {$n < 0} { return 0 }
    }
    return 1
}
## EON CLIPBOX
## BON ARROW
##+##########################################################################
#
# ::Arrow::Go -- toggles display of arrows along the route
#
proc ::Arrow::Go {W} {
    global state msg

    if {! $::state(arrow)} {
	::Arrow::RemoveAllLegs
	::Arrow::CloseDialog
    } else {
	::Arrow::_DoRoute $W
    }
}
##+##########################################################################
#
# ::Arrow::AddLeg -- draws arrow for the very last leg of the route
#                    and also stop&go signs
#
proc ::Arrow::AddLeg {} {
    if {! $::state(arrow)} return
    if {[llength $::route(nodes)] < 2} return
    if {[llength $::route(nodes)] == 2} {
	# No arrow, only stop signs
	::Arrow::_StopSigns Go
	::Arrow::_StopSigns End
	return
    }

    ::Arrow::_Init .c ""
    foreach {pre nid post} [lrange $::route(nodes) end-2 end] break
    foreach {in out} [lrange $::route(roads) end-1 end] break
    ::Arrow::_RouteCorner .c $pre $in $nid $out $post

    ::Arrow::_StopSigns End
}
##+##########################################################################
#
# ::Arrow::RemoveLeg -- clears just one route arrow
#
proc ::Arrow::RemoveLeg {in nid out} {
    variable A
    variable ARROWS

    set tag "arrow/$in/$nid/$out"
    .c delete $tag
    array unset ARROWS .c,$tag
    if {[winfo exists $A(W)] && $A(arrowID) eq $tag} {
	::Arrow::CloseDialog
    }

    ::Arrow::_StopSigns End
}
##+##########################################################################
#
# ::Arrow::RemoveAllLegs -- Removes all arrows and stop signs from the route
#
proc ::Arrow::RemoveAllLegs {} {
    variable ARROWS

    if {! [winfo exists .c]} return
    .c delete arrow
    array unset ARROWS
    ::Arrow::CloseDialog
}
##+##########################################################################
#
# ::Arrow::_DoRoute -- Draws arrows for every turn on the route
#
proc ::Arrow::_DoRoute {W} {
    global route

    ::Arrow::_Init $W ""
    for {set i 1} {$i < [llength $route(roads)]} {incr i} {
	if {[lindex $route(turns) $i] eq "O"} continue ;# Omit
	set pre [lindex $route(nodes) [expr {$i-1}]]
	set in [lindex $route(roads) [expr {$i-1}]]
	set nid [lindex $route(nodes) $i]
	set out [lindex $route(roads) $i]
	set post [lindex $route(nodes) [expr {$i+1}]]

	::Arrow::_RouteCorner $W $pre $in $nid $out $post
    }
    ::Arrow::StopGoIfNeeded
}
##+##########################################################################
#
# ::Arrow::_StopFilter -- merges local how with state(arrow,stop&go)
#
proc ::Arrow::_StopFilter {how} {
    if {$::state(arrow,stop&go) eq "Both"} { return $how }
    if {$how eq "Both"} { return $::state(arrow,stop&go)}
    if {$::state(arrow,stop&go) eq $how} { return $how }
    return "None"
}
##+##########################################################################
#
# ::Arrow::_StopSigns -- draws stop/go sign at either or both ends
#
proc ::Arrow::_StopSigns {fixWho} {
    if {! $::state(arrow) || $::state(arrow,stop&go) eq "None" || $::route(roads) eq {}} {
	.c delete arrow_go arrow_end arrow_endgo
	return
    }
    set who [::Arrow::_StopFilter $fixWho]
    set same [::Route::Stop&Go]

    foreach {nid1g nid2g} $::route(nodes) break
    foreach {nid2s nid1s} [lrange $::route(nodes) end-1 end] break
    if {$who eq "Both" || $who eq "Go"} {
	::Arrow::_OneStopGoArrow .c go $nid1g $nid2g
    }

    if {$who eq "Both" || $who eq "End"} {
	::Arrow::_OneStopGoArrow .c end $nid1s $nid2s $same
    }
    catch {.c raise arrow_go arrow_end}

}
##+##########################################################################
#
# ::Arrow::_OneStopGoArrow -- draws the stop or go sign
#
proc ::Arrow::_OneStopGoArrow {w which nid1 nid2 {same 0}} {
    # Turn arrow_endgo into plain arrow_go
    set endgoTag [$w find withtag arrow_endgo]
    if {$endgoTag ne ""} {
	$w itemconfig $endgoTag -tag [list arrow arrow_go] -image ::img::go
    }

    set goTag [$w find withtag arrow_go]
    if {$same && $goTag ne ""} {
	set tag arrow_endgo
	$w itemconfig $goTag -tag [list arrow arrow_go arrow_endgo] \
	    -image ::img::endgo
	$w delete arrow_end
	return
    }

    set offset 30
    set tag "arrow_$which"

    $w delete $tag
    if {$nid1 eq {} || $nid2 eq {}} return

    foreach {x0 y0} [lindex $::nodes($nid1) 4] break
    foreach {x1 y1} [lindex $::nodes($nid2) 4] break
    if {$nid1 eq $nid2} { ;# Bug fix from laptop
	set x [expr {$x0 - $offset}]
	set y [expr {$y0 - $offset}]
    } else {
	set dx [expr {$x0 - $x1}]
	set dy [expr {$y0 - $y1}]
	set unit [expr {hypot($dx,$dy)}]

	set x [expr {$x0 + $offset * $dx / $unit}]
	set y [expr {$y0 + $offset * $dy / $unit}]
    }
    $w create image $x $y -anchor c -tag [list arrow $tag] \
	-image ::img::$which

    $w bind $tag <Button-1>  [list ::Arrow::_Button click $tag %W %x %y]
    $w bind $tag <B1-Motion> [list ::Arrow::_Button move  $tag %W %x %y]
    $w bind $tag <ButtonRelease-1> [list ::Arrow::_Button release $tag %W %x %y]
    $w bind $tag <Button-3> [list ::Arrow::LabelClick $tag %X %Y]
}
##+##########################################################################
#
# ::Arrow::LabelClick -- posts delete arrow popup menu
#
proc ::Arrow::LabelClick {tag x y} {
    .delpopup entryconfig 0 -label "Delete Arrow" \
	-command [list .c delete $tag]
    tk_popup .delpopup $x $y
}
##+##########################################################################
#
# ::Arrow::StopGoIfNeeded -- redraws stop/go signs if needed & doesn't exist
#                             called after Configure
#
proc ::Arrow::StopGoIfNeeded {} {
    set how $::state(arrow,stop&go)

    if {! $::state(arrow) || $how eq "None" || $::route(roads) eq {}} {
	.c delete arrow_go arrow_end arrow_endgo
	return
    }

    set hasGo [expr {[.c find withtag arrow_go] ne ""}]
    set hasEnd [expr {[.c find withtag arrow_end] ne ""}]
    set hasEndGo [expr {[.c find withtag arrow_endgo] ne ""}]

    if {$::state(arrow,stop&go) eq "Go"} {
	.c delete arrow_end
	.c delete arrow_endgo			;# NB. this kills arrow_go also
	if {! $hasGo || $hasEndGo} {::Arrow::_StopSigns Go}
    } elseif {$::state(arrow,stop&go) eq "End"} {
	.c delete arrow_go
	.c delete arrow_endgo
	if {! $hasEnd} {::Arrow::_StopSigns End}
    } elseif {$::state(arrow,stop&go) eq "Both"} {
	if {[::Route::Stop&Go]} {
	    .c delete arrow_go
	    .c delete arrow_end
	    if {! $hasEndGo} {
		::Arrow::_StopSigns Go
		::Arrow::_StopSigns End
	    }
	} else {
	    .c delete arrow_endgo
	    if {$hasGo && ! $hasEnd} {::Arrow::_StopSigns End}
	    if {! $hasGo && $hasEnd} {::Arrow::_StopSigns Go}
	    if {! $hasGo && ! $hasEnd} {::Arrow::_StopSigns Both}
	}
    }
}
##+##########################################################################
#
# ::Arrow::_RouteCorner -- draws arrow for just one corner of the route
#
proc ::Arrow::_RouteCorner {W pre in nid out post} {
    variable A
    variable ARROWS

    set tag "arrow/$in/$nid/$out"
    if {[$W find withtag $tag] ne ""} return	;# Already exists

    set arrowPos [::Arrow::_GetArrowPosition $W $pre $in $nid $out $post]
    if {$arrowPos eq {}} return
    lassign $arrowPos xy angles
    set ARROWS($W,$tag) [concat $angles $A(width) \
			     [list $A(shape)] $A(color) 0]
    ::Arrow::_DrawArrow $W $xy $tag

    return
#    set window [expr {$W eq ".zoom.c" ? "zoom" : "root"}]
#
#    foreach {. . lat lon} $::nodes($nid) break
#    foreach {x0 y0} [::Display::pos2canvas $window $lat $lon] break
#
#    foreach who {in out} {
#	set rid [set $who]
#	set pts [::Route::GetXYZ $rid]
#	set _xy($who) {}
#	foreach pt $pts {
#	    foreach {. . lat lon} $pt break
#	    eval lappend _xy($who) [::Display::pos2canvas $window $lat $lon]
#	}
#    }
#    if {[::Data::IsNorthNode $pre $nid]} {
#	set _xy(in) [::Data::2Reverse $_xy(in)]
#    }
#    if {[::Data::IsNorthNode $post $nid]} {
#	set _xy(out) [::Data::2Reverse $_xy(out)]
#    }
#    ::Arrow::_DrawCorner $W $x0 $y0 $_xy(in) $_xy(out) $tag
}

proc ::Arrow::_GetArrowPosition {W pre in nid out post} {
    variable A

    set window [expr {$W eq ".zoom.c" ? "zoom" : "root"}]

    foreach {. . lat lon} $::nodes($nid) break
    foreach {x0 y0} [::Display::pos2canvas $window $lat $lon] break

    foreach who {in out} {
	set rid [set $who]
	set pts [::Route::GetXYZ $rid]
	set _xy($who) {}
	foreach pt $pts {
	    foreach {. . lat lon} $pt break
	    eval lappend _xy($who) [::Display::pos2canvas $window $lat $lon]
	}
    }
    if {[::Data::IsNorthNode $pre $nid]} {
	set _xy(in) [::Data::2Reverse $_xy(in)]
    }
    if {[::Data::IsNorthNode $post $nid]} {
	set _xy(out) [::Data::2Reverse $_xy(out)]
    }

    set P1 [::Data::PixelAway $x0 $y0 $_xy(in) $A(dist)]
    set P2 [::Data::PixelAway $x0 $y0 $_xy(out) $A(dist)]
    if {$P1 eq "" || $P2 eq ""} return

    if {[::Data::VDistance $P1 $P2] < 2} {	;# U-Turn
	set V [::Data::VSub [list $x0 $y0] $P1]
	set N [::Data::VNormalTo $V $A(offset)]
	set d [expr {$A(dist) + $A(offset)}]

	set U0 [::Data::VAdd $P1 $N -1]
	set U3 [::Data::VAdd $P1 $N]
	set V [::Data::VReScale $V $d]
	set U1 [::Data::VAdd $U0 $V]
	set U2 [::Data::VAdd $U3 $V]
	set xy [concat $U0 $U1 $U2 $U3]
	set angles [concat uturn [::Arrow::_BackComputeAngles $xy]]
    } else {
	set N [::Data::VNormalTo [::Data::VSub $P1 $P2] $A(offset)]
	set xy [concat [::Data::VAdd $N $P1] \
		    [::Data::VAdd $N [list $x0 $y0]] \
		    [::Data::VAdd $N $P2]]
	set angles [concat bend [::Arrow::_BackComputeAngles $xy]]
    }
    return [list $xy $angles]
}

##+##########################################################################
#
# ::Arrow::_DrawCorner -- Draws an arrow at a specified corner
#  W : canvas to draw on
#  x0,y0 : coords of corner getting the arrow
#  xy_in, xy_out : route points for roads into and out of the corner
#  tag : canvas tag to give to the arrow
#
#proc ::Arrow::_DrawCorner {W x0 y0 xy_in xy_out tag} {
#   variable A
#   variable ARROWS
#
#    set P1 [::Data::PixelAway $x0 $y0 $xy_in $A(dist)]
#    set P2 [::Data::PixelAway $x0 $y0 $xy_out $A(dist)]
#    if {$P1 eq "" || $P2 eq ""} return
#
#    if {[::Data::VDistance $P1 $P2] < 2} {	;# U-Turn
#	set V [::Data::VSub [list $x0 $y0] $P1]
#	set N [::Data::VNormalTo $V $A(offset)]
#	set d [expr {$A(dist) + $A(offset)}]
#
#	set U0 [::Data::VAdd $P1 $N -1]
#	set U3 [::Data::VAdd $P1 $N]
#	set V [::Data::VReScale $V $d]
#	set U1 [::Data::VAdd $U0 $V]
#	set U2 [::Data::VAdd $U3 $V]
#	set xy [concat $U0 $U1 $U2 $U3]
#	set angles [concat uturn [::Arrow::_BackComputeAngles $xy]]
#    } else {
#	set N [::Data::VNormalTo [::Data::VSub $P1 $P2] $A(offset)]
#	set xy [concat [::Data::VAdd $N $P1] \
#		    [::Data::VAdd $N [list $x0 $y0]] \
#		    [::Data::VAdd $N $P2]]
#	set angles [concat bend [::Arrow::_BackComputeAngles $xy]]
#    }
#
#    set ARROWS($W,$tag) [concat $angles $A(width) \
#			     [list $A(shape)] $A(color) 0]
#    ::Arrow::_DrawArrow $W $xy $tag
#}
##+##########################################################################
#
# ::Arrow::_DrawArrow -- Draws the arrow on specified canvas
#
proc ::Arrow::_DrawArrow {w xy tag} {
    variable ARROWS
    foreach {. . . . width shape color} $ARROWS($w,$tag) break

    set n [$w create line $xy -tag [list arrow $tag] \
	       -width $width -fill $color -arrow last -arrowshape $shape]
    $w bind $n <Button-1>  [list ::Arrow::_Button click $n %W %x %y]
    $w bind $n <B1-Motion> [list ::Arrow::_Button move  $n %W %x %y]
    $w bind $n <ButtonRelease-1> [list ::Arrow::_Button release $n %W %x %y]
    $w bind $n <Double-Button-1> [list ::Arrow::Dialog %W $tag]
    if {$w eq ".c"} {
	$w bind $n <<MenuMousePress>> \
	    [list ::Display::DoPopupMenu %x %y arrow $tag]
    } else {
	$w bind $n <<MenuMousePress>> \
	    [list ::Zoom::DoPopupMenu %x %y arrow $tag]
    }
}
##+##########################################################################
#
# ::Arrow::_Button -- lets us drag arrows around
#
proc ::Arrow::_Button {what tag W x y} {
    variable cxy

    if {$what eq "click"} {
	$W config -cursor fleur
	set cxy($W) [list [$W canvasx $x] [$W canvasy $y]]
    } elseif {$what eq "release"} {
	$W config -cursor {}
    } elseif {$what eq "move"} {
	set x [$W canvasx $x] ; set y [$W canvasy $y] ;# Where mouse is now
	foreach {ox oy} $cxy($W) break		;# Where it was
	set dx [expr {$x - $ox}]
	set dy [expr {$y - $oy}]
	set cxy($W) [list $x $y]

	$W move $tag $dx $dy
    }
}
##+##########################################################################
#
# ::Arrow::_Init -- initializes variable A for a new arrow
#
proc ::Arrow::_Init {who arrowID {pos ""}} {
    variable A
    variable ARROWS

    ::Data::UniqueTrace ::Arrow::A(color)
    set A(canvas) $who
    set A(turn) -45
    set A(rotate) 0
    set A(dist) $::state(arrow,$who,dist)
    set A(width) $::state(arrow,$who,width)
    set A(shape) $::state(arrow,$who,shape)
    set A(color) $::state(arrow,$who,color)
    set A(offset) $::state(arrow,$who,offset)
    set A(isUTurn) 0
    set A(pos) $pos
    set A(uflip) 0
    set A(reset) ""

    if {$arrowID ne "" && [info exists ARROWS($who,$arrowID)]} {
	foreach {type A(dist) A(turn) A(rotate) A(width) A(shape) A(color) A(uflip)} \
	    $ARROWS($who,$arrowID) break
	set A(isNew) 0
	set A(isUTurn) [expr {$type eq "uturn"}]
	set A(reset) [list $who $arrowID $ARROWS($who,$arrowID)]
    } else {
	set arrowID arrow[incr A(idx)]
	set A(isNew) 1
    }
    set A(arrowID) $arrowID
}
##+##########################################################################
#
# ::Arrow::Dialog -- puts up create/update arrow dialog
# pos is set only when creating via popup menu
#
proc ::Arrow::Dialog {who arrowID {pos ""}} {
    variable A

    ::Arrow::_Init $who $arrowID $pos

    set W $A(W)
    set WB $W.body
    set WBTN $W.buttons
    set A(C) $WB.tableau.c
    set wtitle "$::state(progname) Arrow Dialog"
    set title $wtitle\n[expr {$A(isNew) ? "New Arrow" : "Arrow $arrowID"}]
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::arrow3 arrow3.gif]
    wm protocol $W WM_DELETE_WINDOW ::Arrow::CloseDialog

    ::ttk::button $WBTN.help -text "Help" -command [list ::Help::Help "Arrows"]
    ::ttk::button $WBTN.dismiss -text Close -command ::Arrow::CloseDialog
    ::Display::GridChildren $WBTN 2

    set A(WBTN) $WB.btn
    ::my::frame $WB.btn
    ::ttk::button $WB.btn.reset -text "Reset Arrow" -command ::Arrow::_ResetArrow
    ::ttk::button $WB.btn.del -text "Delete Arrow" -command ::Arrow::_DeleteArrow
    if {$A(isNew)} {
	#$WB.btn.add config -text "Place Arrow" -command ::Arrow::_PlaceArrow
	#$WB.btn.del config -state disabled
	$WB.btn.reset config -state disabled
    }

    ::my::frame $WB.tableau -borderwidth 2 -relief ridge
    $WB.tableau config -pad 5
    canvas $A(C) -width 200 -height 200 -scrollregion {-100 -100 100 100} \
	-bd 0 -highlightthickness 0
    ::Display::TileBGFix $A(C)
    set WBF $WB.tableau.f
    ::my::frame $WBF

    # knob section
    if {! $A(isUTurn) } {
	::my::label $WBF.fturn -text "Turn Angle"
	::ttk::scale $WBF.turn -from -180 -to 180 -variable ::Arrow::A(turn) \
	    -orient horizontal -command ::Arrow::_RedrawArrow
    } else {
	::ttk::checkbutton $WBF.fturn -text "Flip Arrow" \
	    -variable ::Arrow::A(uflip) -command ::Arrow::_RedrawArrow
    }

    ::my::frame $WBF.sep1 -pad 5
    ::my::label $WBF.frotate -text "Rotation"
    ::ttk::scale $WBF.rotate -from 180 -to -180 -variable ::Arrow::A(rotate) \
	-orient horizontal -command ::Arrow::_RedrawArrow
    ::tk::frame $WBF.sep2 -pady 5
    ::my::label $WBF.flength -text "Length"
    ::ttk::scale $WBF.length -from 10 -to 100 -variable ::Arrow::A(dist) \
	-orient horizontal -command ::Arrow::_RedrawArrow
    ::tk::frame $WBF.sep3 -pady 5
    ::my::label $WBF.fwidth -text "Thickness"
    ::ttk::scale $WBF.width -from 1 -to 10 -variable ::Arrow::A(width) \
	-orient horizontal -command ::Arrow::_RedrawArrow
    ::tk::frame $WBF.sep4 -pady 5
    ::my::label $WBF._color -text "Color"
    ::Config::ColorWidget $WBF.color ::Arrow::A(color)
    $WBF.color config -borderwidth 0
    ::Data::UniqueTrace ::Arrow::A(color) ::Arrow::_RedrawArrow

    pack $WB.btn -side bottom
    eval pack [winfo child $WB.btn] -side left -pady 10 -expand 1 -padx 10
    pack $WB.tableau -side top -fill both -expand 1

    pack $WB.tableau.c -fill both -expand 1 -side left
    pack $WB.tableau.f -side left
    eval pack [winfo child $WBF] -side top -anchor w

    if {$A(isNew)} {
	::Arrow::_AddArrow
	set A(isNew) 0
    }
    ::Arrow::_RedrawArrow

    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Arrow::CloseDialog -- cleans up from our dialog
#
proc ::Arrow::CloseDialog {} {
    variable A
    ::Data::UniqueTrace ::Arrow::A(color)
    destroy $A(W)
}
##+##########################################################################
#
# ::Arrow::_RedrawArrow -- updates arrow in dialog
#
proc ::Arrow::_RedrawArrow {args} {
    variable A

    set xy [::Arrow::_GetCoords 0 0]
    $A(C) delete all

    set shape [list [expr {2*$A(width)}] \
		   [expr {3*$A(width)}] \
		   [expr {1.5*$A(width)}]]
    $A(C) create line $xy -arrow last -width $A(width) -arrowshape $A(shape) \
	-fill $A(color)
    ::Arrow::_AddArrow
}
##+##########################################################################
#
# ::Arrow::_GetCoords -- reconstruct xy points for our arrow from A()
#
proc ::Arrow::_GetCoords {x y} {
    variable A

    if {$A(isUTurn)} {
	return [::Arrow::_GetUTurnCoords $x $y $A(rotate)]
    }

    set angle [expr {($A(turn) + $A(rotate)) * acos(-1) / 180}]
    set rotate [expr {$A(rotate) * acos(-1) / 180}]

    set x0 [expr {$x - $A(dist) * cos($rotate)}]
    set y0 [expr {$y - $A(dist) * sin($rotate)}]
    set x1 $x
    set y1 $y
    set x2 [expr {$x + $A(dist) * cos($angle)}]
    set y2 [expr {$y + $A(dist) * sin($angle)}]
    return [list $x0 $y0 $x1 $y1 $x2 $y2]
}
##+##########################################################################
#
# ::Arrow::_GetUTurnCoords -- gets xy coords for our u-turn arrow
#
proc ::Arrow::_GetUTurnCoords {x y rotate} {
    variable A

    set rotate [expr {$rotate * acos(-1) / 180}]

    set x1 [expr {$x - $A(dist) * cos($rotate)}]
    set y1 [expr {$y - $A(dist) * sin($rotate)}]
    set P1 [list $x1 $y1]

    set V [::Data::VSub [list $x $y] [list $x1 $y1]]
    set N [::Data::VNormalTo $V $A(offset)]
    if {$A(uflip)} {
	set N [::Data::VSub {0 0} $N]
    }
    set d [expr {$A(dist) + $A(offset)}]

    set U0 [::Data::VAdd $P1 $N -1]
    set U3 [::Data::VAdd $P1 $N]
    set V [::Data::VReScale $V $d]
    set U1 [::Data::VAdd $U0 $V]
    set U2 [::Data::VAdd $U3 $V]
    set xy [concat $U0 $U1 $U2 $U3]
}
##+##########################################################################
#
# ::Arrow::_AddArrow -- draws/updates arrow based on A() settings
#
proc ::Arrow::_AddArrow {} {
    variable A
    variable ARROWS

    if {! [winfo exists $A(canvas)]} return
    set type [expr {$A(isUTurn) ? "uturn" : "bend"}]
    set ARROWS($A(canvas),$A(arrowID)) \
	[list $type $A(dist) $A(turn) $A(rotate) \
	     $A(width) $A(shape) $A(color) $A(uflip)]

    if {$A(isNew)} {
	foreach {x y} $A(pos) break
	set xy [::Arrow::_GetCoords $x $y]
	::Arrow::_DrawArrow $A(canvas) $xy $A(arrowID)
    } else {					;# Existing arrow
	if {[$A(canvas) find withtag $A(arrowID)] eq ""} return
	foreach {x1 y1} [::Arrow::_GetOrigin] break
	set xy [::Arrow::_GetCoords $x1 $y1]
	$A(canvas) coords $A(arrowID) $xy
	$A(canvas) itemconfig $A(arrowID) -fill $A(color) -width $A(width)
    }
}
##+##########################################################################
#
# ::Arrow::_PlaceArrow -- called to initially create an arrow
#
proc ::Arrow::_PlaceArrow {} {
    variable A
    $A(WBTN).add config -text "Update Arrow" -command ::Arrow::_AddArrow
    $A(WBTN).del config -text "Delete Arrow" -state normal
    ::Arrow::_AddArrow
    set A(isNew) 0
}
##+##########################################################################
#
# ::Arrow::_ResetArrow -- Resets arrow to initial state
#
proc ::Arrow::_ResetArrow {} {
    variable A
    variable ARROWS

    if {$A(reset) eq ""} return
    foreach {who arrowID data} $A(reset) break
    set ARROWS($who,$arrowID) $data
    foreach {type A(dist) A(turn) A(rotate) A(width) A(shape) A(color) A(uflip)} \
	$ARROWS($who,$arrowID) break
    ::Arrow::_RedrawArrow
}
##+##########################################################################
#
# ::Arrow::_DeleteArrow -- deletes our arrow
#
proc ::Arrow::_DeleteArrow {} {
    variable A
    variable ARROWS

    $A(canvas) delete $A(arrowID)
    array unset ARROWS $A(canvas),$A(arrowID)
    ::Arrow::CloseDialog
}
##+##########################################################################
#
# ::Arrow::_GetOrigin -- figures out where to place arrow
#
proc ::Arrow::_GetOrigin {} {
    variable A

    foreach {x0 y0 x1 y1 x2 y2} [$A(canvas) coords $A(arrowID)] break
    if {$A(isUTurn)} {
	set V0 [::Data::VSub [list $x0 $y0] [list $x1 $y1]]
	set V1 [::Data::VSub [list $x2 $y2] [list $x1 $y1]]
	set N [::Data::VReScale $V0 $A(offset)]
	set P [::Data::VAdd [::Data::VAdd [list $x1 $y1] $V1 .5] $N]
	foreach {x1 y1} $P break
    }
    return [list $x1 $y1]
}
##+##########################################################################
#
# ::Arrow::_BackComputeAngles -- given arrow coordinates, computes
# dist, turn and rotate for it.
#
proc ::Arrow::_BackComputeAngles {xy} {
    variable A

    foreach {x0 y0 x1 y1 x2 y2} $xy break

    set V1 [::Data::VReScale [::Data::VSub [list $x1 $y1] [list $x0 $y0]] 1]
    set V2 [::Data::VReScale [::Data::VSub [list $x2 $y2] [list $x1 $y1]] 1]
    set dot [::Data::VDot $V1 $V2]
    set turn [expr {acos($dot) * 180 / acos(-1)}]
    set cross [::Data::VCross $V1 $V2]
    if {$cross < 0} { set turn [expr {-$turn}]}

    set V1 [::Data::VReScale $V1 -1]
    set dot [::Data::VDot $V1 [list -1 0]]
    set cross [::Data::VCross $V1 [list -1 0]]
    set rotate [expr {acos($dot) * 180 / acos(-1)}]
    if {$cross > 0} { set rotate [expr {-$rotate}]}

    return [list $A(dist) $turn $rotate]
}
##+##########################################################################
#
# ::Arrow::DumpArrowInfo -- serialize arrow info for saving w/ route
#
proc ::Arrow::DumpArrowInfo {} {
    variable A
    variable ARROWS

    ::Arrow::CloseDialog
    set dump "array set Rarrows {\n"
    foreach arr [lsort -dictionary [array names ARROWS .c,*]] {
	foreach {who arrowID} [split $arr ","] break
	::Arrow::_Init $who $arrowID
	set O [::Arrow::_GetOrigin]
	foreach {x y} $O break

	append dump [format "    %-25s  {%s}\n" "$arr,arr" $ARROWS($arr)]
	append dump [format "    %-25s {%s}\n" "$arr,org" $O]
	#foreach {. . . . lat lon} [::Display::canvas2pos $x $y] break
	#set lon [expr {-$lon}]
	#append dump [format "    %-25s {%s %s}\n" "$arr,pos" $lat $lon]
    }

    # Add stop/end arrows
    foreach tag {endgo go end} {
	set n [.c find withtag arrow_$tag]
	if {$n eq {}} continue
	set xy [eval [list format "%.0f %.0f"] [.c coords $n]]
	append dump "    $tag,sign {$xy}\n"
	if {$tag eq "endgo"} break
    }

    append dump "}"
    return $dump
}
##+##########################################################################
#
# ::Arrow::UnDumpArrowInfo -- used by load route to restore arrows
#
proc ::Arrow::UnDumpArrowInfo {varName} {
    variable A
    variable ARROWS

    upvar 1 $varName Rarrows
    foreach arr [array names Rarrows *,arr] {
	foreach {who arrowID .} [split $arr ","] break
	set ARROWS($who,$arrowID) $Rarrows($arr)
	::Arrow::_Init .c $arrowID
	set A(isNew) 1
	set A(pos) $Rarrows($who,$arrowID,org)

	::Arrow::_AddArrow
    }

    foreach arr [array names Rarrows *,sign] {
	foreach {who .} [split $arr ","] break
	set type [string totitle [expr {$who eq "endgo" ? "both" : $who}]]
	::Arrow::_StopSigns $type
	eval .c coords arrow_$who $Rarrows($arr)
    }

}
## EON ARROW
## BON FAVORITES
##+##########################################################################
#
# ::Favorites::Toggle -- Displays or destroys the favorites dialog
#
proc ::Favorites::Toggle {} {
    if {$::state(favorites)} {
	::Favorites::Dialog
    } else {
	::Favorites::CloseDialog
    }
}
##+##########################################################################
#
# ::Favorites::Dialog -- Puts up the favorites dialog
#
proc ::Favorites::Dialog {} {
    variable S

    ::Favorites::ReadData
    ::Favorites::CreateImages

    set W $S(W)
    set WB $W.body
    set WBTN $W.buttons
    set wtree $WB.tree
    set wtitle "$::state(progname) Favorites"
    set title $wtitle

    ::Display::MakeDialogBox $W $wtitle $title [list ::img::fav favorites.gif]
    wm transient $W .
    wm protocol $W WM_DELETE_WINDOW ::Favorites::CloseDialog
    wm resizable $W 1 1

    ::ttk::button $WBTN.help -text "Help" -command {::Help::Help "Favorites"}
    ::ttk::button $WBTN.web -text "Update from Web" \
	-command [list ::Favorites::GetWebUpdate $wtree]
    if {! [::Data::CanDo internet]} { $WBTN.web config -state disabled }
    destroy $WBTN.web
    ::ttk::button $WBTN.dismiss -text "Dismiss" -command ::Favorites::CloseDialog
    ::Display::GridChildren $WBTN 1

    # Add our multi-column list
    ::ttk::treeview $wtree -columns $S(headers) -show headings \
	-yscroll "$WB.vsb set" -xscroll "$WB.hsb set" -selectmode browse
    bind $wtree <<TreeviewSelect>> [list ::Favorites::TreeSelection $wtree]
    ::ttk::scrollbar $WB.vsb -orient vertical -command "$wtree yview"
    ::ttk::scrollbar $WB.hsb -orient horizontal -command "$wtree xview"

    ::my::frame $WB.buttons
    ::ttk::checkbutton $WB.buttons.region -text "Only current region" \
	-variable ::Favorites::S(thisRegion) \
	-command [list ::Favorites::Filter $wtree]
    ::my::label $WB.buttons.msg -textvariable ::Favorites::S(msg) -anchor c \
	-foreground red -font boldFont
    set ::Favorites::S(msg) ""

    set nlist {}
    foreach nid $::region(node,visible) {
	lappend nlist [::Edit::PrettyNode $nid]
    }
    set nlist [concat -- [lsort -dictionary $nlist]]
    ::my::frame $WB.nfilter
    ::ttk::checkbutton $WB.nfilter.cbutton -text "Containing node" \
	-variable ::Favorites::S(nodeFilter) \
	-command [list ::Favorites::Filter $wtree]
    ::ttk::combobox $WB.nfilter.cbox -textvariable Favorites::S(nodeFilter,val) \
	-state readonly -values $nlist -width 5 -exportselection 0 -takefocus 0 \
	-justify c
    ::Data::UniqueTrace ::Favorites::S(nodeFilter,val) \
	[list ::Favorites::Filter $wtree]

    grid $wtree $WB.vsb -sticky nsew
    grid $WB.hsb          -sticky nsew
    grid $WB.buttons - -sticky ew
    grid $WB.nfilter - -sticky ew
    pack $WB.buttons.region -side left
    pack $WB.buttons.msg -side left -fill x -expand 1
    pack $WB.nfilter.cbutton $WB.nfilter.cbox -side left

    grid columnconfigure $WB 0 -weight 1
    grid rowconfigure    $WB 0 -weight 1

    ::Favorites::FillTable $wtree
    if {$S(thisRegion)} {
	::Favorites::Filter $wtree
    }
    eval [list ::Favorites::SortBy $wtree] $S(lastSort)
    ::Favorites::BandTable $wtree
    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Favorites::CloseDialog -- Closes and cleans up the favorites dialog
#
proc ::Favorites::CloseDialog {} {
    variable S
    variable RDATA

    destroy $S(W)
    unset -nocomplain RDATA
    set ::state(favorites) 0
}
##+##########################################################################
#
# ::Favorites::CreateImages -- Create arrows for visual sorting clues
#
proc ::Favorites::CreateImages {} {
    if {[info commands ::Favorites::arrow(0)] ne ""} return
    image create bitmap ::Favorites::arrow(0) -data {
	#define arrowUp_width 7
	#define arrowUp_height 4
	static char arrowUp_bits[] = {
	    0x08, 0x1c, 0x3e, 0x7f
	};
    }
    image create bitmap ::Favorites::arrow(1) -data {
	#define arrowDown_width 7
	#define arrowDown_height 4
	static char arrowDown_bits[] = {
	    0x7f, 0x3e, 0x1c, 0x08
	};
    }
    image create bitmap ::Favorites::arrowBlank -data {
	#define arrowBlank_width 7
	#define arrowBlank_height 4
	static char arrowBlank_bits[] = {
	    0x00, 0x00, 0x00, 0x00
	};
    }
}
##+##########################################################################
#
# ::Favorites::FillTable -- Puts in RDATA into the table
#
proc ::Favorites::FillTable {wtree} {
    variable S
    variable RDATA

    $wtree delete [$wtree children {}]

    set font [::ttk::style lookup [$wtree cget -style] -font]
    if {$font eq ""} {
	set font boldFont
    }
    foreach col $S(headers) w $S(widths) {
	set name [string totitle $col]
	$wtree heading $col -text $name -image ::Favorites::arrowBlank \
	    -command [list ::Favorites::SortBy $wtree $col 0]
	$wtree column $col -anchor c -width $w ;#[font measure $font xxx$name]
    }
    set lnum -1
    foreach id [lsort -dictionary [array names RDATA]] {
	$wtree insert {} end -id $id -values $RDATA($id) -tag tag[incr lnum]

	# Fix up column widths
	foreach col $S(headers) value $RDATA($id) {
	    if {$col eq ""} break
	    set len [font measure $font "$value  "]
	    if {[$wtree column $col -width] < $len} {
		$wtree column $col -width $len
	    }
	}
    }
}
##+##########################################################################
#
# ::Favorites::Filter -- Applies the "current region only" filter
#
proc ::Favorites::_oldFilter {wtree} {
    variable S

    if {$S(thisRegion)} {			;# Exclude non-region routes
	foreach rowID [$wtree children {}] {
	    if {! [::Favorites::CheckRegion $wtree $rowID]} {
		$wtree delete $rowID
	    }
	}
	::Favorites::BandTable $wtree
    } else {
	$wtree delete [$wtree children {}]
	::Favorites::FillTable $wtree
	eval [list ::Favorites::SortBy $wtree] $S(lastSort)
    }
}
##+##########################################################################
#
# ::Favorites::Filter -- Applies current region and contains node filters
#
proc ::Favorites::Filter {wtree args} {
    variable S
    variable RDATA

    if {! [winfo exists $wtree]} return
    $wtree delete [$wtree children {}]
    ::Favorites::FillTable $wtree

    set nid [::Edit::FindNode $S(nodeFilter,val)]
    set doNodeFilter [expr {$S(nodeFilter) && $nid ne ""}]

    if {$S(thisRegion) || $doNodeFilter} {
	foreach rowID [$wtree children {}] {
	    if {$S(thisRegion) && ! [::Favorites::CheckRegion $wtree $rowID]} {
		$wtree delete $rowID
		continue
	    }
	    if {$doNodeFilter} {
		set path [lindex $RDATA($rowID) 4]
		if {! [::Data::NodeInPath $nid $path]} {
		    $wtree delete $rowID
		    continue
		}
	    }
	}
    }
    eval [list ::Favorites::SortBy $wtree] $S(lastSort)
}
##+##########################################################################
#
# ::Favorites::CheckRegion -- Makes sure fav's region is ok
# Region:
#   - one region -- easy
#   - multiple regions -- must be a subset
#   - "multiple" -- check extra regions
#
proc ::Favorites::CheckRegion {wtree id} {
    variable RDATA

    return [::Favorites::IsRouteVisible $id]

    set datum [$wtree set $id 0]		;# Extract region info
    if {$datum eq "Multiple"} {
	set extra [lindex $RDATA($id) 6]
	foreach where $extra {
	    set n [::Region::IsSubset [list $where]]
	    if {$n > 0} { return $n }
	}
	return 0
    } else {
	regsub -all {,\s+} $datum "," datum	;# May need multiple regions
	set where [split $datum ","]

	return [::Region::IsSubset $where]
    }
}
##+##########################################################################
#
# ::Favorites::IsRouteVisible -- Return true if route is visible
# in our current region
#
proc ::Favorites::IsRouteVisible {id} {
    variable RDATA

    set rids [lassign [lindex $RDATA($id) 4] nid]
    if {[lsearch $::region(node,visible) $nid] == -1} { return 0 } ;# Need start
    set cnt 0
    foreach rid $rids {
	if {[lsearch $::region(road,visible) $rid] > -1} {
	    incr cnt
	}
    }
    return [expr {$cnt > 1}]
}
##+##########################################################################
#
# ::Favorites::SortBy -- Sorts table by column clicked on
#
proc ::Favorites::SortBy {wtree col direction} {
    variable S

    set S(lastSort) [list $col $direction]

    # Build something we can sort
    set data {}
    foreach row [$wtree children {}] {
	set datum [$wtree set $row $col]
	if {$col eq "climbing"} {
	    set datum [string map {, ""} $datum] ;# Handle commas
	}
	lappend data [list $datum $row]
    }

    # Now reshuffle the rows into the sorted order
    set dir [expr {$direction ? "-decreasing" : "-increasing"}]
    set r -1
    foreach rinfo [lsort -dictionary -index 0 $dir $data] {
	$wtree move [lindex $rinfo 1] {} [incr r]
    }

    # Switch the heading so that it will sort in the opposite direction
    $wtree heading $col -command \
	[list ::Favorites::SortBy $wtree $col [expr {!$direction}]]
    ::Favorites::BandTable $wtree
    ::Favorites::ArrowTable $wtree $col $direction
}
##+##########################################################################
#
# ::Favorites::BandTable -- Visually fixes up table by adding colored bands
#
proc ::Favorites::BandTable {wtree} {
    variable S

    set id 0
    foreach row [$wtree children {}] {
	set id [expr {! $id}]
	set tag [$wtree item $row -tag]
	$wtree tag configure $tag -background $S(bandColor,$id)
    }
}
##+##########################################################################
#
# ::Favorites::ArrowTable -- Configs headings to show sort arrow
#
proc ::Favorites::ArrowTable {wtree sortCol dir} {
    set idx -1
    foreach col [$wtree cget -columns] {
	incr idx
	set img ::Favorites::arrowBlank
	if {$col == $sortCol} {
	    set img ::Favorites::arrow($dir)
	}
	$wtree heading $idx -image $img
    }
}
##+##########################################################################
#
# ::Favorites::TreeSelection -- Handles clicking on a favorite
#
proc ::Favorites::TreeSelection {wtree} {
    variable S

    set id [$wtree selection]
    set n [::Favorites::LoadRoute $wtree $id]

    set tag [$wtree item $id -tag]
    ::Favorites::BandTable $wtree		;# Unmark previous selected
    $wtree tag configure $tag -background $S(bandColor,selected,$n)
}
##+##########################################################################
#
# ::Favorites::LoadRoute -- Loads selected route into KLIMB
#
proc ::Favorites::LoadRoute {wtree id} {
    variable S
    variable RDATA
    global route

    foreach {rregion rtitle . . rte rturns} $RDATA($id) break

    ::Route::ClearRoute
    set S(msg) ""
    if {! [::Favorites::CheckRegion $wtree $id]} {
	set S(msg) "WARNING: route outside current region"
	if {! $::state(su)} { return 0}
    }
    set bad [::Favorites::CheckRoads $rte]
    if {$bad ne {}} {
	set S(msg) "ERROR: missing roads"
	set emsg "ERROR: Some roads on this route no longer exist.\n"
	append emsg "Try reloading or reverting this region.\n\n"
	append emsg "Details: [join $bad {, }]"
	WARN $emsg
	return 0
    }
    if {! [::Favorites::CheckVisibility $rte]} {
	set S(msg) "This route is off the map"
	return 0
    }

    set type node
    foreach id $rte {
	::Route::CheckRoute $type $id
	set type road
    }
    set route(title) [expr {$rtitle eq "" ? $id : $rtitle}]
    set rturns [split $rturns ""]
    if {[llength $rturns] == [llength $rte]} {
	set route(turns) $rturns
	# TODO: Erase omitted arrows
    }

    ::Display::BestFit
    ::RInfo::Refresh?
    return 1
}
##+##########################################################################
#
# ::Favorites::CheckRoads -- Makes sure all roads still exist
#
proc ::Favorites::CheckRoads {rte} {
    global bad
    unset -nocomplain bad
    set bad {}
    if {! [info exists ::nodes([lindex $rte 0])]} { lappend bad [lindex $rte 0]}
    foreach rid [lrange $rte 1 end] {
	if {! [info exists ::roads($rid)]} { lappend bad $rid }
    }
    return $bad
}
##+##########################################################################
#
# ::Favorites::CheckVisibility -- Makes sure at least the starting
# node is visible.
#
proc ::Favorites::CheckVisibility {rte} {
    if {[lsearch $::region(node,visible) [lindex $rte 0]] == -1} { return 0 }
    return 1
}
##+##########################################################################
#
# ::Favorites::IsValid -- Makes sure current route is allowed to be added
#
proc ::Favorites::IsValid {rids nids} {
    if {$::state(su)} { return 1}
    if {[lsearch -glob $rids X*] > -1} { return 0}
    if {[lsearch -glob $nids X*] > -1} { return 0}
    return 1
}
##+##########################################################################
#
# ::Favorites::FindFavoritesFiles -- Returns the favorites files for this zone
#
proc ::Favorites::FindFavoritesFiles {who} {
    set system [file join $::state(zdir) favorites.data]
    set user [file join $::state(zdir) favorites.user]
    if {$who eq "user"} { return $user }
    if {$who eq "system"} { return $system }
    return [list $system $user]
}
##+##########################################################################
#
# ::Favorites::AppendRoute -- Adds current route to our favorites file
#
proc ::Favorites::AppendRoute {} {
    global route state msg

    set emsg {}
    if {$route(roads) eq {}} {
	set emsg "Empty route"
    } elseif {! [::Favorites::IsValid $route(roads) $route(nodes)]} {
	set emsg "Route contains user data.\n\nCannot append to favorites"
    } elseif {$route(title) eq ""} {
	set emsg "Please enter a title for the route"
    }
    if {$emsg ne ""} {
	WARN $emsg
	return
    }

    # Package up our data
    set data [list [string map {, \\,} $state(region,pretty2)]]
    lappend data [string map {, \\,} $route(title)]
    lappend data [::Data::Convert $msg(dist2) dist]
    lappend data [::Data::Convert $msg(climb2) climb]
    lappend data [concat [lindex $route(nodes) 0] $route(roads)]
    set turns [join $route(turns) ""]
    if {[regexp {^BN*E$} $turns]} { set turns "B" }
    lappend data $turns
    set data [join $data ","]

    set line [::Favorites::PackageRoute \
		  $state(region,pretty2) \
		  $route(title) \
		  [::Data::Convert $msg(dist2) dist] \
		  [::Data::Convert $msg(climb2) climb] \
		  [concat [lindex $route(nodes) 0] $route(roads)] \
		  [join $route(turns) ""]]


    set fname [::Favorites::FindFavoritesFiles user]
    set n [catch {set fout [open $fname a]} emsg]
    if {$n} { WARN "ERROR: $emsg"; return }

    puts $fout $data
    close $fout
    DoInfo "Current route added to favorites" "KLIMB Favorites"
}
proc ::Favorites::PackageRoute {region title dist climb rte turns} {
    set region [string map {, \\,} $region]
    set title [string map {, \\,} $title]
    if {[regexp {^BN*E$} $turns]} { set turns "B" }

    set data [list $region $title $dist $climb $rte $turns]
    set line [join $data ","]
    return $line
}
##+##########################################################################
#
# ::Favorites::ReadData -- Reads in the favorites file into RDATA
#
# <region>,<title>,<distance>,<climbing>,<rte>,<turns>?,<extra regions>
# Multiple,Day 1,58.2,6267,Xn1 r1 r4 r5 r3 r6 r7 r8,BNNNNNNE,all "Day 1" "Day 1@15"
# <region> can be 1 region, >1 region or "Multiple"
#
proc ::Favorites::ReadData {} {
    variable RDATA
    unset -nocomplain RDATA
    set data [::Favorites::_ReadData all]
    array set RDATA $data
}
proc ::Favorites::_ReadData {who} {
    unset -nocomplain _rdata
    unset -nocomplain dups
    set fnames [::Favorites::FindFavoritesFiles $who]
    set id 0
    foreach fname $fnames {
	if {! [file exists $fname]} continue

	set n [catch {set fin [open $fname r]} emsg]
	if {$n} {
	    WARN "ERROR: $emsg"
	    ::Favorites::CloseDialog
	    return
	}

	while {[gets $fin line] > -1} {
	    set line [string trim $line]
	    if {$line eq "" || [string match "\#*" $line]} continue

	    set line [string map {\\, \x00} $line] ;# Take care w/ escaped commas
	    regsub -all {\s*,\s*} $line {,} line
	    set datum [split $line ","]
	    set datum [string map {\x00 ,} $datum]
	    foreach {reg . . . rte} $datum break

	    # Metric handling
	    lset datum 2 [::Data::Convert [lindex $datum 2] dist]
	    lset datum 3 [comma [::Data::Convert [lindex $datum 3] climb]]

	    if {[info exists dups($reg,$rte)]} {	;# Duplicate
		set tag $dups($reg,$rte)		;# Replace old one
	    } else {
		set tag [format "ID%03d" [incr id]]	;# New entry, new ID
	    }
	    if {[lindex $datum 1] eq ""} { lset datum 1 $tag }
	    set _rdata($tag) $datum
	    set dups($rte) $tag
	}
	close $fin
    }
    return [array get _rdata]
}
##+##########################################################################
#
# ::Favorites::RenumberNode -- Renumbers node for every favorites file
#
proc ::Favorites::RenumberNode {pre post} {
    set cnt 0
    set changed 0

    foreach fname [::Favorites::FindFavoritesFiles all] {
	set result [::Favorites::_RenumberNode $fname $pre $post]
	foreach {changed2 cnt2} $result break
	incr changed $changed2
	incr cnt $cnt2
    }
    return [list $changed $cnt]
}
##+##########################################################################
#
# ::Favorites::_RenumberNode -- Renumbers nodes for one favorite file
#
proc ::Favorites::_RenumberNode {fname pre post} {
    if {! [file exists $fname]} { return [list 0 0] }

    set data [::Data::ReadAllText $fname]
    set newData ""
    set changed 0
    set cnt 0
    foreach line [split $data \n] {
	set line [string trim $line]
	if {$line eq "" || [string match "\#*" $line]} {
	    append newData $line \n
	    continue
	}

	incr cnt
	set line2 [string map {\\, \x00} $line] ;# Take care w/ escaped commas
	regsub -all {\s*,\s*} $line2 {,} line2
	set datum [split $line2 ","]
	set nid [lindex $datum 4 0]
	set newNid [::Renumber::RenumberNodesList $nid $pre $post]
	if {$newNid ne $nid} {
	    lset datum 4 0 $newNid
	    set line [join $datum ","]
	    set line [string map {\x00 \\,} $line]
	    incr changed
	}
	append newData $line \n
    }
    if {$changed} {
	::Data::WriteAllText $fname $newData 0 backup
    }
    return [list $changed $cnt]
}
##+##########################################################################
#
# ::Favorites::InstallNew -- Copies in new favorites data from the web
#
proc ::Favorites::InstallNew {data} {
    if {$data eq ""} return
    set fname [::Favorites::FindFavoritesFiles system]
    if {[file exists $fname] && [file size $fname] == [string length $data]} {
	DoInfo "Favorites are already up to date" "KLIMB Favorites"
	return
    }
    ::Data::BackupFile $fname

    set n [catch {set fout [open $fname w]} emsg]
    if {$n} { WARN "ERROR: $emsg"; return }
    fconfigure $fout -translation binary
    puts -nonewline $fout $data
    close $fout

    if {[winfo exists $::Favorites::S(W)]} {
	::Favorites::Dialog
    }
    DoInfo "Updated favorites" "KLIMB Favorites"
}

## EON FAVORITES
## BON RENUMBER
##+##########################################################################
#
# ::Renumber::Dialog -- puts up the node renumber dialog
#
proc ::Renumber::Dialog {} {
    variable W
    variable S

    if {[llength $::region($::state(region),nodes)] > 1} {
	return [WARN "Too many node files"]
    }

    destroy $W
    set WB $W.body
    set WBTN $W.buttons
    set wtitle "$::state(progname) Node Renumber"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::sanity sanity.gif]

    ::ttk::button $WBTN.dismiss -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN 1

    ::my::label $WB.from -text "Old Node Range"
    ::my::label $WB.l_pre -text "Prefix"
    ::my::entry $WB.e_pre -textvariable ::Renumber::S(pre) -width 5 -justify center
    ::my::label $WB.l_low -text "First"
    ::my::entry $WB.e_low -textvariable ::Renumber::S(low) -width 5 -justify center
    ::my::label $WB.l_high -text "Last"
    ::my::entry $WB.e_high -textvariable ::Renumber::S(high) -width 5 -justify center

    ::my::label $WB.to -text "New Node Range"
    ::my::label $WB.l_npre -text "New Prefix"
    ::my::entry $WB.e_npre -textvariable ::Renumber::S(newPre) -width 5 -justify center
    ::my::label $WB.l_newLow -text "Start"
    ::my::entry $WB.e_newLow -textvariable ::Renumber::S(newLow) -width 5 -justify center

    ::my::button $WB.renumber -text Renumber -command ::Renumber::DoMany

    grid $WB.from - - x $WB.to - - -sticky w
    grid columnconfigure $WB {0 4} -minsize .1i
    grid columnconfigure $WB 3 -minsize .25i
    grid x $WB.l_pre $WB.e_pre x x $WB.l_npre $WB.e_npre
    grid x $WB.l_low $WB.e_low x x $WB.l_newLow $WB.e_newLow
    grid x $WB.l_high $WB.e_high

    grid $WB.renumber -pady {10 0} -columnspan 7
    ::Display::RightWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::Renumber::DoMany -- Checks user parameters and then does node renumbering
#
proc ::Renumber::DoMany {} {
    variable S

    foreach arr [array names S] { set S($arr) [string trim $S($arr)] }
    if {! [string is integer -strict $S(low)]} {set S(low) 0}
    if {! [string is integer -strict $S(high)]} {set S(high) 9999}
    if {! [string is integer -strict $S(newLow)]} {set S(newLow) 1}

    set pre1 [expr {[string match "n*" $S(pre)] ? $S(pre) : "n$S(pre)"}]
    set pre2 [expr {[string match "n*" $S(pre)] ? $S(newPre) : "n$S(newPre)"}]


    set prefix $pre1
    set low $S(low)
    set high $S(high)
    set newPrefix $pre2
    set newLow $S(newLow)

    set renumInfo [::Renumber::_DoMany2 $pre1 $S(low) $S(high) $pre2 $S(newLow)]
    foreach {cnt logResult favResult} $renumInfo break
    if {$cnt == 0} {
	set msg "No nodes match that prefix and range"
    } else {
	set msg "Renamed $cnt [::Data::Plural $cnt node nodes]\n"
	foreach {changed cnt} $logResult break
	append msg "Fixed $changed out of $cnt logged rides\n"
	foreach {changed cnt} $favResult break
	append msg "Fixed $changed out of $cnt favorite routes\n"
    }
    DoInfo $msg "KLIMB Renumber"
}
##+##########################################################################
#
# ::Renumber::_DoMany2 -- Internal routine to renumber nodes
#
proc ::Renumber::_DoMany2 {prefix low high newPrefix newLow} {
    variable T

    set pre [::Renumber::_GetMatchingNodes $prefix $low $high]
    set T(pre) [set T(post) $pre]
    if {[llength $pre] == 0} { return [list 0 . .] }
    set newHigh [expr {$newLow + [llength $pre]}]

    # Check for overlapping range
    if {$prefix eq $newPrefix && $newLow <= $high && $newHigh >= $low} {
	set post [::Renumber::_ChangePrefix nXX $pre]
    } else {
	set post $pre
    }
    set post [::Renumber::_Grind $newPrefix $newLow $post]
    set T(post) $post
    ::Renumber::_Save
    set logResult [::Renumber::_FixLog $pre $post]
    set favResult [::Favorites::RenumberNode $pre $post]
    return [list [llength $pre] $logResult $favResult]
}
##+##########################################################################
#
# ::Renumber::RenumberOne -- renumbers node from old to new
#
proc ::Renumber::RenumberOne {old new} {
    global nodes roads route NR region

    if {! [info exists nodes($old)]} {
	WARN "NodeRenumber Error: node '$old' doesn't exist"
	return
    }
    if {[info exists nodes($new)]} {
	WARN "NodeRenumber Error: node '$new' already exists"
	return
    }

    set nodes($new) $nodes($old)
    unset nodes($old)

    set meta ""
    foreach rid [lsort -dictionary [array names roads]] {
	foreach {nid1 nid2 . . . . name} $roads($rid) break
	if {$old eq $nid1} {
	    lappend meta [list $rid $name $nid1 $nid2]
	    lset roads($rid) 0 $new
	    set NR($rid,$new,$nid2) $NR($rid,$old,$nid2)
	    set NR($rid,$nid2,$new) $NR($rid,$nid2,$old)

	    unset NR($rid,$old,$nid2)
	    unset NR($rid,$nid2,$old)
	} elseif {$old eq $nid2} {
	    lappend meta [list $rid $name $nid1 $nid2]
	    lset roads($rid) 1 $new
	    set NR($rid,$new,$nid1) $NR($rid,$old,$nid1)
	    set NR($rid,$nid1,$new) $NR($rid,$nid1,$old)
	    unset NR($rid,$old,$nid1)
	    unset NR($rid,$nid1,$old)
	}
    }

    # Update curront route
    foreach nid [lsearch -all $::route(nodes) $old] {
	lset ::route(nodes) $nid $new
    }
    ::Route::StatRoute 1

    set n [lsearch $::region(node,visible) $old]
    if {$n > -1} { lset ::region(node,visible) $n $new}
    .c delete node_$old text_$old
    ::Display::DrawNodes $new
    ::Balloon::ClearText node $old
    return $meta
}
##+##########################################################################
#
# ::Renumber::_GetMatchingNodes -- Return a list of nodes matching
# the given prefix and in the specified range.
#
proc ::Renumber::_GetMatchingNodes {prefix low high} {
    set nids {}
    set len [string length $prefix]
    foreach nid [array names ::nodes ${prefix}*] {
	set num [string range $nid $len end]
	if {! [string is integer -strict $num]} continue
	if {$num >= $low && $num <= $high} {
	    lappend nids $nid
	}
    }
    set nids [lsort -decreasing -command ::Renumber::_Cmp $nids]
    return $nids
}
##+##########################################################################
#
# ::Renumber::_FixLog -- Fixes nids found in the log file
#
proc ::Renumber::_FixLog {pre post} {
    set logData [::Data::ReadAllText $::state(logfile)]
    if {$logData eq ""} { return [list 0 0] }

    set fsa idle
    set newLog ""
    set cnt 0
    set changed 0
    foreach line [split $logData \n] {
	if {$fsa eq "nodes"} {
	    if {[regexp {^(\s+)(.*)$} $line . indent nids]} {
		set newNodes [::Renumber::RenumberNodesList $nids $pre $post]
		append newLog $indent $newNodes \n
		incr changed [expr {$newNodes ne $nids}]
		continue
	    }
	    set fsa idle
	}
	if {$fsa eq "newroads"} {
	    if {[regexp {^\s+} $line prefix]} {
		set nids [lrange [lindex $line 1] 0 1]
		set newNodes [::Renumber::RenumberNodesList $nids $pre $post]
		foreach {nid1 nid2} $newNodes break
		lset line 1 0 $nid1
		lset line 1 1 $nid2
		append newLog $prefix $line \n
		incr changed [expr {$newNodes ne $nids}]
		continue
	    }
	    set fsa idle
	}
	if {$fsa ne "idle"} { error "FSA error: '$fsa'" }
	if {[regexp {^KLIMB Nodes: (.*)$} $line . nids]} {
	    incr cnt
	    set newNodes [::Renumber::RenumberNodesList $nids $pre $post]
	    append newLog "KLIMB Nodes: " $newNodes \n
	    incr changed [expr {$newNodes ne $nids}]

	    set fsa "nodes"
	    continue
	}
	if {[regexp {^KLIMB NewRoads:} $line]} {
	    set fsa "newroads"
	}
	append newLog $line \n
    }
    ::Data::WriteAllText $::state(logfile) $newLog 0 backup
    return [list $changed $cnt]
}
##+##########################################################################
#
# ::Renumber::RenumberNodesList -- replaces elements in nids
# which need to be renumbered.
#
proc ::Renumber::RenumberNodesList {nids pre post} {
    set new ""
    foreach nid $nids {
	set n [lsearch -exact $pre $nid]
	if {$n == -1} {
	    lappend new $nid
	} else {
	    set nid2 [lindex $post $n]
	    lappend new $nid2
	}
    }
    return $new
}
##+##########################################################################
#
# ::Renumber::_ChangePrefix -- Changes prefix for a node
# while keeping its number. Helps in overlapping range copy.
#
proc ::Renumber::_ChangePrefix {newPrefix who} {

    set who2 {}
    foreach nid $who {
	set n [regsub {^[^\d]+} $nid $newPrefix nid2]
	if {! $n} {
	    error "bad regsub: $nid"
	}
	::Renumber::RenumberOne $nid $nid2
	lappend who2 $nid2
	set T($nid) $nid2
    }
    return $who2
}
##+##########################################################################
#
# ::Renumber::_Grind -- computes new nid for each
# one in the nodeList
#
proc ::Renumber::_Grind {newPrefix newLow nodeList} {
    global nodes

    set nodeList2 {}
    foreach pass {1 2} {
	set idx [expr {$newLow - 1}]
	foreach nid $nodeList {
	    set nid2 $newPrefix[incr idx]
	    if {[info exists nodes($nid2)]} {
		error "Cannot renumber $nid -> $nid2: already exists"
	    }
	    if {$pass == 1} continue
	    ::Renumber::RenumberOne $nid $nid2
	    lappend nodeList2 $nid2
	}
    }
    return $nodeList2
}
##+##########################################################################
#
# ::Renumber::_Cmp -- Compares two nodes return northern one as less
#
proc ::Renumber::_Cmp {A B} {
    global nodes
    foreach {. . latA lonA} $nodes($A) {. . latB lonB} $nodes($B) break
    set n [expr {$latA - $latB}]
    if {$n == 0} {
	set n [expr {$lonA - $lonB}]
    }
    return [expr {$n > 0 ? 1 : $n < 0 ? -1 : 0}]
}
##+##########################################################################
#
# ::Renumber::_Save -- Backups up existing node file
# and then saves node data
#
proc ::Renumber::_Save {} {
    set fname $::region($::state(region),nodes)
    set zname [::Init::LocateZoneFile $fname]

    set bname [::Data::GetBackupName $zname]
    file copy $zname $bname
    DumpAllData "" $zname
    return [list $zname $bname]
}
## EON RENUMBER
### BON SUPER
###+##########################################################################
##
## ::Super::Dialog -- puts up the node renumber dialog
##
#proc ::Super::Dialog {} {
#    variable W
#    variable S
#
#    if {[llength $::region($::state(region),nodes)] > 1} {
#	return [WARN "Too many node files"]
#    }
#
#    destroy $W
#    set WB $W.body
#    set WBTN $W.buttons
#    set wtitle "$::state(progname) Node Renumber"
#    set title $wtitle
#    ::Display::MakeDialogBox $W $wtitle $title [list ::img::sanity sanity.gif]
#    wm protocol $W WM_DELETE_WINDOW ::Super::_TearDown
#
#    ::ttk::button $WBTN.save -text Save -command ::Super::Save -state disabled
#    ::ttk::button $WBTN.dismiss -text Dismiss -command ::Super::_TearDown
#    ::Display::GridChildren $WBTN 1
#
#    ::my::label $WB.lold -text "Old ID"
#    set values [lsort -dictionary [array names ::nodes]]
#    ::ttk::combobox $WB.cb -values $values -textvariable ::Super::S(old) \
#	-width 8 ;# -takefocus 0 ;# -state readonly
#    ::my::label $WB.lnew -text "New ID"
#    ::my::entry $WB.enew -textvariable ::Super::S(new) -width 8
#    ::ttk::button $WB.renumber -text Renumber -state disabled \
#	-command ::Super::_DoRenumber
#
#    grid $WB.lold x $WB.lnew
#    grid $WB.cb x $WB.enew
#    grid $WB.renumber - - -pady 10
#    grid columnconfigure $WB 1 -minsize 30
#
#    set S(old) [lindex $::route(nodes) end]
#    set S(new) ""
#    trace variable ::Super::S(old) w ::Super::_Tracer
#    trace variable ::Super::S(new) w ::Super::_Tracer
#
#    ::Display::RightWindow $W
#    wm deiconify $W
#    wm resizable $W 1 1
#}
#proc ::Super::Foo {} {
#    variable W
#    variable S
#
#    if {[$W.body.renumber cget -state] ne "normal"} return
#    $W.body.renumber invoke
#
#    set n [scan $S(new) n%d num]
#    if {$n == 0} return
#    set S(new) n[incr num]
#}
###+##########################################################################
##
## ::Super::_TearDown -- cleans up after the sanity dialog
##
#proc ::Super::_TearDown {} {
#    trace vdelete ::Super::S(old) w ::Super::_Tracer
#    trace vdelete ::Super::S(new) w ::Super::_Tracer
#    destroy $::Super::W
#}
###+##########################################################################
##
## ::Super::_Tracer -- updates GUI based on user interaction
##
#proc ::Super::_Tracer {var1 var2 op} {
#    variable W
#    variable S
#
#    if {$var2 eq "old" && [info exists ::nodes($S(old))]} {
#    }
#
#    set how disabled
#    while {1} {
#	if {! [info exists ::nodes($S(old))]} break
#	if {[string length $S(new)] < 2} break
#	if {! [string match "n*" $S(new)]} break
#	if {[info exists ::nodes($S(new))]} break
#
#	set how normal
#	break
#    }
#    $W.body.renumber config -state $how
#}
###+##########################################################################
##
## ::Super::_DoRenumber -- called by the dialog to do renumbering
##
#proc ::Super::_DoRenumber {} {
#    variable W
#    variable S
#    ::Super::NodeRenumber $S(old) $S(new)
#    $W.buttons.save config -state normal
#    set S(old) ""
#    #set S(new) ""
#
#    set values [lsort -dictionary [array names ::nodes]]
#    $W.body.cb config -values $values
#}
###+##########################################################################
##
## ::Super::NodeRenumber -- renumbers node from old to new
##
#proc ::Super::NodeRenumber {old new} {
#    global nodes roads route NR region
#
#    if {! [info exists nodes($old)]} {
#	WARN "NodeRenumber Error: node '$old' doesn't exist"
#	return
#    }
#    if {[info exists nodes($new)]} {
#	WARN "NodeRenumber Error: node '$new' already exists"
#	return
#    }
#
#    set nodes($new) $nodes($old)
#    unset nodes($old)
#
#    set meta ""
#    foreach rid [lsort -dictionary [array names roads]] {
#	foreach {nid1 nid2 . . . . name} $roads($rid) break
#	if {$old eq $nid1} {
#	    lappend meta [list $rid $name $nid1 $nid2]
#	    lset roads($rid) 0 $new
#	    set NR($rid,$new,$nid2) $NR($rid,$old,$nid2)
#	    set NR($rid,$nid2,$new) $NR($rid,$nid2,$old)
#
#	    unset NR($rid,$old,$nid2)
#	    unset NR($rid,$nid2,$old)
#	} elseif {$old eq $nid2} {
#	    lappend meta [list $rid $name $nid1 $nid2]
#	    lset roads($rid) 1 $new
#	    set NR($rid,$new,$nid1) $NR($rid,$old,$nid1)
#	    set NR($rid,$nid1,$new) $NR($rid,$nid1,$old)
#	    unset NR($rid,$old,$nid1)
#	    unset NR($rid,$nid1,$old)
#	}
#    }
#
#    # Update curront route
#    foreach nid [lsearch -all $::route(nodes) $old] {
#	lset ::route(nodes) $nid $new
#    }
#    ::Route::StatRoute 1
#
#    set n [lsearch $::region(node,visible) $old]
#    if {$n > -1} { lset ::region(node,visible) $n $new}
#    .c delete node_$old text_$old
#    ::Display::DrawNodes $new
#    ::Balloon::ClearText node $old
#    return $meta
#}
###+##########################################################################
##
## ::Super::Save -- Does DumpAllData to the node file while
## backing it up
##
#proc ::Super::Save {} {
#    variable W
#
#    set fname $::region($::state(region),nodes)
#    set zname [::Init::LocateZoneFile $fname]
#
#    set bname [::Data::GetBackupName $zname]
#    file copy $zname $bname
#    DumpAllData "" $zname
#    set msg "Wrote $zname\nbackup: $bname"
#
#    if {[winfo exists $W]} {
#	$W.buttons.save config -state disabled
#    }
#    tk_messageBox -icon info -title "KLIMB Renumber" -message $msg
#}
### EON SUPER
## BON WUPDATE
##+##########################################################################
#
# ::WUpdate::Dialog -- Displays update from web dialog
#
proc ::WUpdate::Dialog {} {
    variable W
    variable DLG

    if {! [::Data::CanDo internet]} {
	return [WARN "This feature requires the http extension"]
    }

    set WB $W.body
    set WBF $W.body.f
    set WBTN $W.buttons
    set wtitle "$::state(progname) Web Update"
    set title $wtitle
    ::Display::MakeDialogBox $W $wtitle $title [list ::img::icon klimb.gif]
    #wm protocol $W WM_DELETE_WINDOW {}
    ::ttk::button $WBTN.cancel -text Dismiss -command [list destroy $W]
    ::Display::GridChildren $WBTN 0

    set txt "KLIMB periodically posts updated copies of both the node "
    append txt "file and the favorite routes file. You can use this dialog to "
    append txt "download and install those updated files."
    set txt [::Data::WordWrap $txt 45]
    ::my::label $WB.txt -text $txt
    grid $WB.txt -pady {0 10}
    ::my::frame $WBF

    set kfile [file join $::state(kdir) klimb.tcl]
    set nfile $::region($::state(region),nodes)
    set nfile [::Init::LocateZoneFile $nfile 1 0]
    set ffile [::Favorites::FindFavoritesFiles system]

    set cnt -1
    set mlist {}
    #set mlist [concat $mlist [list $kfile KLIMB "KLIMB File:"]]
    set mlist [concat $mlist [list $nfile nodes "Node File:"]]
    set mlist [concat $mlist [list $ffile favorites "Favorites:"]]

    foreach {fname who lbl} $mlist {
	incr cnt

	set DLG($who,date) "<missing>"
	if {[file exists $fname]} {
	    set DLG($who,date) [clock format [file mtime $fname] \
				    -format "%N/%d/%y"]
	}
	::my::label $WBF.f$cnt -text [file tail $fname] -anchor w
	::my::label $WBF.d$cnt -textvariable ::WUpdate::DLG($who,date) -anchor w
	::ttk::button $WBF.b$cnt -text "Update" \
	    -command [list ::WUpdate::_Download $who]
	grid $WBF.f$cnt $WBF.d$cnt $WBF.b$cnt -sticky ew

	# Not all zones have downloadable nodes or favorites
	if {$who eq "nodes"} {
	    if {$::state(zone) ne "San Francisco Bay Area" && \
		    $::state(zone) ne "Ohio"} {
		$WBF.b$cnt config -state disabled
	    }
	} elseif {$who eq "favorites"} {
	    if {! [file exists $ffile]} {
		$WBF.b$cnt config -state disabled
	    }
	}
    }
    grid columnconfigure $WBF {0 1 2} -weight 1

    grid $WBF -sticky ew

    ::Display::CenterWindow $W
    wm deiconify $W
}
##+##########################################################################
#
# ::WUpdate::_Download -- starts download of specified component
#
proc ::WUpdate::_Download {who} {
    variable W
    variable S

    set zdir [string tolower [file tail $::state(zdir)]]
    if {$who eq "nodes"} {
	set wtitle "Downloading KLIMB Node File"
	set title "$wtitle\n$::state(zone) Zone"
	set nfile $::region($::state(region),nodes)
	set path [file join zones $zdir $nfile]
    } elseif {$who eq "favorites"} {
	set wtitle "Downloading KLIMB Favorites"
	set title "$wtitle\n$::state(zone) Zone"
	set path [file join zones $zdir favorites.data]
    }
    set icon [list ::img::browser browser.gif]
    set url "http://www.klimb.org/$path"

    set token [::URL::GetURL $url $W $wtitle $title $icon]
    if {$token eq ""} return

    set ncode [::http::ncode $token]
    if {$ncode == 404} {
	WARN "The $who file seems to be missing."
	::http::cleanup $token
	return
    }
    if {$ncode != 200} {
	WARN "Bad response from '$url'\n[::http::code $token]"
	::http::cleanup $token
	return
    }

    set ::WUpdate::DLG($who,date) [clock format [clock seconds] \
				       -format "%N/%d/%y"]
    set data [::http::data $token]
    ::http::cleanup $token

    if {$who eq "favorites"} {
	::Favorites::InstallNew $data
    } elseif {$who eq "nodes"} {
	::Zone::InstallNewNodes $data
    }

    return
}
## EON WEB
## BON URL
##+##########################################################################
#
# ::URL::GetURL -- Fetches url data with wait/cancel dialog. Returns
# http::geturl token on success, "" on error
#
proc ::URL::GetURL {url parent wtitle title icon} {
    variable W
    variable S

    unset -nocomplain S
    set S(token) ""
    set S(url) $url
    ::URL::_MakeWaitDialog $parent $wtitle $title $icon
    update
    set S(token) [::http::geturl $url -command ::URL::_Command \
    		      -progress ::URL::_Progress]
    DoGrab $W $W.buttons.cancel
    # FOLLOWS REDIRECTS but can't cancel
    #set S(token) [::URL::GetUrlFollowRedirects $url -progress ::URL::_Progress]
    #destroy $W
    return $S(token)				;# NB. may be null via _Cancel
}
##+##########################################################################
#
# ::URL::_MakeWaitDialog -- Our wait/cancel dialog
#
proc ::URL::_MakeWaitDialog {parent wtitle title icon} {
    variable W

    set WB $W.body
    set WBC $WB.c
    set WBTN $W.buttons

    if {! [winfo exists $parent]} { set parent . }
    ::Display::MakeDialogBox $W $wtitle $title $icon
    wm transient $W $parent
    wm protocol $W WM_DELETE_WINDOW ::URL::_Cancel

    ::ttk::button $WBTN.cancel -text Cancel -command ::URL::_Cancel
    ::Display::GridChildren $WBTN 0

    ::my::label $WB.l -text "Please Wait" -font bigBold -foreground red
    ::my::label $WB.msg -textvariable ::URL::S(msg) -anchor c
    set ::URL::S(msg) ""

    pack $WB.l $WB.msg -side top -fill x
    ::Display::CenterWindow $W $parent
    wm deiconify $W
}
##+##########################################################################
#
# ::URL::_Command -- Called on url download completion
#
proc ::URL::_Command {token} {
    variable W

    destroy $W
}
##+##########################################################################
#
# ::URL::_Cancel -- Called on user cancel
#
proc ::URL::_Cancel {} {
    variable W
    variable S
    ::http::reset $S(token)
    ::http::cleanup $S(token)
    set S(token) ""
    destroy $W
}
##+##########################################################################
#
# ::URL::_Progress -- ::http::geturl progress callback
#
proc ::URL::_Progress {token total current} {
    set ::URL::S(msg) "[comma $current]/[comma $total]"
}

proc ::URL::GetUrlFollowRedirects {url args} {
    ::Data::CanDo uri

    array set URI [::uri::split $url] ;# Need host info from here
    set token ""
    for {set i 0} {$i < 5} {incr i} {
	::http::cleanup $token
        set n [catch {set token [eval http::geturl $url {*}$args]} emsg]
	set ncode [::http::ncode $token]
        if {![string match {30[1237]} [::http::ncode $token]]} {return $token}

        array set meta [set ${token}(meta)]
        if {![info exist meta(Location)]} {
            return $token
        }
        array set uri [::uri::split $meta(Location)]
        unset meta
        if {$uri(host) == ""} { set uri(host) $URI(host) }
        # problem w/ relative versus absolute paths
        set url [eval ::uri::join [array get uri]]
	INFO "redirecting to $url"
    }
    return $token
}

## EON URL
## BON MATRIX

##+##########################################################################
#
# ::Matrix::pos2canvas -- Computes position on canvas when
# we have a 3x3 transformation matrix
#
proc ::Matrix::pos2canvas {lat lon} {
    set V [list $lon $lat 1]
    set C [::Matrix::_VMultiply $::region(matrix) $V]
    return [lrange $C 0 1]
}
##+##########################################################################
#
# ::Matrix::canvas2pos -- Computes lat/lon from canvas position when
# we have a 3x3 transformation matrix
#
proc ::Matrix::canvas2pos {x y} {
    set V [list $x $y 1]
    set L [::Matrix::_VMultiply $::region(matrixI) $V]
    lassign $L lon lat
    return [list $lat $lon]
}
##+##########################################################################
#
# ::Matrix::_VMultiply -- multiples a 3x3 matrix with a column vector
#
proc ::Matrix::_VMultiply {M V} {
    set result {}
    lassign $V v0 v1 v2

    foreach {c0 c1 c2} $M {
	set val [expr {$c0*$v0 + $c1*$v1 + $c2*$v2}]
	if {abs($val) < .000001} { set val 0}
	lappend result $val
    }
    return $result
}



## EON MATRIX
################
################
proc Main {} {
    global argc argv tcl_interactive state start

    ::Init::ParseArgs
    set n 0
    if {$argc} {				;# Load given route file
	set n [::Route::Load [lindex $argv 0] 1]
    }
    if {! $n} {					;# No route, load default
	::Zone::GoZone $state(zone,argv)	;# Set up zones
	::Init::StartingRegion $state(region,argv) $state(mag,argv) ;# Check region
	::Region::GoRegion $state(region) $state(mag)
    }
    if {$tcl_interactive} {
	set end [clock seconds]
	set lt [comma [expr {$end - $start}]]
	puts "load time: $lt seconds"
    }
}
#+##############################################################
################################################################
################################################################
# XXXXX
set start [clock seconds]
set save_argv $argv
::Init::Init 1					;# Do minimal init
::About::Splash
::Init::Init 0					;# Do full init

if {$state(kcode) ne ""} {
    source $state(kcode)
}
Main
return

###################################
###################################
###################################
# testing, new and junk stuff below


# TODO
#  handle node w/o altitude
#  handle bad climbing/desc info
#proc DoRename {nid} {
#    if {! [info exists ::state(nodes,prefix)]} {
#	WARN "state(nodes,prefix) not defined"
#	return
#    }
#    if {$::state(su)} {
#	if {[regexp {^n\d+$} $nid]} {
#	    RenameNode $nid $::state(nodes,prefix)
#	}
#    }
#}
#proc RenameNode {onid {letter D}} {
#    global nodes roads NR
#
#    set nid [::Edit::FindNode $onid]
#    if {$nid eq {}} {
#	INFO "no node $onid"
#	return
#    }
#    set nnid [::Edit::GetNextID n $letter]
#    puts "Renaming $nid to $nnid"
#
#    foreach nr [array names NR *,$nid] {
#	foreach {rid id1 id2} [split $nr ","] break
#	if {[lindex $roads($rid) 0] == $nid} {
#	    lset roads($rid) 0 $nnid
#	} elseif {[lindex $roads($rid) 1] == $nid} {
#	    lset roads($rid) 1 $nnid
#	} else {
#	    error "road $rid doesn't have NODE $nid"
#	}
#
#	set NR($rid,$id1,$nnid) $NR($rid,$id1,$id2)
#	set NR($rid,$nnid,$id1) $NR($rid,$id2,$id1)
#	unset NR($rid,$id1,$id2)
#	unset NR($rid,$id2,$id1)
#    }
#    set nodes($nnid) $nodes($nid)
#    unset nodes($nid)
#
#    ::Balloon::ClearText node $nid
#    .c delete inode_$nid
#    ::Display::DrawNodes $nnid
#}



################################################################
# BENDING ROAD STUFF
#
proc ColorRoad {rid {ax 0} {ay 0} {dx 0} {dy 10}} {
    set colors [list red blue yellow cyan green]
    .c delete road_$rid xy
    set cxy [::Display::GetRoadPoints $rid]

    set x0 -1
    foreach {x1 y1} $cxy {
	if {$x0 != -1} {
	    set color [lindex $colors 0]
	    set colors [concat [lrange $colors 1 end] $color]
	    .c create line $x0 $y0 $x1 $y1 -fill $color -width 5 -tag xy
	    .c create line $ax $ay $x1 $y1 -fill $color -width 2 -tag xy
	    incr ax $dx
	    incr ay $dy
	}
	set x0 $x1
	set y0 $y1
    }
}
proc UnbendRoad {rid {tolerance 1.5}} {
    set Z [concat ? [lindex $::roads($rid) 9] ?]
    set cxy {}
    foreach {cx cy} [::Display::GetRoadPoints $rid] {
	lappend cxy [list $cx $cy]
    }
    set len [llength $cxy]

    set keep [concat [lindex $cxy 0] ?]		;# Starting node
    set bad 0
    set good 2					;# The two endpoints
    for {set start 0} {$start < $len - 2} {set start $next} {
	foreach {x0 y0} [lindex $cxy $start] break
	for {set next [expr {$start + 1}]} {$next < $len-1} {incr next} {
	    # Compute distance point NEXT is to line START <-> NEXT+1
	    # If below threshhold but not a altitude waypoint the delete it
	    foreach {x1 y1} [lindex $cxy $next] break
	    foreach {x2 y2} [lindex $cxy [expr {$next+1}]] break
	    set dist [::Data::DistanceToLine $x1 $y1 $x0 $y0 $x2 $y2]

	    set z [lindex $Z $next]
	    if {![string is integer -strict $z] && $dist < $tolerance} {
		incr bad
	    } else {
		if {! [string is integer -strict $z]} {set z "?"}
		incr good
		lappend keep $x1 $y1 $z
		break
	    }
	}
    }
    eval lappend keep [lindex $cxy end] ?	;# Ending node

    return [list $keep $good $bad]
}
proc CleanupBends {{who {}} {tolerance 1.5}} {
    global roads state

    foreach {verbose state(verbose)} [list $state(verbose) 0] break
    if {$who eq {}} {
	set who [array names roads]
    }
    set cnt 0
    set tgood 0
    set tbad 0
    set badlist {}
    foreach rid $who {
	set ::rid rid
	incr cnt
	if {($cnt % 50) == 0} { puts -nonewline "."; update}
	foreach {coords good bad} [UnbendRoad $rid $tolerance] break
	incr tgood $good
	incr tbad $bad
	if {$bad == 0} continue
	lappend badlist [list $rid $good $bad]

	set xy {}
	set Z {}
	set gotZ 0
	foreach {x y z} [lrange $coords 3 end-3] {
	    set ll [::Display::canvas2pos $x $y 0]
	    eval eval lappend xy [lrange $ll 0 1]
	    lappend Z $z
	    if {[string is double -strict $z]} {set gotZ 1}
	}
	lset roads($rid) 8 $xy
	if {! $gotZ} {set Z {}}
	lset roads($rid) 9 $Z
	set old [::Display::GetRoadPoints $rid]
	::Display::DrawRoads $rid
	if {[.c find withtag road_$rid] ne {}} {
	    .c create line $old -tag old -fill red -width 2
	}
    }
    set state(verbose) $verbose
    return [list $tgood $tbad $badlist]
}


proc FindWorstBentRoads {{onlyVisible 0}} {
    global roads bads

    set cnt 0
    unset -nocomplain bads
    foreach rid [array names roads] {
	if {$onlyVisible && [.c find withtag road_$rid] eq {}} continue
	set bad [lindex [UnbendRoad $rid] end]
	lappend bads($bad) $rid
	incr cnt
	if {($cnt % 50) ==0} {puts -nonewline "."; update}
    }
    set v {}
    set total 0
    foreach b [lsort -integer [array names bads]] {
	set len [llength $bads($b)]
	lappend v [list $b $len]
	set total [expr {$total + $b * $len}]
    }
    return $v
}

return


proc DistanceError {args} {
    global roads nodes NR
    set nid ""

    foreach id $args {
	if {[info exists nodes($id)]} {
	    set nid $id
	    set who {}
	    foreach nr [array names NR *,$nid] {
		lappend who [lindex [split $nr ","] 0]
	    }
	    set id $who
	}
	foreach rid $id {
	    foreach {nid1 nid2 . dist} $roads($rid) break
	    set guess [::Data::RoadDistance $rid 1]
	    set guess [Round2 [::BadMath::Real $guess]]
	    set err [expr {[::BadMath::Real $dist] - $guess}]

	    set who "($nid1 $nid2)"
	    if {$nid eq $nid2} { set who "($nid2 $nid1)"}

	    puts "$rid $who: $dist/$guess => $err"
	}
    }
}
proc HighlightBad {delta} {

    set bad [::Data::SanityCheckDistance $delta visible]

    ;# Put in our own highlight color
    foreach a [array names ::state r,0,*,color] {
	foreach {. . idx .} [split $a ","] break
	set ::state(r,9,$idx,color) cyan
    }
    foreach b [array names ::state r,0,*,width] {
	foreach {. . idx . } [split $b ","] break
	set ::state(r,9,$idx,width) 5
    }
    set ::state(n,9,color) cyan
    ::Route::ClearRoute
    foreach b $bad {
	set rid [lindex $b 1]
	::Display::HighlightRoad 9 $rid
    }
}



proc foo {args} {
    ::Display::MakeProgressBar . "Testing progress bar"

    if {$args ne {}} {
	set ::Display::pColors $args
    }
    for {set i 0} {$i <= 100} {incr i} {
	::Display::DoProgressBar $i 100
	after 50
    }
}

proc 3d:GetXYZ {{normalize 0}} {
    set xyz [::Route::GetXYZ]
    foreach {lat0 lat1 lon0 lon1 alt0 alt1} [::Route::GetBounds $xyz] break
    foreach {Olat Olon Oalt} {0 0 0} break
    if {$normalize} {
	set Olat [expr {($lat0 + $lat1) / 2.0}]
	set Olon [expr {($lon0 + $lon1) / 2.0}]
	set Oalt [expr {($alt0 + $alt1) / 2.0}]
    }

    set xyz2 {}
    foreach pt $xyz {
	foreach {. . lat lon . . . alt} $pt break
	set x [expr {$lon - $Olon}]
	set y [expr {$lat - $Olat}]
	set z [expr {$alt - $Oalt}]
	lappend xyz2 $x $y $z
    }
    return $xyz2
}

proc 3dObj {} {
    global result
    set xyz [::Route::GetXYZ]
    set result ""


    set z0 ""
    set xy {}
    foreach pt $xyz {
	foreach {. . y x . . . z} $pt break
	append result "v $x $y $z\n"
	lappend xy $x $y $z
    }
    append result "l"
    for {set i 1} {$i <= [llength $xyz]} {incr i} {
	append result " $i"
    }
    append result "\n"
    return $xy
}

proc 3dObj2 {} {
    ::Trace::GetData
    set xy $::Trace::tdata(xy)

    set result ""

    foreach {x0 y0} [lindex $xy 0] break
    foreach {x1 y1} [lindex $xy 0] break
    foreach pt $xy {
	foreach {x y} $pt break
	if {$x < $x0} {set x0 $x} elseif {$x > $x1} {set x1 $x}
	if {$y < $y0} {set y0 $y} elseif {$y > $y1} {set y1 $y}
    }
    set ox [expr {($x0 + $x1) / 2}]
    set oy [expr {($y0 + $y1) / 2}]


    set z 0
    foreach pt $xy {
	foreach {x y} $pt break
	set x [expr {$x - $ox}]
	set y [expr {$y - $oy}]
	incr z 10
	append result "v $x $y $z\n"
    }
    append result "f"
    for {set i 1} {$i <= [llength $xy]} {incr i} {
	append result " $i"
    }
    append result "\n"
    return $result
}



proc ::3D::TkAnim {} {
    destroy .top
    toplevel .top
    canvas .top.c -width 500 -height 500
    pack .top.c -fill both -expand 1

    for {set i 1} {1} {incr i} {
	set name "::3D::gnuplot::plot[format %03d $i]"
	if {[info procs $name] eq ""} break
	if {! [winfo exists .top.c]} break
	$name .top.c
	update
	after 10
    }
}

proc WhichRegion {args} {
    global nodes

    set arg1 [lindex $args 0]
    if {[llength $args] == 1} {
	if {! [info exists nodes($arg1)]} {
	    set arg1 [::Edit::FindNode $arg1]
	    if {! [info exists nodes($arg1)]} {
		error "unknown node $args"
	    }
	}
	foreach {. . lat lon} $nodes($arg1) break
    } elseif {[llength $args] == 2} {
	foreach {lat lon} $args break
    } elseif {[llength $args] == 6} {
	foreach var {lat lon} {a b c} $args {
	    set $var [lat2int $a $b $c]
	}
    } else {
	error "usage: WhichRegion lat lon"
    }

    set result {}
    foreach which [lsort -dictionary [array names ::region *3,maps]] {
	set name [lindex [split $which ","] 0]
	foreach mmap $::region($which) {
	    foreach var {lat0 lon0 lat1 lon1} {a b c} $::map($mmap) {
		set $var [lat2int $a $b $c]
	    }
	    if {$lat > $lat0 || $lat < $lat1} continue
	    if {$lon > $lon0 || $lon < $lon1} continue
	    #lappend result [list $name $mmap]
	    lappend result $name
	}
    }
    return $result
}

proc FindNodeRegion {} {
    ;#     R(delta,nodes)
    ;#     R(delta,roads)
    ;#     R(nid) {...}
    ;#     R(rid) {...}

    global R nodes roads
    unset -nocomplain R

    set cnt -1
    set total [llength [array names nodes]]
    foreach nid [lsort -dictionary [array names nodes]] {
	if {([incr cnt] % 100) == 0} {
	    puts -nonewline "\r$cnt/$total"
	    flush stdout
	}
	set R($nid) [WhichRegion $nid]
	foreach r $R($nid) {
	    lappend R($r,nodes) $nid
	}
    }
    puts ""

    set cnt -1
    set total [llength [array names roads]]
    foreach rid [lsort -dictionary [array names roads]] {
	if {([incr cnt] % 100) == 0} {
	    puts -nonewline "\r$cnt/$total"
	    flush stdout
	}
	foreach {id1 id2} $roads($rid) break
	set R($rid) [lsort -unique [concat $R($id1) $R($id2)]]
	foreach r $R($rid) {
	    lappend R($r,roads) $rid
	}
    }
}

# produces road in region output used by tools/missing.tsh
unset -nocomplain result
foreach r [lsort [array names R *,roads]] {
    foreach {rname .} [split $r ","] break
    append result "set REGION($rname) {$R($r)}\n"
}


Miscellaneous features:
  right click on about picture of larger version
  zoom shortcuts
  route turnings
  ridelog stats & filter
  starting multi region
  usgs right click in edit node dialog
  mousewheel scrolling both vertical and horizontal
  double click node in profile
  balloon help on profile





proc ttk_optionMenu { w varName firstValue args } {
    upvar #0 $varName var

    if {![info exists var]} {
	set var $firstValue
    }
    ::ttk::menubutton $w -textvariable $varName -menu $w.menu \
	-direction flush ;# \
	-relief raised -bd 2 -highlightthickness 2 -anchor c  \
	-indicatoron 1
    menu $w.menu -tearoff 0
    $w.menu add radiobutton -label $firstValue -variable $varName
    foreach i $args {
	$w.menu add radiobutton -label $i -variable $varName
    }
    return $w.menu
}


foreach rid [lsort -dictionary $region(road,visible)] {
    foreach {. . north . south} $roads($rid) break
    set north [::BadMath::Real $north]
    set south [::BadMath::Real $south]
    if {($north > 0 && $north < 30) || ($south > 0 && $south < 30)} {
	puts "$rid: $north $south"
    }
}


proc foo {} {

    set rid $::Zoom::ZMAP(who)
    foreach {nid1 nid2 north . south} $::roads($rid) break
    if {$north > $south+50} {
	foreach {nid1 nid2} [list $nid2 $nid1] break
    }
    ::Route::ClearRoute
    ::Route::CheckRoute node $nid1
    ::Route::CheckRoute node $nid2
    ::Profile::Profile
}


proc RoadDistComp {A B} {
    global roads
    set a [::BadMath::Real [lindex $roads($A) 3]]
    set b [::BadMath::Real [lindex $roads($B) 3]]
    return [expr {int(100*($a - $b))}]
}



proc Text2Canvas {t c} {

    for {set row 1} {$row < [$t index end]} {incr row} {
	set idx "$row.0"
	foreach {x y w h base} [$t dlineinfo $idx] break
	set txt [$t get $idx [list $idx lineend]]

	$c create text $x $y -anchor nw -font {Helvetica 8} -text $txt
    }
}




#####
proc foo {W tag} {
    foreach {x0 y0 x1 y1} [$W bbox $tag] break
    $W move $tag [expr {-$x0}] [expr {-$y0}]
    set w [expr {$x1-$x0}]
    set h [expr {$y1-$y0}]
    $W config -width $w -height $h

    ::Data::CanDo grabWindow
    image create photo ::img::grab -data $W
}

proc foo {section} {
    set parent .config.nb.$section
    set q [winfo child $parent]

    set vars {}
    while {[llength $q] > 0} {
	set w [lindex $q 0]
	set q [lrange $q 1 end]

	set q [concat $q [winfo child $w]]
	set n [catch {set var [$w cget -variable]}]
	if {$n} {
	    set n [catch {set var [$w cget -textvariable]}]
	}
	if {! $n} {
	    if {! [regexp {\((.*)\)} $var => var2]} continue
	    if {[lsearch $vars $var2] == -1} {
		lappend vars $var2
	    }
	}
    }
    return $vars
}

# How far is 1 second of lat or 1 second of lon??
set lat1 [lat2int 40 0 0]
set lon1 [lat2int 82 0 0]
set lat2 [lat2int 40 0 1]
set lon2 [lat2int 82 0 0]
set lat3 [lat2int 40 0 0]
set lon3 [lat2int 82 0 1]

::Data::Distance $lat1 $lon1 $lat2 $lon2 1 ;# 101'
::Data::Distance $lat1 $lon1 $lat3 $lon3 1 ;# 78'
::Data::Distance $lat1 $lon1 [expr {$lat1 + 0.00001}] $lon2 1 ;# 3.7'


Route Formats:
 description ==> ::Description::GetData
 trace ==> ::Trace::GetData
 profile ==> ::Profile::GetData
 3d ==> ::Profile::GetData, ::Route::GetXYZ
 gps
 hills ==> ::Hills::GrindTrack; ::Hills::_Route2Track
 mileposts ==> ::Trace::GetData

===
::Profile::GetData   ::= <dest node> <total dist> altitude quality <total climb> <rid> <turn>
::Route::GetXYZ      ::= name ele lat lon <waypoint|routepoint> <nid|rid> utm ele2 usgs
::GPS::GetXYZ        ::= ::Route::GetXYZ
::Trace::GetData     ::= variable tdata
::Description::GetData ::= turn, roadname, rid, from_name, etc. (NO RTEPTs)
GPS::tracks(##,track) ::= lat lon alt ?


proc foo {rid} {
    global NR roads

    foreach {id1 id2 north dist south type rname} $roads($rid) break
    foreach {. v(dist,r) v(climb,r) v(desc,r)} $NR($rid,$id1,$id2) break

    set dist [::BadMath::Real $dist]
    set north [::BadMath::Real $north]
    set south [::BadMath::Real $south]

    set v(dist,r) [::BadMath::Real $v(dist,r)]
    set v(desc,r) [::BadMath::Real $v(desc,r)]
    set v(climb,r) [::BadMath::Real $v(climb,r)]

    if {$dist != $v(dist,r) || $north != $v(desc,r) || $south != $v(climb,r)} {
	puts "$rid: $dist/$v(dist,r)  $north/$v(desc,r)  $south/$v(climb,r)"
    }
}
proc ::Data::LRotate {listName} {
    upvar 1 $listName myList

    set myList [lassign $myList head]
    lappend myList $head
    return $head
}



Ohio vs Bay Area

* 16 70' hills vs 1 1,000' hill
* easy, hill, coast, easy vs hard, hard, hard
* sprint the hills
* average speed is a harsh mistress
* headwind
* less scenic
* no long downhill coasts
* chicken farms, pig farms pee-ew



climate:
 rain
 snow
 limited season


I discover that I don't know how to ride on flat roads. I get really
eager and push the pace high. Then I'd get upset for not being able
to maintain it--there's no hill here so of course I should be able to
keep this pace :-)



================================================================

set x 2209
set y 3098
set lat1 [lat2int 40 6 42.5047]
set lon1 [lat2int 82 55 28.6994]
set lat2 [lat2int 39 58 37.8468]
set lon2 [lat2int 82 44 56.6736]

set dlat [expr {$lat2 - $lat1}]
set dlon [expr {$lon2 - $lon1}]

set x1 [expr {$x + 4}]
set y1 $y
set lon3 [expr {$lon2 + $dlon}]
set line "map=google/c_${x1}_$y1.jpg:4:"
append line "[int2lat $lat1] [int2lat $lon2] "
append line "[int2lat $lat2] [int2lat $lon3]"
clipit $line 1


set x1 [expr {$x + 4}]
set y1 $y
set lon4 [expr {$lon3 + $dlon}]
set line "map=google/c_${x1}_$y1.jpg:4:"
append line "[int2lat $lat1] [int2lat $lon3] "
append line "[int2lat $lat2] [int2lat $lon4]"
clipit $line 1


return

set rid1 r4
set rid2 r5
proc JoinNodes {from mid to} {
    global NR

    set arr [array names NR *,$from,$mid]
    set rid1 [lindex [split $arr ","] 0]
    set arr [array names NR *,$mid,$to]
    set rid2 [lindex [split $arr ","] 0]
    set rid [JoinRoads $rid1 $rid2]
    return $rid
}
proc JoinRoads {rid1 rid2} {
    global roads nodes

    foreach {id1a id1b north1 dist1 south1 type1 name1 comment1 xy1 z1 q1} $roads($rid1) break
    foreach {id2a id2b north2 dist2 south2 type2 name2 comment2 xy2 z2 q2} $roads($rid2) break

    if {$id1a == $id2a} {
	set from $id1b
	set mid $id1a
	set to $id2b
    } elseif {$id1a == $id2b} {
	set from $id1b
	set mid $id1a
	set to $id2a
    } elseif {$id1b == $id2a} {
	set from $id1a
	set mid $id1b
	set to $id2b
    } elseif {$id1b == $id2b} {
	set from $id1a
	set mid $id1b
	set to $id2a
    } else {
	error "$rid1 doesn't touch $rid2"
    }
    foreach {. midElev midLat midLon} $nodes($mid) break

    set dist [::BadMath::Add $dist1 $dist2]
    set type $type1
    set name "Joining $name1 $name2"
    set comment [string trim "$comment1 $comment2"]
    set q $q1

    if {[::Data::IsNorthNode $from $mid]} {
	set xy $xy1
	set z $z1
	set climb1 $south1
	set desc1 $north1
    } else {
	set xy [::Data::XYReverse $xy1]
	set z [::Data::Reverse $z1]
	set climb1 $north1
	set desc1 $south1
    }
    set xy [concat $xy [int2lat $midLat] [int2lat $midLon]]
    set z [concat $z $midElev]

    if {[::Data::IsNorthNode $mid $to]} {
	set xy [concat $xy $xy2]
	set z [concat $z $z2]
	set climb2 $south2
	set desc2 $north2
    } else {
	set xy [concat $xy [::Data::XYReverse $xy2]]
	set z [concat $z [::Data::Reverse $z2]]
	set climb2 $north2
	set desc2 $south2
    }

    set climb [::BadMath::Add $climb1 $climb2]
    set desc [::BadMath::Add $desc1 $desc2]

    if {! [::Data::IsNorthNode $from $to]} {
	foreach {from to} [list $to $from] break
	set xy [::Data::XYReverse $xy]
	set z [::Data::Reverse $z]
	foreach {climb desc} [list $desc $climb] break
    }
    set xyz [::Data::AddZ2XY $xy $z]
    set rid [::Edit::GetNextID r]
    set ::rid $rid

    set rinfo [list $from $to $desc $dist $climb $type $name $comment $xyz]
    ::Edit::AddRoad2 $rid $rinfo
    return $rid
}

proc foo {} {
    set w .test
    toplevel $w

    set headers [list ID Name Elevation USGS Error]
    ::TileTable::Create $w $headers $data

}


proc OnScreenNodes {} {
    global nodes visible NR2 NR
    set visible {}
    unset -nocomplain NR2

    foreach nid [array names ::nodes] {
	foreach {x y} [lindex $nodes($nid) 4] break
	if {[::Display::IsVisible $x $y]} {
	    lappend visible $nid
	    foreach arr [array names ::NR *,$nid] {
		set NR2($arr) $::NR($arr)
	    }
	}
    }
    set clip "array set NR2 \{\n"
    foreach arr [lsort -dictionary [array names NR2]] {
	append clip "    $arr {$NR2($arr)}\n"
    }
    append clip "}\n"
}


foreach nid [array names nodes] {
    set txt [lindex $nodes($nid) 0]
    if {! [string match "My new node*" $txt]} continue
    set new "Node [::Edit::PrettyNode $nid]"
    lset nodes($nid) 0 $new
    lappend ::Data::changed(node) $nid

}

proc parray { a {pattern *} } {
    upvar 1 $a array
    if {![array exists array]} {
	error "\"$a\" isn't an array"
    }
    set maxl 0
    set names [lsort -dictionary [array names array $pattern]]
    foreach name $names {
	if {[string length $name] > $maxl} {
	    set maxl [string length $name]
	}
    }
    set maxl [expr {$maxl + [string length $a] + 2}]
    foreach name $names {
	set nameString [format %s(%s) $a $name]
	set val $array($name)
	if {[string length $val] > 100} { set val [string range $val 0 97]...}
	puts stdout [format "%-*s = %s" $maxl $nameString $val]
    }
}


################################################################
# Plotchart ribbon
set w .pcp.c
proc PlotChartProfile {} {
    package require Plotchart
    destroy .pcp
    toplevel .pcp
    canvas .pcp.c -width 800 -height 400 -bg cyan
    pack .pcp.c -fill both -expand 1

    #PlotChartProfileGo .pcp.c
    bind .pcp.c <Configure> [list PlotChartProfileGo .pcp.c]
}
proc PlotChartProfileGo {w} {
    global pro

    if {! [winfo exists $w]} return
    $w delete all

    set data [::Profile::GetData]
    lassign $data minX maxX minY maxY climb desc xy
    ::Profile::GetSizes
    set Z {}
    set YZ {}
    foreach wpt $xy {
	lassign $wpt . y alt
	lappend Z [list $alt $alt]
	lappend YZ [list $y $alt]
    }

    set xscale [list 0 1 1]
    set xscale [list 0 .1 .1]
    set yscale [list $pro(xmin,nice) $pro(xmax,nice) $pro(xt,nice)]
    set zscale [list $pro(ymin,nice) $pro(ymax,nice) $pro(yt,nice)]
    foreach {xmin xmax xstep} $xscale {break}
    foreach {ymin ymax ystep} $yscale {break}
    foreach {zmin zmax zstep} $zscale {break}

    set s [::Plotchart::create3DPlot .pcp.c $xscale $yscale $zscale]
    $w delete axis3d
    set xstep 0
    ::Plotchart::Draw3DAxes         $w $xmin  $ymin  $zmin  \
    	$xmin  $ymax $zmax \
    	$xstep $ystep $zstep

    #$s plotdata $Z
    ::Plotchart::myDraw3DRibbon $w $YZ
}
package require Plotchart
proc ::Plotchart::myDraw3DRibbon { w yzData } {
    variable scaling

    set  nxcells 1
    set  nycells [llength $yzData]
    incr nxcells -1
    incr nycells -1

    set x1    $scaling($w,xmin)
    set x2    [expr {($scaling($w,xmax) - $x1)/10.0}]

    foreach {fill border} $scaling($w,colours) {break}

    #
    # Draw the quadrangles making up the data in the right order:
    # first y from minimum to maximum
    # then x from maximum to minimum
    #
    for { set j 0 } { $j < $nycells } { incr j } {
	set jj [expr {$j+1}]
	set y1 [lindex $yzData $j 0]
	set y2 [lindex $yzData $jj 0]
	set z1 [lindex $yzData $j 1]
	set z2 [lindex $yzData $jj 1]

	foreach {px11 py11} [::Plotchart::coords3DToPixel $w $x1 $y1 $z1] break
	foreach {px12 py12} [::Plotchart::coords3DToPixel $w $x1 $y2 $z2] break
	foreach {px21 py21} [::Plotchart::coords3DToPixel $w $x2 $y1 $z1] break
	foreach {px22 py22} [::Plotchart::coords3DToPixel $w $x2 $y2 $z2] break
	$w create polygon $px11 $py11 $px21 $py21 $px22 $py22 \
	    $px12 $py12 $px11 $py11 \
	    -fill $fill -outline $border
    }
}

# Draw3DAxes --
#    Draw the axes in a 3D plot
# Arguments:
#    w           Name of the canvas
#    xmin        Minimum x coordinate
#    xmax        Maximum x coordinate
#    xstep       Step size
#    ymin        Minimum y coordinate
#    ymax        Maximum y coordinate
#    ystep       Step size
#    zmin        Minimum z coordinate
#    zmax        Maximum z coordinate
#    zstep       Step size
#    names       List of labels for the x-axis (optional)
# Result:
#    None
# Note:
#    To keep the axes in positive orientation, the x-axis appears
#    on the right-hand side and the y-axis appears in front.
#    This may not be the most "intuitive" presentation though.
# Side effects:
#    Axes drawn in canvas
#
proc ::Plotchart::Draw3DAxes { w xmin  ymin  zmin
                                 xmax  ymax  zmax
                                 xstep ystep zstep
                                 {names {}}        } {
   variable scaling

   $w delete axis3d

   #
   # Create the support lines first
   #
   foreach {pxxmin pyxmin} [coords3DToPixel $w \
				$scaling($w,xmin) $scaling($w,ymin) $scaling($w,zmin)] {break}
   foreach {pxxmax pyxmax} [coords3DToPixel $w \
				$scaling($w,xmax) $scaling($w,ymin) $scaling($w,zmin)] {break}
   foreach {pxymax pyymax} [coords3DToPixel $w \
				$scaling($w,xmax) $scaling($w,ymax) $scaling($w,zmin)] {break}
   foreach {pxzmax pyzmax} [coords3DToPixel $w \
				$scaling($w,xmax) $scaling($w,ymin) $scaling($w,zmax)] {break}
   foreach {pxzmx2 pyzmx2} [coords3DToPixel $w \
				$scaling($w,xmin) $scaling($w,ymin) $scaling($w,zmax)] {break}
   foreach {pxymx2 pyymx2} [coords3DToPixel $w \
				$scaling($w,xmin) $scaling($w,ymax) $scaling($w,zmin)] {break}
   foreach {pxzymx pyzymx} [coords3DToPixel $w \
				$scaling($w,xmax) $scaling($w,ymax) $scaling($w,zmax)] {break}

   if {$xstep > 0} {
	   $w create line $pxxmax $pyxmax $pxxmin $pyxmin -fill black -tag axis3d
	   $w create line $pxxmax $pyxmax $pxymax $pyymax -fill black -tag axis3d
	   $w create line $pxymax $pyymax $pxymx2 $pyymx2 -fill black -tag axis3d
	   $w create line $pxzmax $pyzmax $pxzymx $pyzymx -fill black -tag axis3d
	   $w create line $pxxmax $pyxmax $pxzmax $pyzmax -fill black -tag axis3d
	   $w create line $pxzmax $pyzmax $pxzmx2 $pyzmx2 -fill black -tag axis3d
	   $w create line $pxymax $pyymax $pxzymx $pyzymx -fill black -tag axis3d
   }
   $w create line $pxxmin $pyxmin $pxymx2 $pyymx2 -fill black -tag axis3d
   $w create line $pxxmin $pyxmin $pxzmx2 $pyzmx2 -fill black -tag axis3d

   #
   # Numbers to the z-axis
   #
   set z $zmin
   while { $z < $zmax+0.5*$zstep } {
      foreach {xcrd ycrd} [coords3DToPixel $w $xmin $ymin $z] {break}
      set xcrd2 [expr {$xcrd-3}]
      set xcrd3 [expr {$xcrd-5}]

      $w create line $xcrd2 $ycrd $xcrd $ycrd -tag axis3d
      $w create text $xcrd3 $ycrd -text $z -tag axis3d -anchor e
      set z [expr {$z+$zstep}]
   }

   #
   # Numbers or labels to the x-axis (shown on the right!)
   #
   if {$xstep > 0} {
      if { $names eq "" } {
          set x $xmin
          while { $x < $xmax+0.5*$xstep } {
              foreach {xcrd ycrd} [coords3DToPixel $w $x $ymax $zmin] {break}
              set xcrd2 [expr {$xcrd+4}]
              set xcrd3 [expr {$xcrd+6}]

              $w create line $xcrd2 $ycrd $xcrd $ycrd -tag axis3d
              $w create text $xcrd3 $ycrd -text $x -tag axis3d -anchor w
              set x [expr {$x+$xstep}]
          }
      } else {
          set x [expr {$xmin+0.5*$xstep}]
          foreach label $names {
              foreach {xcrd ycrd} [coords3DToPixel $w $x $ymax $zmin] {break}
              set xcrd2 [expr {$xcrd+6}]

              $w create text $xcrd2 $ycrd -text $label -tag axis3d -anchor w
              set x [expr {$x+$xstep}]
          }
      }
   }
   #
   # Numbers to the y-axis (shown in front!)
   #
   set y $ymin
   while { $y < $ymax+0.5*$ystep } {
      foreach {xcrd ycrd} [coords3DToPixel $w $xmin $y $zmin] {break}
      set ycrd2 [expr {$ycrd+3}]
      set ycrd3 [expr {$ycrd+5}]

      $w create line $xcrd $ycrd2 $xcrd $ycrd -tag axis3d
      $w create text $xcrd $ycrd3 -text $y -tag axis3d -anchor n
      set y [expr {$y+$ystep}]
   }

   set scaling($w,xstep) $xstep
   set scaling($w,ystep) $ystep
   set scaling($w,zstep) $zstep

   #
   # Set the default grid size
   #
   GridSize3D $w 10 10
}
################################################################

set taylorochs {
    243 354
    227 583 460 615 450 779 554 785 477 1115 975 1185
    986 1051
    1060 439
}
set norpell {
    986 1051 1348 1092 1294 1668 938 1626
}
set alrutz {
    159 1348
    959 1372
    937 1632
    868 2386
    628 2385
    612 2305
    193 2299
    163 2189
    85 2178
}
proc GoFoo {} {
    global foo

    .c delete a
    if {[llength $foo] > 2} {
	.c create poly $foo -tag a -fill cyan -outline black -stipple gray12
    }
}

proc Embellish {item xy tags args} {
    .c create $item $xy -tag $tags {*}$args
    .c lower [lindex $tags 0]
    .c lower maps
}
.c delete a
Embellish poly $alrutz {a alrutz} -fill #6d6 -outline black -stipple gray12
Embellish poly $norpell {a norpell} -fill #d66 -outline black -stipple gray12
Embellish poly $taylorochs {a taylorochs} -fill #66d -outline black -stipple gray12

proc List2Pos {l} {
    set r {}
    foreach {x y} $l {
	foreach {. . . . lat lon} [::Display::canvas2pos $x $y 0] break
	lappend r {*}[format "%.6f %.6f" $lat $lon]
    }
    return $r
}

.popup add command -label "Embellishment Point" -under 0 -command MyE
proc MyE {} {
    global state E

    set ll [eval ::Display::canvas2pos $::state(popup)]
    lassign $ll plat plon . . lat lon
    lappend E $lat $lon
    set xy {}
    foreach {lat lon} $E {
	lappend xy {*}[::Display::pos2canvas root $lat $lon]
    }
    .c delete a
    .c create line $xy -tag a -fill red -width 5
}


proc foo {rid} {
    set ::rid $rid; ::Zoom::Go road $rid ; Locate $rid
    foreach {nid1 nid2} $::roads($rid) break
    foreach {. . lat lon} $::nodes($nid1) break
    set from "from: $lat -$lon"
    foreach {. . lat lon} $::nodes($nid2) break
    set to "to: $lat -$lon"
    clipit "$from $to"
}


set z0 [lindex $roads($rid) 9]
set z1 $z0; list
while {1} {
    set n [lsearch $z1 0]
    if {$n == -1} break
    lset z1 $n 1
}
puts "\n$z0\n$z1"
lset roads($rid) 9 $z1

bad usgs lat/lon for elevation
  37 15 46.51 122 15 26.88
  37 11 56.06 122 15 27.03
  37 11 49.05 122 15 27.91
  37 11 54.5 122 15 26.96
  37 11 57.35 122 15 27.02
